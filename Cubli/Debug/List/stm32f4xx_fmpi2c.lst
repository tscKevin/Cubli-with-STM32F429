###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.2.214/W32 for ARM         14/Jul/2020  18:42:04
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fmpi2c.c
#    Command line =
#        -f C:\Users\Evan\AppData\Local\Temp\EW96B0.tmp
#        (E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fmpi2c.c
#        -D USE_STDPERIPH_DRIVER -D STM32F429_439xx -lC
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List
#        -o
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\IAR Systems\Embedded
#        Workbench 8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\iar\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\user\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\user\src\
#        -Ol --use_c++_inline -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List\stm32f4xx_fmpi2c.lst
#    Object file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj\stm32f4xx_fmpi2c.o
#
###############################################################################

E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fmpi2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_fmpi2c.c
      4            * @author  MCD Application Team
      5            * @version V1.8.0
      6            * @date    04-November-2016
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Inter-Integrated circuit Fast Mode Plus (FMPI2C):
      9            *           + Initialization and Configuration
     10            *           + Communications handling
     11            *           + SMBUS management
     12            *           + FMPI2C registers management
     13            *           + Data transfers management
     14            *           + DMA transfers management
     15            *           + Interrupts and flags management
     16            *
     17            *  @verbatim
     18           ============================================================================
     19                               ##### How to use this driver #####
     20           ============================================================================
     21             [..]
     22             (#) Enable peripheral clock using RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2Cx, ENABLE)
     23                 function for FMPI2C peripheral.
     24             (#) Enable SDA, SCL  and SMBA (when used) GPIO clocks using 
     25                 RCC_AHBPeriphClockCmd() function. 
     26             (#) Peripherals alternate function: 
     27                 (++) Connect the pin to the desired peripherals' Alternate 
     28                      Function (AF) using GPIO_PinAFConfig() function.
     29                 (++) Configure the desired pin in alternate function by:
     30                      GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     31                 (++) Select the type, OpenDrain and speed via 
     32                      GPIO_PuPd, GPIO_OType and GPIO_Speed members
     33                 (++) Call GPIO_Init() function.
     34             (#) Program the Mode, Timing , Own address, Ack and Acknowledged Address 
     35                 using the FMPI2C_Init() function.
     36             (#) Optionally you can enable/configure the following parameters without
     37                 re-initialization (i.e there is no need to call again FMPI2C_Init() function):
     38                 (++) Enable the acknowledge feature using FMPI2C_AcknowledgeConfig() function.
     39                 (++) Enable the dual addressing mode using FMPI2C_DualAddressCmd() function.
     40                 (++) Enable the general call using the FMPI2C_GeneralCallCmd() function.
     41                 (++) Enable the clock stretching using FMPI2C_StretchClockCmd() function.
     42                 (++) Enable the PEC Calculation using FMPI2C_CalculatePEC() function.
     43                 (++) For SMBus Mode: 
     44                      (+++) Enable the SMBusAlert pin using FMPI2C_SMBusAlertCmd() function.
     45             (#) Enable the NVIC and the corresponding interrupt using the function
     46                 FMPI2C_ITConfig() if you need to use interrupt mode.
     47             (#) When using the DMA mode 
     48                (++) Configure the DMA using DMA_Init() function.
     49                (++) Active the needed channel Request using FMPI2C_DMACmd() function.
     50             (#) Enable the FMPI2C using the FMPI2C_Cmd() function.
     51             (#) Enable the DMA using the DMA_Cmd() function when using DMA mode in the 
     52                 transfers.
     53             [..]        
     54             (@) When using FMPI2C in Fast Mode Plus, SCL and SDA pin 20mA current drive capability
     55                 must be enabled by setting the driving capability control bit in SYSCFG.
     56                 
     57              @endverbatim
     58            ******************************************************************************
     59            * @attention
     60            *
     61            * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
     62            *
     63            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     64            * You may not use this file except in compliance with the License.
     65            * You may obtain a copy of the License at:
     66            *
     67            *        http://www.st.com/software_license_agreement_liberty_v2
     68            *
     69            * Unless required by applicable law or agreed to in writing, software 
     70            * distributed under the License is distributed on an "AS IS" BASIS, 
     71            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     72            * See the License for the specific language governing permissions and
     73            * limitations under the License.
     74            *
     75            ******************************************************************************
     76            */
     77          
     78          /* Includes ------------------------------------------------------------------*/
     79          #include "stm32f4xx_fmpi2c.h"
     80          #include "stm32f4xx_rcc.h"
     81          
     82          /** @addtogroup STM32F4xx_StdPeriph_Driver
     83            * @{
     84            */
     85          
     86          /** @defgroup FMPI2C  FMPI2C
     87            * @brief FMPI2C driver modules
     88            * @{
     89            */
     90          #if defined(STM32F410xx) || defined(STM32F412xG)|| defined(STM32F413_423xx) || defined(STM32F446xx)
     91          /* Private typedef -----------------------------------------------------------*/
     92          /* Private define ------------------------------------------------------------*/
     93          
     94          #define CR1_CLEAR_MASK          ((uint32_t)0x00CFE0FF)  /*<! FMPI2C CR1 clear register Mask */
     95          #define CR2_CLEAR_MASK          ((uint32_t)0x07FF7FFF)  /*<! FMPI2C CR2 clear register Mask */
     96          #define TIMING_CLEAR_MASK       ((uint32_t)0xF0FFFFFF)  /*<! FMPI2C TIMING clear register Mask */
     97          #define ERROR_IT_MASK           ((uint32_t)0x00003F00)  /*<! FMPI2C Error interrupt register Mask */
     98          #define TC_IT_MASK              ((uint32_t)0x000000C0)  /*<! FMPI2C TC interrupt register Mask */
     99          
    100          /* Private macro -------------------------------------------------------------*/
    101          /* Private variables ---------------------------------------------------------*/
    102          /* Private function prototypes -----------------------------------------------*/
    103          /* Private functions ---------------------------------------------------------*/
    104          
    105          /** @defgroup FMPI2C_Private_Functions
    106            * @{
    107            */
    108          
    109          
    110          /** @defgroup FMPI2C_Group1 Initialization and Configuration functions
    111           *  @brief   Initialization and Configuration functions 
    112           *
    113          @verbatim   
    114           ===============================================================================
    115                     ##### Initialization and Configuration functions #####
    116           ===============================================================================
    117              [..] This section provides a set of functions allowing to initialize the FMPI2C Mode,
    118                   FMPI2C Timing, FMPI2C filters, FMPI2C Addressing mode, FMPI2C OwnAddress1.
    119          
    120              [..] The FMPI2C_Init() function follows the FMPI2C configuration procedures (these procedures 
    121                   are available in reference manual).
    122                   
    123              [..] When the Software Reset is performed using FMPI2C_SoftwareResetCmd() function, the internal
    124                   states machines are reset and communication control bits, as well as status bits come 
    125                   back to their reset value.
    126                   
    127              [..] Before enabling Stop mode using FMPI2C_StopModeCmd() FMPI2C Clock source must be set to
    128                   HSI and Digital filters must be disabled.
    129                   
    130              [..] Before enabling Own Address 2 via FMPI2C_DualAddressCmd() function, OA2 and mask should be
    131                   configured using FMPI2C_OwnAddress2Config() function.
    132                   
    133              [..] FMPI2C_SlaveByteControlCmd() enable Slave byte control that allow user to get control of 
    134                   each byte in slave mode when NBYTES is set to 0x01. 
    135                       
    136          @endverbatim
    137            * @{
    138            */
    139          
    140          /**
    141            * @brief  Deinitializes the FMPI2Cx peripheral registers to their default reset values.
    142            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    143            * @retval None
    144            */
    145          void FMPI2C_DeInit(FMPI2C_TypeDef* FMPI2Cx)
    146          {
    147            /* Check the parameters */
    148            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    149          
    150            if (FMPI2Cx == FMPI2C1)
    151            {
    152              /* Enable FMPI2C1 reset state */
    153              RCC_APB1PeriphResetCmd(RCC_APB1Periph_FMPI2C1, ENABLE);
    154              /* Release FMPI2C1 from reset state */
    155              RCC_APB1PeriphResetCmd(RCC_APB1Periph_FMPI2C1, DISABLE);      
    156            }
    157          }
    158          
    159          /**
    160            * @brief  Initializes the FMPI2Cx peripheral according to the specified
    161            *         parameters in the FMPI2C_InitStruct.
    162            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    163            * @param  FMPI2C_InitStruct: pointer to a FMPI2C_InitTypeDef structure that
    164            *         contains the configuration information for the specified FMPI2C peripheral.
    165            * @retval None
    166            */
    167          void FMPI2C_Init(FMPI2C_TypeDef* FMPI2Cx, FMPI2C_InitTypeDef* FMPI2C_InitStruct)
    168          {
    169            uint32_t tmpreg = 0;
    170          
    171            /* Check the parameters */
    172            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    173            assert_param(IS_FMPI2C_ANALOG_FILTER(FMPI2C_InitStruct->FMPI2C_AnalogFilter));
    174            assert_param(IS_FMPI2C_DIGITAL_FILTER(FMPI2C_InitStruct->FMPI2C_DigitalFilter));
    175            assert_param(IS_FMPI2C_MODE(FMPI2C_InitStruct->FMPI2C_Mode));
    176            assert_param(IS_FMPI2C_OWN_ADDRESS1(FMPI2C_InitStruct->FMPI2C_OwnAddress1));
    177            assert_param(IS_FMPI2C_ACK(FMPI2C_InitStruct->FMPI2C_Ack));
    178            assert_param(IS_FMPI2C_ACKNOWLEDGE_ADDRESS(FMPI2C_InitStruct->FMPI2C_AcknowledgedAddress));
    179          
    180            /* Disable FMPI2Cx Peripheral */
    181            FMPI2Cx->CR1 &= (uint32_t)~((uint32_t)FMPI2C_CR1_PE);
    182          
    183            /*---------------------------- FMPI2Cx FILTERS Configuration ------------------*/
    184            /* Get the FMPI2Cx CR1 value */
    185            tmpreg = FMPI2Cx->CR1;
    186            /* Clear FMPI2Cx CR1 register */
    187            tmpreg &= CR1_CLEAR_MASK;
    188            /* Configure FMPI2Cx: analog and digital filter */
    189            /* Set ANFOFF bit according to FMPI2C_AnalogFilter value */
    190            /* Set DFN bits according to FMPI2C_DigitalFilter value */
    191            tmpreg |= (uint32_t)FMPI2C_InitStruct->FMPI2C_AnalogFilter |(FMPI2C_InitStruct->FMPI2C_DigitalFilter << 8);
    192            
    193            /* Write to FMPI2Cx CR1 */
    194            FMPI2Cx->CR1 = tmpreg;
    195          
    196            /*---------------------------- FMPI2Cx TIMING Configuration -------------------*/
    197            /* Configure FMPI2Cx: Timing */
    198            /* Set TIMINGR bits according to FMPI2C_Timing */
    199            /* Write to FMPI2Cx TIMING */
    200            FMPI2Cx->TIMINGR = FMPI2C_InitStruct->FMPI2C_Timing & TIMING_CLEAR_MASK;
    201          
    202            /* Enable FMPI2Cx Peripheral */
    203            FMPI2Cx->CR1 |= FMPI2C_CR1_PE;
    204          
    205            /*---------------------------- FMPI2Cx OAR1 Configuration ---------------------*/
    206            /* Clear tmpreg local variable */
    207            tmpreg = 0;
    208            /* Clear OAR1 register */
    209            FMPI2Cx->OAR1 = (uint32_t)tmpreg;
    210            /* Clear OAR2 register */
    211            FMPI2Cx->OAR2 = (uint32_t)tmpreg;
    212            /* Configure FMPI2Cx: Own Address1 and acknowledged address */
    213            /* Set OA1MODE bit according to FMPI2C_AcknowledgedAddress value */
    214            /* Set OA1 bits according to FMPI2C_OwnAddress1 value */
    215            tmpreg = (uint32_t)((uint32_t)FMPI2C_InitStruct->FMPI2C_AcknowledgedAddress | \
    216                                (uint32_t)FMPI2C_InitStruct->FMPI2C_OwnAddress1);
    217            /* Write to FMPI2Cx OAR1 */
    218            FMPI2Cx->OAR1 = tmpreg;
    219            /* Enable Own Address1 acknowledgement */
    220            FMPI2Cx->OAR1 |= FMPI2C_OAR1_OA1EN;
    221          
    222            /*---------------------------- FMPI2Cx MODE Configuration ---------------------*/
    223            /* Configure FMPI2Cx: mode */
    224            /* Set SMBDEN and SMBHEN bits according to FMPI2C_Mode value */
    225            tmpreg = FMPI2C_InitStruct->FMPI2C_Mode;
    226            /* Write to FMPI2Cx CR1 */
    227            FMPI2Cx->CR1 |= tmpreg;
    228          
    229            /*---------------------------- FMPI2Cx ACK Configuration ----------------------*/
    230            /* Get the FMPI2Cx CR2 value */
    231            tmpreg = FMPI2Cx->CR2;
    232            /* Clear FMPI2Cx CR2 register */
    233            tmpreg &= CR2_CLEAR_MASK;
    234            /* Configure FMPI2Cx: acknowledgement */
    235            /* Set NACK bit according to FMPI2C_Ack value */
    236            tmpreg |= FMPI2C_InitStruct->FMPI2C_Ack;
    237            /* Write to FMPI2Cx CR2 */
    238            FMPI2Cx->CR2 = tmpreg;
    239          }
    240          
    241          /**
    242            * @brief  Fills each FMPI2C_InitStruct member with its default value.
    243            * @param  FMPI2C_InitStruct: pointer to an FMPI2C_InitTypeDef structure which will be initialized.
    244            * @retval None
    245            */
    246          void FMPI2C_StructInit(FMPI2C_InitTypeDef* FMPI2C_InitStruct)
    247          {
    248            /*---------------- Reset FMPI2C init structure parameters values --------------*/
    249            /* Initialize the FMPI2C_Timing member */
    250            FMPI2C_InitStruct->FMPI2C_Timing = 0;
    251            /* Initialize the FMPI2C_AnalogFilter member */
    252            FMPI2C_InitStruct->FMPI2C_AnalogFilter = FMPI2C_AnalogFilter_Enable;
    253            /* Initialize the FMPI2C_DigitalFilter member */
    254            FMPI2C_InitStruct->FMPI2C_DigitalFilter = 0;
    255            /* Initialize the FMPI2C_Mode member */
    256            FMPI2C_InitStruct->FMPI2C_Mode = FMPI2C_Mode_FMPI2C;
    257            /* Initialize the FMPI2C_OwnAddress1 member */
    258            FMPI2C_InitStruct->FMPI2C_OwnAddress1 = 0;
    259            /* Initialize the FMPI2C_Ack member */
    260            FMPI2C_InitStruct->FMPI2C_Ack = FMPI2C_Ack_Disable;
    261            /* Initialize the FMPI2C_AcknowledgedAddress member */
    262            FMPI2C_InitStruct->FMPI2C_AcknowledgedAddress = FMPI2C_AcknowledgedAddress_7bit;
    263          }
    264          
    265          /**
    266            * @brief  Enables or disables the specified FMPI2C peripheral.
    267            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    268            * @param  NewState: new state of the FMPI2Cx peripheral. 
    269            *   This parameter can be: ENABLE or DISABLE.
    270            * @retval None
    271            */
    272          void FMPI2C_Cmd(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    273          {
    274            /* Check the parameters */
    275            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    276            assert_param(IS_FUNCTIONAL_STATE(NewState));
    277            if (NewState != DISABLE)
    278            {
    279              /* Enable the selected FMPI2C peripheral */
    280              FMPI2Cx->CR1 |= FMPI2C_CR1_PE;
    281            }
    282            else
    283            {
    284              /* Disable the selected FMPI2C peripheral */
    285              FMPI2Cx->CR1 &= (uint32_t)~((uint32_t)FMPI2C_CR1_PE);
    286            }
    287          }
    288          
    289          
    290          /**
    291            * @brief  Enables or disables the specified FMPI2C software reset.
    292            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    293            * @retval None
    294            */
    295          void FMPI2C_SoftwareResetCmd(FMPI2C_TypeDef* FMPI2Cx)
    296          {
    297            /* Check the parameters */
    298            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    299          
    300            /* Disable peripheral */
    301            FMPI2Cx->CR1 &= (uint32_t)~((uint32_t)FMPI2C_CR1_PE);
    302          
    303            /* Perform a dummy read to delay the disable of peripheral for minimum
    304               3 APB clock cycles to perform the software reset functionality */
    305            *(__IO uint32_t *)(uint32_t)FMPI2Cx; 
    306          
    307            /* Enable peripheral */
    308            FMPI2Cx->CR1 |= FMPI2C_CR1_PE;
    309          }
    310          
    311          /**
    312            * @brief  Enables or disables the specified FMPI2C interrupts.
    313            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    314            * @param  FMPI2C_IT: specifies the FMPI2C interrupts sources to be enabled or disabled. 
    315            *   This parameter can be any combination of the following values:
    316            *     @arg FMPI2C_IT_ERRI: Error interrupt mask
    317            *     @arg FMPI2C_IT_TCI: Transfer Complete interrupt mask
    318            *     @arg FMPI2C_IT_STOPI: Stop Detection interrupt mask
    319            *     @arg FMPI2C_IT_NACKI: Not Acknowledge received interrupt mask
    320            *     @arg FMPI2C_IT_ADDRI: Address Match interrupt mask  
    321            *     @arg FMPI2C_IT_RXI: RX interrupt mask
    322            *     @arg FMPI2C_IT_TXI: TX interrupt mask
    323            * @param  NewState: new state of the specified FMPI2C interrupts.
    324            *   This parameter can be: ENABLE or DISABLE.
    325            * @retval None
    326            */
    327          void FMPI2C_ITConfig(FMPI2C_TypeDef* FMPI2Cx, uint32_t FMPI2C_IT, FunctionalState NewState)
    328          {
    329            /* Check the parameters */
    330            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    331            assert_param(IS_FUNCTIONAL_STATE(NewState));
    332            assert_param(IS_FMPI2C_CONFIG_IT(FMPI2C_IT));
    333            
    334            if (NewState != DISABLE)
    335            {
    336              /* Enable the selected FMPI2C interrupts */
    337              FMPI2Cx->CR1 |= FMPI2C_IT;
    338            }
    339            else
    340            {
    341              /* Disable the selected FMPI2C interrupts */
    342              FMPI2Cx->CR1 &= (uint32_t)~((uint32_t)FMPI2C_IT);
    343            }
    344          }
    345          
    346          /**
    347            * @brief  Enables or disables the FMPI2C Clock stretching.
    348            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    349            * @param  NewState: new state of the FMPI2Cx Clock stretching.
    350            *   This parameter can be: ENABLE or DISABLE.
    351            * @retval None
    352            */
    353          void FMPI2C_StretchClockCmd(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    354          {
    355            /* Check the parameters */
    356            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    357            assert_param(IS_FUNCTIONAL_STATE(NewState));
    358            
    359            if (NewState != DISABLE)
    360            {
    361              /* Enable clock stretching */
    362              FMPI2Cx->CR1 &= (uint32_t)~((uint32_t)FMPI2C_CR1_NOSTRETCH);    
    363            }
    364            else
    365            {
    366              /* Disable clock stretching  */
    367              FMPI2Cx->CR1 |= FMPI2C_CR1_NOSTRETCH;
    368            }
    369          }
    370          
    371          /**
    372            * @brief  Enables or disables the FMPI2C own address 2.
    373            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    374            * @param  NewState: new state of the FMPI2C own address 2.
    375            *   This parameter can be: ENABLE or DISABLE.  
    376            * @retval None
    377            */
    378          void FMPI2C_DualAddressCmd(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    379          {
    380            /* Check the parameters */
    381            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    382            assert_param(IS_FUNCTIONAL_STATE(NewState));
    383            
    384            if (NewState != DISABLE)
    385            {
    386              /* Enable own address 2 */
    387              FMPI2Cx->OAR2 |= FMPI2C_OAR2_OA2EN;
    388            }
    389            else
    390            {
    391              /* Disable own address 2 */
    392              FMPI2Cx->OAR2 &= (uint32_t)~((uint32_t)FMPI2C_OAR2_OA2EN);
    393            }
    394          }    
    395          
    396          /**
    397            * @brief  Configures the FMPI2C slave own address 2 and mask.
    398            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    399            * @param  Address: specifies the slave address to be programmed.
    400            * @param  Mask: specifies own address 2 mask to be programmed.
    401            *   This parameter can be one of the following values:
    402            *     @arg FMPI2C_OA2_NoMask: no mask.
    403            *     @arg FMPI2C_OA2_Mask01: OA2[1] is masked and don't care.
    404            *     @arg FMPI2C_OA2_Mask02: OA2[2:1] are masked and don't care.
    405            *     @arg FMPI2C_OA2_Mask03: OA2[3:1] are masked and don't care.
    406            *     @arg FMPI2C_OA2_Mask04: OA2[4:1] are masked and don't care.
    407            *     @arg FMPI2C_OA2_Mask05: OA2[5:1] are masked and don't care.
    408            *     @arg FMPI2C_OA2_Mask06: OA2[6:1] are masked and don't care.
    409            *     @arg FMPI2C_OA2_Mask07: OA2[7:1] are masked and don't care.
    410            * @retval None
    411            */
    412          void FMPI2C_OwnAddress2Config(FMPI2C_TypeDef* FMPI2Cx, uint16_t Address, uint8_t Mask)
    413          {
    414            uint32_t tmpreg = 0;
    415          
    416            /* Check the parameters */
    417            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    418            assert_param(IS_FMPI2C_OWN_ADDRESS2(Address));
    419            assert_param(IS_FMPI2C_OWN_ADDRESS2_MASK(Mask));
    420            
    421            /* Get the old register value */
    422            tmpreg = FMPI2Cx->OAR2;
    423          
    424            /* Reset FMPI2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
    425            tmpreg &= (uint32_t)~((uint32_t)(FMPI2C_OAR2_OA2 | FMPI2C_OAR2_OA2MSK));
    426          
    427            /* Set FMPI2Cx SADD */
    428            tmpreg |= (uint32_t)(((uint32_t)Address & FMPI2C_OAR2_OA2) | \
    429                      (((uint32_t)Mask << 8) & FMPI2C_OAR2_OA2MSK)) ;
    430          
    431            /* Store the new register value */
    432            FMPI2Cx->OAR2 = tmpreg;
    433          }
    434          
    435          /**
    436            * @brief  Enables or disables the FMPI2C general call mode.
    437            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    438            * @param  NewState: new state of the FMPI2C general call mode.
    439            *   This parameter can be: ENABLE or DISABLE.  
    440            * @retval None
    441            */
    442          void FMPI2C_GeneralCallCmd(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    443          {
    444            /* Check the parameters */
    445            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    446            assert_param(IS_FUNCTIONAL_STATE(NewState));
    447            
    448            if (NewState != DISABLE)
    449            {
    450              /* Enable general call mode */
    451              FMPI2Cx->CR1 |= FMPI2C_CR1_GCEN;
    452            }
    453            else
    454            {
    455              /* Disable general call mode */
    456              FMPI2Cx->CR1 &= (uint32_t)~((uint32_t)FMPI2C_CR1_GCEN);
    457            }
    458          } 
    459          
    460          /**
    461            * @brief  Enables or disables the FMPI2C slave byte control.
    462            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    463            * @param  NewState: new state of the FMPI2C slave byte control.
    464            *   This parameter can be: ENABLE or DISABLE.  
    465            * @retval None
    466            */
    467          void FMPI2C_SlaveByteControlCmd(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    468          {
    469            /* Check the parameters */
    470            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    471            assert_param(IS_FUNCTIONAL_STATE(NewState));
    472            
    473            if (NewState != DISABLE)
    474            {
    475              /* Enable slave byte control */
    476              FMPI2Cx->CR1 |= FMPI2C_CR1_SBC;
    477            }
    478            else
    479            {
    480              /* Disable slave byte control */
    481              FMPI2Cx->CR1 &= (uint32_t)~((uint32_t)FMPI2C_CR1_SBC);
    482            }
    483          }
    484          
    485          /**
    486            * @brief  Configures the slave address to be transmitted after start generation.
    487            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    488            * @param  Address: specifies the slave address to be programmed.
    489            * @note   This function should be called before generating start condition.  
    490            * @retval None
    491            */
    492          void FMPI2C_SlaveAddressConfig(FMPI2C_TypeDef* FMPI2Cx, uint16_t Address)
    493          {
    494            uint32_t tmpreg = 0;
    495          
    496            /* Check the parameters */
    497            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    498            assert_param(IS_FMPI2C_SLAVE_ADDRESS(Address));
    499                         
    500            /* Get the old register value */
    501            tmpreg = FMPI2Cx->CR2;
    502          
    503            /* Reset FMPI2Cx SADD bit [9:0] */
    504            tmpreg &= (uint32_t)~((uint32_t)FMPI2C_CR2_SADD);
    505          
    506            /* Set FMPI2Cx SADD */
    507            tmpreg |= (uint32_t)((uint32_t)Address & FMPI2C_CR2_SADD);
    508          
    509            /* Store the new register value */
    510            FMPI2Cx->CR2 = tmpreg;
    511          }
    512            
    513          /**
    514            * @brief  Enables or disables the FMPI2C 10-bit addressing mode for the master.
    515            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    516            * @param  NewState: new state of the FMPI2C 10-bit addressing mode.
    517            *   This parameter can be: ENABLE or DISABLE.
    518            * @note   This function should be called before generating start condition.  
    519            * @retval None
    520            */
    521          void FMPI2C_10BitAddressingModeCmd(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    522          {
    523            /* Check the parameters */
    524            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    525            assert_param(IS_FUNCTIONAL_STATE(NewState));
    526            
    527            if (NewState != DISABLE)
    528            {
    529              /* Enable 10-bit addressing mode */
    530              FMPI2Cx->CR2 |= FMPI2C_CR2_ADD10;
    531            }
    532            else
    533            {
    534              /* Disable 10-bit addressing mode */
    535              FMPI2Cx->CR2 &= (uint32_t)~((uint32_t)FMPI2C_CR2_ADD10);
    536            }
    537          } 
    538          
    539          /**
    540            * @}
    541            */
    542          
    543          
    544          /** @defgroup FMPI2C_Group2 Communications handling functions
    545           *  @brief   Communications handling functions 
    546           *
    547          @verbatim
    548           ===============================================================================
    549                            ##### Communications handling functions #####
    550           ===============================================================================  
    551              [..] This section provides a set of functions that handles FMPI2C communication.
    552              
    553              [..] Automatic End mode is enabled using FMPI2C_AutoEndCmd() function. When Reload
    554                   mode is enabled via FMPI2C_ReloadCmd() AutoEnd bit has no effect.
    555                   
    556              [..] FMPI2C_NumberOfBytesConfig() function set the number of bytes to be transferred,
    557                   this configuration should be done before generating start condition in master 
    558                   mode.
    559                   
    560              [..] When switching from master write operation to read operation in 10Bit addressing
    561                   mode, master can only sends the 1st 7 bits of the 10 bit address, followed by 
    562                   Read direction by enabling HEADR bit using FMPI2C_10BitAddressHeader() function.        
    563                   
    564              [..] In master mode, when transferring more than 255 bytes Reload mode should be used
    565                   to handle communication. In the first phase of transfer, Nbytes should be set to 
    566                   255. After transferring these bytes TCR flag is set and FMPI2C_TransferHandling()
    567                   function should be called to handle remaining communication.
    568                   
    569              [..] In master mode, when software end mode is selected when all data is transferred
    570                   TC flag is set FMPI2C_TransferHandling() function should be called to generate STOP
    571                   or generate ReStart.                      
    572                       
    573          @endverbatim
    574            * @{
    575            */
    576            
    577          /**
    578            * @brief  Enables or disables the FMPI2C automatic end mode (stop condition is 
    579            *         automatically sent when nbytes data are transferred).
    580            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    581            * @param  NewState: new state of the FMPI2C automatic end mode.
    582            *   This parameter can be: ENABLE or DISABLE.
    583            * @note   This function has effect if Reload mode is disabled.   
    584            * @retval None
    585            */
    586          void FMPI2C_AutoEndCmd(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    587          {
    588            /* Check the parameters */
    589            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    590            assert_param(IS_FUNCTIONAL_STATE(NewState));
    591            
    592            if (NewState != DISABLE)
    593            {
    594              /* Enable Auto end mode */
    595              FMPI2Cx->CR2 |= FMPI2C_CR2_AUTOEND;
    596            }
    597            else
    598            {
    599              /* Disable Auto end mode */
    600              FMPI2Cx->CR2 &= (uint32_t)~((uint32_t)FMPI2C_CR2_AUTOEND);
    601            }
    602          } 
    603          
    604          /**
    605            * @brief  Enables or disables the FMPI2C nbytes reload mode.
    606            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    607            * @param  NewState: new state of the nbytes reload mode.
    608            *   This parameter can be: ENABLE or DISABLE.
    609            * @retval None
    610            */
    611          void FMPI2C_ReloadCmd(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    612          {
    613            /* Check the parameters */
    614            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    615            assert_param(IS_FUNCTIONAL_STATE(NewState));
    616            
    617            if (NewState != DISABLE)
    618            {
    619              /* Enable Auto Reload mode */
    620              FMPI2Cx->CR2 |= FMPI2C_CR2_RELOAD;
    621            }
    622            else
    623            {
    624              /* Disable Auto Reload mode */
    625              FMPI2Cx->CR2 &= (uint32_t)~((uint32_t)FMPI2C_CR2_RELOAD);
    626            }
    627          }
    628          
    629          /**
    630            * @brief  Configures the number of bytes to be transmitted/received.
    631            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    632            * @param  Number_Bytes: specifies the number of bytes to be programmed.
    633            * @retval None
    634            */
    635          void FMPI2C_NumberOfBytesConfig(FMPI2C_TypeDef* FMPI2Cx, uint8_t Number_Bytes)
    636          {
    637            uint32_t tmpreg = 0;
    638          
    639            /* Check the parameters */
    640            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    641          
    642            /* Get the old register value */
    643            tmpreg = FMPI2Cx->CR2;
    644          
    645            /* Reset FMPI2Cx Nbytes bit [7:0] */
    646            tmpreg &= (uint32_t)~((uint32_t)FMPI2C_CR2_NBYTES);
    647          
    648            /* Set FMPI2Cx Nbytes */
    649            tmpreg |= (uint32_t)(((uint32_t)Number_Bytes << 16 ) & FMPI2C_CR2_NBYTES);
    650          
    651            /* Store the new register value */
    652            FMPI2Cx->CR2 = tmpreg;
    653          }  
    654            
    655          /**
    656            * @brief  Configures the type of transfer request for the master.
    657            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    658            * @param  FMPI2C_Direction: specifies the transfer request direction to be programmed.
    659            *    This parameter can be one of the following values:
    660            *     @arg FMPI2C_Direction_Transmitter: Master request a write transfer
    661            *     @arg FMPI2C_Direction_Receiver: Master request a read transfer 
    662            * @retval None
    663            */
    664          void FMPI2C_MasterRequestConfig(FMPI2C_TypeDef* FMPI2Cx, uint16_t FMPI2C_Direction)
    665          {
    666          /* Check the parameters */
    667            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    668            assert_param(IS_FMPI2C_DIRECTION(FMPI2C_Direction));
    669            
    670            /* Test on the direction to set/reset the read/write bit */
    671            if (FMPI2C_Direction == FMPI2C_Direction_Transmitter)
    672            {
    673              /* Request a write Transfer */
    674              FMPI2Cx->CR2 &= (uint32_t)~((uint32_t)FMPI2C_CR2_RD_WRN);
    675            }
    676            else
    677            {
    678              /* Request a read Transfer */
    679              FMPI2Cx->CR2 |= FMPI2C_CR2_RD_WRN;
    680            }
    681          }  
    682            
    683          /**
    684            * @brief  Generates FMPI2Cx communication START condition.
    685            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    686            * @param  NewState: new state of the FMPI2C START condition generation.
    687            *   This parameter can be: ENABLE or DISABLE.
    688            * @retval None
    689            */
    690          void FMPI2C_GenerateSTART(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    691          {
    692            /* Check the parameters */
    693            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    694            assert_param(IS_FUNCTIONAL_STATE(NewState));
    695            
    696            if (NewState != DISABLE)
    697            {
    698              /* Generate a START condition */
    699              FMPI2Cx->CR2 |= FMPI2C_CR2_START;
    700            }
    701            else
    702            {
    703              /* Disable the START condition generation */
    704              FMPI2Cx->CR2 &= (uint32_t)~((uint32_t)FMPI2C_CR2_START);
    705            }
    706          }  
    707            
    708          /**
    709            * @brief  Generates FMPI2Cx communication STOP condition.
    710            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    711            * @param  NewState: new state of the FMPI2C STOP condition generation.
    712            *   This parameter can be: ENABLE or DISABLE.
    713            * @retval None
    714            */
    715          void FMPI2C_GenerateSTOP(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    716          {
    717            /* Check the parameters */
    718            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    719            assert_param(IS_FUNCTIONAL_STATE(NewState));
    720            
    721            if (NewState != DISABLE)
    722            {
    723              /* Generate a STOP condition */
    724              FMPI2Cx->CR2 |= FMPI2C_CR2_STOP;
    725            }
    726            else
    727            {
    728              /* Disable the STOP condition generation */
    729              FMPI2Cx->CR2 &= (uint32_t)~((uint32_t)FMPI2C_CR2_STOP);
    730            }
    731          }  
    732          
    733          /**
    734            * @brief  Enables or disables the FMPI2C 10-bit header only mode with read direction.
    735            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    736            * @param  NewState: new state of the FMPI2C 10-bit header only mode.
    737            *   This parameter can be: ENABLE or DISABLE.
    738            * @note   This mode can be used only when switching from master transmitter mode 
    739            *         to master receiver mode.        
    740            * @retval None
    741            */
    742          void FMPI2C_10BitAddressHeaderCmd(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    743          {
    744            /* Check the parameters */
    745            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    746            assert_param(IS_FUNCTIONAL_STATE(NewState));
    747            
    748            if (NewState != DISABLE)
    749            {
    750              /* Enable 10-bit header only mode */
    751              FMPI2Cx->CR2 |= FMPI2C_CR2_HEAD10R;
    752            }
    753            else
    754            {
    755              /* Disable 10-bit header only mode */
    756              FMPI2Cx->CR2 &= (uint32_t)~((uint32_t)FMPI2C_CR2_HEAD10R);
    757            }
    758          }    
    759          
    760          /**
    761            * @brief  Generates FMPI2C communication Acknowledge.
    762            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    763            * @param  NewState: new state of the Acknowledge.
    764            *   This parameter can be: ENABLE or DISABLE.  
    765            * @retval None
    766            */
    767          void FMPI2C_AcknowledgeConfig(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    768          {
    769            /* Check the parameters */
    770            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    771            assert_param(IS_FUNCTIONAL_STATE(NewState));
    772            
    773            if (NewState != DISABLE)
    774            {
    775              /* Enable ACK generation */
    776              FMPI2Cx->CR2 &= (uint32_t)~((uint32_t)FMPI2C_CR2_NACK);    
    777            }
    778            else
    779            {
    780              /* Enable NACK generation */
    781              FMPI2Cx->CR2 |= FMPI2C_CR2_NACK;
    782            }
    783          }
    784          
    785          /**
    786            * @brief  Returns the FMPI2C slave matched address .
    787            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    788            * @retval The value of the slave matched address .
    789            */
    790          uint8_t FMPI2C_GetAddressMatched(FMPI2C_TypeDef* FMPI2Cx)
    791          {
    792            /* Check the parameters */
    793            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    794            
    795            /* Return the slave matched address in the SR1 register */
    796            return (uint8_t)(((uint32_t)FMPI2Cx->ISR & FMPI2C_ISR_ADDCODE) >> 16) ;
    797          }
    798          
    799          /**
    800            * @brief  Returns the FMPI2C slave received request.
    801            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    802            * @retval The value of the received request.
    803            */
    804          uint16_t FMPI2C_GetTransferDirection(FMPI2C_TypeDef* FMPI2Cx)
    805          {
    806            uint32_t tmpreg = 0;
    807            uint16_t direction = 0;
    808            
    809            /* Check the parameters */
    810            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    811            
    812            /* Return the slave matched address in the SR1 register */
    813            tmpreg = (uint32_t)(FMPI2Cx->ISR & FMPI2C_ISR_DIR);
    814            
    815            /* If write transfer is requested */
    816            if (tmpreg == 0)
    817            {
    818              /* write transfer is requested */
    819              direction = FMPI2C_Direction_Transmitter;
    820            }
    821            else
    822            {
    823              /* Read transfer is requested */
    824              direction = FMPI2C_Direction_Receiver;
    825            }  
    826            return direction;
    827          }
    828          
    829          /**
    830            * @brief  Handles FMPI2Cx communication when starting transfer or during transfer (TC or TCR flag are set).
    831            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    832            * @param  Address: specifies the slave address to be programmed.
    833            * @param  Number_Bytes: specifies the number of bytes to be programmed.
    834            *   This parameter must be a value between 0 and 255.
    835            * @param  ReloadEndMode: new state of the FMPI2C START condition generation.
    836            *   This parameter can be one of the following values:
    837            *     @arg FMPI2C_Reload_Mode: Enable Reload mode .
    838            *     @arg FMPI2C_AutoEnd_Mode: Enable Automatic end mode.
    839            *     @arg FMPI2C_SoftEnd_Mode: Enable Software end mode.
    840            * @param  StartStopMode: new state of the FMPI2C START condition generation.
    841            *   This parameter can be one of the following values:
    842            *     @arg FMPI2C_No_StartStop: Don't Generate stop and start condition.
    843            *     @arg FMPI2C_Generate_Stop: Generate stop condition (Number_Bytes should be set to 0).
    844            *     @arg FMPI2C_Generate_Start_Read: Generate Restart for read request.
    845            *     @arg FMPI2C_Generate_Start_Write: Generate Restart for write request.
    846            * @retval None
    847            */
    848          void FMPI2C_TransferHandling(FMPI2C_TypeDef* FMPI2Cx, uint16_t Address, uint8_t Number_Bytes, uint32_t ReloadEndMode, uint32_t StartStopMode)
    849          {
    850            uint32_t tmpreg = 0;
    851            
    852            /* Check the parameters */
    853            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    854            assert_param(IS_FMPI2C_SLAVE_ADDRESS(Address));  
    855            assert_param(IS_RELOAD_END_MODE(ReloadEndMode));
    856            assert_param(IS_START_STOP_MODE(StartStopMode));
    857              
    858            /* Get the CR2 register value */
    859            tmpreg = FMPI2Cx->CR2;
    860            
    861            /* clear tmpreg specific bits */
    862            tmpreg &= (uint32_t)~((uint32_t)(FMPI2C_CR2_SADD | FMPI2C_CR2_NBYTES | FMPI2C_CR2_RELOAD | FMPI2C_CR2_AUTOEND | FMPI2C_CR2_RD_WRN | FMPI2C_CR2_START | FMPI2C_CR2_STOP));
    863            
    864            /* update tmpreg */
    865            tmpreg |= (uint32_t)(((uint32_t)Address & FMPI2C_CR2_SADD) | (((uint32_t)Number_Bytes << 16 ) & FMPI2C_CR2_NBYTES) | \
    866                      (uint32_t)ReloadEndMode | (uint32_t)StartStopMode);
    867            
    868            /* update CR2 register */
    869            FMPI2Cx->CR2 = tmpreg;  
    870          }  
    871          
    872          /**
    873            * @}
    874            */
    875          
    876          
    877          /** @defgroup FMPI2C_Group3 SMBUS management functions
    878           *  @brief   SMBUS management functions 
    879           *
    880          @verbatim
    881           ===============================================================================
    882                                ##### SMBUS management functions #####
    883           ===============================================================================   
    884              [..] This section provides a set of functions that handles SMBus communication
    885                   and timeouts detection.
    886              
    887              [..] The SMBus Device default address (0b1100 001) is enabled by calling FMPI2C_Init()
    888                   function and setting FMPI2C_Mode member of FMPI2C_InitTypeDef() structure to 
    889                   FMPI2C_Mode_SMBusDevice.
    890                   
    891              [..] The SMBus Host address (0b0001 000) is enabled by calling FMPI2C_Init()
    892                   function and setting FMPI2C_Mode member of FMPI2C_InitTypeDef() structure to 
    893                   FMPI2C_Mode_SMBusHost.         
    894                   
    895              [..] The Alert Response Address (0b0001 100) is enabled using FMPI2C_SMBusAlertCmd()
    896                   function.
    897                   
    898              [..] To detect cumulative SCL stretch in master and slave mode, TIMEOUTB should be 
    899                   configured (in accordance to SMBus specification) using FMPI2C_TimeoutBConfig() 
    900                   function then FMPI2C_ExtendedClockTimeoutCmd() function should be called to enable
    901                   the detection.
    902                   
    903              [..] SCL low timeout is detected by configuring TIMEOUTB using FMPI2C_TimeoutBConfig()
    904                   function followed by the call of FMPI2C_ClockTimeoutCmd(). When adding to this 
    905                   procedure the call of FMPI2C_IdleClockTimeoutCmd() function, Bus Idle condition 
    906                   (both SCL and SDA high) is detected also.                
    907                                    
    908          @endverbatim
    909            * @{
    910            */
    911          
    912          /**
    913            * @brief  Enables or disables FMPI2C SMBus alert.
    914            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    915            * @param  NewState: new state of the FMPI2Cx SMBus alert.
    916            *   This parameter can be: ENABLE or DISABLE.
    917            * @retval None
    918            */
    919          void FMPI2C_SMBusAlertCmd(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    920          {
    921            /* Check the parameters */
    922            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    923            assert_param(IS_FUNCTIONAL_STATE(NewState));
    924            
    925            if (NewState != DISABLE)
    926            {
    927              /* Enable SMBus alert */
    928              FMPI2Cx->CR1 |= FMPI2C_CR1_ALERTEN;   
    929            }
    930            else
    931            {
    932              /* Disable SMBus alert */    
    933              FMPI2Cx->CR1 &= (uint32_t)~((uint32_t)FMPI2C_CR1_ALERTEN); 
    934            }
    935          }
    936          
    937          /**
    938            * @brief  Enables or disables FMPI2C Clock Timeout (SCL Timeout detection).
    939            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    940            * @param  NewState: new state of the FMPI2Cx clock Timeout.
    941            *   This parameter can be: ENABLE or DISABLE.
    942            * @retval None
    943            */
    944          void FMPI2C_ClockTimeoutCmd(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    945          {
    946            /* Check the parameters */
    947            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    948            assert_param(IS_FUNCTIONAL_STATE(NewState));
    949            
    950            if (NewState != DISABLE)
    951            {
    952              /* Enable Clock Timeout */
    953              FMPI2Cx->TIMEOUTR |= FMPI2C_TIMEOUTR_TIMOUTEN;   
    954            }
    955            else
    956            {
    957              /* Disable Clock Timeout */    
    958              FMPI2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)FMPI2C_TIMEOUTR_TIMOUTEN); 
    959            }
    960          }
    961          
    962          /**
    963            * @brief  Enables or disables FMPI2C Extended Clock Timeout (SCL cumulative Timeout detection).
    964            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    965            * @param  NewState: new state of the FMPI2Cx Extended clock Timeout.
    966            *   This parameter can be: ENABLE or DISABLE.
    967            * @retval None
    968            */
    969          void FMPI2C_ExtendedClockTimeoutCmd(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    970          {
    971            /* Check the parameters */
    972            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    973            assert_param(IS_FUNCTIONAL_STATE(NewState));
    974            
    975            if (NewState != DISABLE)
    976            {
    977              /* Enable Clock Timeout */
    978              FMPI2Cx->TIMEOUTR |= FMPI2C_TIMEOUTR_TEXTEN;   
    979            }
    980            else
    981            {
    982              /* Disable Clock Timeout */    
    983              FMPI2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)FMPI2C_TIMEOUTR_TEXTEN); 
    984            }
    985          }
    986          
    987          /**
    988            * @brief  Enables or disables FMPI2C Idle Clock Timeout (Bus idle SCL and SDA 
    989            *         high detection).
    990            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
    991            * @param  NewState: new state of the FMPI2Cx Idle clock Timeout.
    992            *   This parameter can be: ENABLE or DISABLE.
    993            * @retval None
    994            */
    995          void FMPI2C_IdleClockTimeoutCmd(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
    996          {
    997            /* Check the parameters */
    998            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
    999            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1000            
   1001            if (NewState != DISABLE)
   1002            {
   1003              /* Enable Clock Timeout */
   1004              FMPI2Cx->TIMEOUTR |= FMPI2C_TIMEOUTR_TIDLE;   
   1005            }
   1006            else
   1007            {
   1008              /* Disable Clock Timeout */    
   1009              FMPI2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)FMPI2C_TIMEOUTR_TIDLE); 
   1010            }
   1011          }
   1012          
   1013          /**
   1014            * @brief  Configures the FMPI2C Bus Timeout A (SCL Timeout when TIDLE = 0 or Bus 
   1015            *   idle SCL and SDA high when TIDLE = 1).
   1016            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
   1017            * @param  Timeout: specifies the TimeoutA to be programmed. 
   1018            * @retval None
   1019            */
   1020          void FMPI2C_TimeoutAConfig(FMPI2C_TypeDef* FMPI2Cx, uint16_t Timeout)
   1021          {
   1022            uint32_t tmpreg = 0;
   1023          
   1024            /* Check the parameters */
   1025            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
   1026            assert_param(IS_FMPI2C_TIMEOUT(Timeout));
   1027              
   1028            /* Get the old register value */
   1029            tmpreg = FMPI2Cx->TIMEOUTR;
   1030          
   1031            /* Reset FMPI2Cx TIMEOUTA bit [11:0] */
   1032            tmpreg &= (uint32_t)~((uint32_t)FMPI2C_TIMEOUTR_TIMEOUTA);
   1033          
   1034            /* Set FMPI2Cx TIMEOUTA */
   1035            tmpreg |= (uint32_t)((uint32_t)Timeout & FMPI2C_TIMEOUTR_TIMEOUTA) ;
   1036          
   1037            /* Store the new register value */
   1038            FMPI2Cx->TIMEOUTR = tmpreg;
   1039          }
   1040          
   1041          /**
   1042            * @brief  Configures the FMPI2C Bus Timeout B (SCL cumulative Timeout).
   1043            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
   1044            * @param  Timeout: specifies the TimeoutB to be programmed. 
   1045            * @retval None
   1046            */
   1047          void FMPI2C_TimeoutBConfig(FMPI2C_TypeDef* FMPI2Cx, uint16_t Timeout)
   1048          {
   1049            uint32_t tmpreg = 0;
   1050          
   1051            /* Check the parameters */
   1052            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
   1053            assert_param(IS_FMPI2C_TIMEOUT(Timeout));
   1054          
   1055            /* Get the old register value */
   1056            tmpreg = FMPI2Cx->TIMEOUTR;
   1057          
   1058            /* Reset FMPI2Cx TIMEOUTB bit [11:0] */
   1059            tmpreg &= (uint32_t)~((uint32_t)FMPI2C_TIMEOUTR_TIMEOUTB);
   1060          
   1061            /* Set FMPI2Cx TIMEOUTB */
   1062            tmpreg |= (uint32_t)(((uint32_t)Timeout << 16) & FMPI2C_TIMEOUTR_TIMEOUTB) ;
   1063          
   1064            /* Store the new register value */
   1065            FMPI2Cx->TIMEOUTR = tmpreg;
   1066          }
   1067          
   1068          /**
   1069            * @brief  Enables or disables FMPI2C PEC calculation.
   1070            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
   1071            * @param  NewState: new state of the FMPI2Cx PEC calculation.
   1072            *   This parameter can be: ENABLE or DISABLE.
   1073            * @retval None
   1074            */
   1075          void FMPI2C_CalculatePEC(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
   1076          {
   1077            /* Check the parameters */
   1078            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
   1079            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1080            
   1081            if (NewState != DISABLE)
   1082            {
   1083              /* Enable PEC calculation */
   1084              FMPI2Cx->CR1 |= FMPI2C_CR1_PECEN;   
   1085            }
   1086            else
   1087            {
   1088              /* Disable PEC calculation */    
   1089              FMPI2Cx->CR1 &= (uint32_t)~((uint32_t)FMPI2C_CR1_PECEN); 
   1090            }
   1091          }
   1092          
   1093          /**
   1094            * @brief  Enables or disables FMPI2C PEC transmission/reception request.
   1095            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
   1096            * @param  NewState: new state of the FMPI2Cx PEC request.
   1097            *   This parameter can be: ENABLE or DISABLE.
   1098            * @retval None
   1099            */
   1100          void FMPI2C_PECRequestCmd(FMPI2C_TypeDef* FMPI2Cx, FunctionalState NewState)
   1101          {
   1102            /* Check the parameters */
   1103            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
   1104            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1105            
   1106            if (NewState != DISABLE)
   1107            {
   1108              /* Enable PEC transmission/reception request */
   1109              FMPI2Cx->CR1 |= FMPI2C_CR2_PECBYTE;   
   1110            }
   1111            else
   1112            {
   1113              /* Disable PEC transmission/reception request */    
   1114              FMPI2Cx->CR1 &= (uint32_t)~((uint32_t)FMPI2C_CR2_PECBYTE); 
   1115            }
   1116          }
   1117          
   1118          /**
   1119            * @brief  Returns the FMPI2C PEC.
   1120            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
   1121            * @retval The value of the PEC .
   1122            */
   1123          uint8_t FMPI2C_GetPEC(FMPI2C_TypeDef* FMPI2Cx)
   1124          {
   1125            /* Check the parameters */
   1126            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
   1127            
   1128            /* Return the slave matched address in the SR1 register */
   1129            return (uint8_t)((uint32_t)FMPI2Cx->PECR & FMPI2C_PECR_PEC);
   1130          }
   1131          
   1132          /**
   1133            * @}
   1134            */  
   1135            
   1136            
   1137          /** @defgroup FMPI2C_Group4 FMPI2C registers management functions
   1138           *  @brief   FMPI2C registers management functions 
   1139           *
   1140          @verbatim
   1141           ===============================================================================
   1142                          ##### FMPI2C registers management functions #####
   1143           ===============================================================================  
   1144              [..] This section provides a functions that allow user the management of 
   1145                   FMPI2C registers.
   1146                   
   1147          @endverbatim
   1148            * @{
   1149            */
   1150          
   1151            /**
   1152            * @brief  Reads the specified FMPI2C register and returns its value.
   1153            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
   1154            * @param  FMPI2C_Register: specifies the register to read.
   1155            *   This parameter can be one of the following values:
   1156            *     @arg FMPI2C_Register_CR1: CR1 register.
   1157            *     @arg FMPI2C_Register_CR2: CR2 register.
   1158            *     @arg FMPI2C_Register_OAR1: OAR1 register.
   1159            *     @arg FMPI2C_Register_OAR2: OAR2 register.
   1160            *     @arg FMPI2C_Register_TIMINGR: TIMING register.
   1161            *     @arg FMPI2C_Register_TIMEOUTR: TIMEOUTR register.
   1162            *     @arg FMPI2C_Register_ISR: ISR register.
   1163            *     @arg FMPI2C_Register_ICR: ICR register.
   1164            *     @arg FMPI2C_Register_PECR: PECR register.
   1165            *     @arg FMPI2C_Register_RXDR: RXDR register.
   1166            *     @arg FMPI2C_Register_TXDR: TXDR register.
   1167            * @retval The value of the read register.
   1168            */
   1169          uint32_t FMPI2C_ReadRegister(FMPI2C_TypeDef* FMPI2Cx, uint8_t FMPI2C_Register)
   1170          {
   1171            __IO uint32_t tmp = 0;
   1172          
   1173            /* Check the parameters */
   1174            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
   1175            assert_param(IS_FMPI2C_REGISTER(FMPI2C_Register));
   1176          
   1177            tmp = (uint32_t)FMPI2Cx;
   1178            tmp += FMPI2C_Register;
   1179          
   1180            /* Return the selected register value */
   1181            return (*(__IO uint32_t *) tmp);
   1182          }
   1183          
   1184          /**
   1185            * @}
   1186            */  
   1187            
   1188          /** @defgroup FMPI2C_Group5 Data transfers management functions
   1189           *  @brief   Data transfers management functions 
   1190           *
   1191          @verbatim
   1192           ===============================================================================
   1193                          ##### Data transfers management functions #####
   1194           =============================================================================== 
   1195              [..] This subsection provides a set of functions allowing to manage 
   1196                   the FMPI2C data transfers.
   1197                   
   1198              [..] The read access of the FMPI2C_RXDR register can be done using 
   1199                   the FMPI2C_ReceiveData() function and returns the received value.
   1200                   Whereas a write access to the FMPI2C_TXDR can be done using FMPI2C_SendData()
   1201                   function and stores the written data into TXDR.
   1202          @endverbatim
   1203            * @{
   1204            */  
   1205            
   1206          /**
   1207            * @brief  Sends a data byte through the FMPI2Cx peripheral.
   1208            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
   1209            * @param  Data: Byte to be transmitted..
   1210            * @retval None
   1211            */
   1212          void FMPI2C_SendData(FMPI2C_TypeDef* FMPI2Cx, uint8_t Data)
   1213          {
   1214            /* Check the parameters */
   1215            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
   1216            
   1217            /* Write in the DR register the data to be sent */
   1218            FMPI2Cx->TXDR = (uint8_t)Data;
   1219          }
   1220          
   1221          /**
   1222            * @brief  Returns the most recent received data by the FMPI2Cx peripheral.
   1223            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
   1224            * @retval The value of the received data.
   1225            */
   1226          uint8_t FMPI2C_ReceiveData(FMPI2C_TypeDef* FMPI2Cx)
   1227          {
   1228            /* Check the parameters */
   1229            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
   1230            
   1231            /* Return the data in the DR register */
   1232            return (uint8_t)FMPI2Cx->RXDR;
   1233          }  
   1234          
   1235          /**
   1236            * @}
   1237            */ 
   1238            
   1239            
   1240          /** @defgroup FMPI2C_Group6 DMA transfers management functions
   1241           *  @brief   DMA transfers management functions 
   1242           *
   1243          @verbatim
   1244           ===============================================================================
   1245                         ##### DMA transfers management functions #####
   1246           ===============================================================================  
   1247              [..] This section provides two functions that can be used only in DMA mode.
   1248              [..] In DMA Mode, the FMPI2C communication can be managed by 2 DMA Channel 
   1249                   requests:
   1250                   (#) FMPI2C_DMAReq_Tx: specifies the Tx buffer DMA transfer request.
   1251                   (#) FMPI2C_DMAReq_Rx: specifies the Rx buffer DMA transfer request.
   1252              [..] In this Mode it is advised to use the following function:
   1253                   (+) FMPI2C_DMACmd(FMPI2C_TypeDef* FMPI2Cx, uint32_t FMPI2C_DMAReq, FunctionalState NewState);
   1254          @endverbatim
   1255            * @{
   1256            */  
   1257              
   1258          /**
   1259            * @brief  Enables or disables the FMPI2C DMA interface.
   1260            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
   1261            * @param  FMPI2C_DMAReq: specifies the FMPI2C DMA transfer request to be enabled or disabled. 
   1262            *   This parameter can be any combination of the following values:
   1263            *     @arg FMPI2C_DMAReq_Tx: Tx DMA transfer request
   1264            *     @arg FMPI2C_DMAReq_Rx: Rx DMA transfer request
   1265            * @param  NewState: new state of the selected FMPI2C DMA transfer request.
   1266            *         This parameter can be: ENABLE or DISABLE.
   1267            * @retval None
   1268            */
   1269          void FMPI2C_DMACmd(FMPI2C_TypeDef* FMPI2Cx, uint32_t FMPI2C_DMAReq, FunctionalState NewState)
   1270          {
   1271            /* Check the parameters */
   1272            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
   1273            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1274            assert_param(IS_FMPI2C_DMA_REQ(FMPI2C_DMAReq));
   1275          
   1276            if (NewState != DISABLE)
   1277            {
   1278              /* Enable the selected FMPI2C DMA requests */
   1279              FMPI2Cx->CR1 |= FMPI2C_DMAReq;
   1280            }
   1281            else
   1282            {
   1283              /* Disable the selected FMPI2C DMA requests */
   1284              FMPI2Cx->CR1 &= (uint32_t)~FMPI2C_DMAReq;
   1285            }
   1286          }
   1287          /**
   1288            * @}
   1289            */  
   1290          
   1291          
   1292          /** @defgroup FMPI2C_Group7 Interrupts and flags management functions
   1293           *  @brief   Interrupts and flags management functions 
   1294           *
   1295          @verbatim
   1296           ===============================================================================
   1297                       ##### Interrupts and flags management functions  #####
   1298           =============================================================================== 
   1299              [..] This section provides functions allowing to configure the FMPI2C Interrupts 
   1300                   sources and check or clear the flags or pending bits status.
   1301                   The user should identify which mode will be used in his application to manage 
   1302                   the communication: Polling mode, Interrupt mode or DMA mode(refer FMPI2C_Group6) .
   1303          
   1304            *** Polling Mode ***
   1305            ====================
   1306              [..] In Polling Mode, the FMPI2C communication can be managed by 15 flags:
   1307                  (#) FMPI2C_FLAG_TXE: to indicate the status of Transmit data register empty flag.
   1308                  (#) FMPI2C_FLAG_TXIS: to indicate the status of Transmit interrupt status flag .
   1309                  (#) FMPI2C_FLAG_RXNE: to indicate the status of Receive data register not empty flag.
   1310                  (#) FMPI2C_FLAG_ADDR: to indicate the status of Address matched flag (slave mode).
   1311                  (#) FMPI2C_FLAG_NACKF: to indicate the status of NACK received flag.
   1312                  (#) FMPI2C_FLAG_STOPF: to indicate the status of STOP detection flag.
   1313                  (#) FMPI2C_FLAG_TC: to indicate the status of Transfer complete flag(master mode).
   1314                  (#) FMPI2C_FLAG_TCR: to indicate the status of Transfer complete reload flag.
   1315                  (#) FMPI2C_FLAG_BERR: to indicate the status of Bus error flag.
   1316                  (#) FMPI2C_FLAG_ARLO: to indicate the status of Arbitration lost flag.
   1317                  (#) FMPI2C_FLAG_OVR: to indicate the status of Overrun/Underrun flag.
   1318                  (#) FMPI2C_FLAG_PECERR: to indicate the status of PEC error in reception flag.
   1319                  (#) FMPI2C_FLAG_TIMEOUT: to indicate the status of Timeout or Tlow detection flag.
   1320                  (#) FMPI2C_FLAG_ALERT: to indicate the status of SMBus Alert flag.
   1321                  (#) FMPI2C_FLAG_BUSY: to indicate the status of Bus busy flag.
   1322          
   1323              [..] In this Mode it is advised to use the following functions:
   1324                  (+) FlagStatus FMPI2C_GetFlagStatus(FMPI2C_TypeDef* FMPI2Cx, uint32_t FMPI2C_FLAG);
   1325                  (+) void FMPI2C_ClearFlag(FMPI2C_TypeDef* FMPI2Cx, uint32_t FMPI2C_FLAG);
   1326          
   1327              [..]
   1328                  (@)Do not use the BUSY flag to handle each data transmission or reception.It is 
   1329                     better to use the TXIS and RXNE flags instead.
   1330          
   1331            *** Interrupt Mode ***
   1332            ======================
   1333              [..] In Interrupt Mode, the FMPI2C communication can be managed by 7 interrupt sources
   1334                   and 15 pending bits: 
   1335              [..] Interrupt Source:
   1336                  (#) FMPI2C_IT_ERRI: specifies the interrupt source for the Error interrupt.
   1337                  (#) FMPI2C_IT_TCI: specifies the interrupt source for the Transfer Complete interrupt.
   1338                  (#) FMPI2C_IT_STOPI: specifies the interrupt source for the Stop Detection interrupt.
   1339                  (#) FMPI2C_IT_NACKI: specifies the interrupt source for the Not Acknowledge received interrupt.
   1340                  (#) FMPI2C_IT_ADDRI: specifies the interrupt source for the Address Match interrupt.  
   1341                  (#) FMPI2C_IT_RXI: specifies the interrupt source for the RX interrupt.
   1342                  (#) FMPI2C_IT_TXI: specifies the interrupt source for the TX interrupt.
   1343          
   1344              [..] Pending Bits:
   1345                  (#) FMPI2C_IT_TXIS: to indicate the status of Transmit interrupt status flag.
   1346                  (#) FMPI2C_IT_RXNE: to indicate the status of Receive data register not empty flag.
   1347                  (#) FMPI2C_IT_ADDR: to indicate the status of Address matched flag (slave mode).
   1348                  (#) FMPI2C_IT_NACKF: to indicate the status of NACK received flag.
   1349                  (#) FMPI2C_IT_STOPF: to indicate the status of STOP detection flag.
   1350                  (#) FMPI2C_IT_TC: to indicate the status of Transfer complete flag (master mode).
   1351                  (#) FMPI2C_IT_TCR: to indicate the status of Transfer complete reload flag.
   1352                  (#) FMPI2C_IT_BERR: to indicate the status of Bus error flag.
   1353                  (#) FMPI2C_IT_ARLO: to indicate the status of Arbitration lost flag.
   1354                  (#) FMPI2C_IT_OVR: to indicate the status of Overrun/Underrun flag.
   1355                  (#) FMPI2C_IT_PECERR: to indicate the status of PEC error in reception flag.
   1356                  (#) FMPI2C_IT_TIMEOUT: to indicate the status of Timeout or Tlow detection flag.
   1357                  (#) FMPI2C_IT_ALERT: to indicate the status of SMBus Alert flag.
   1358          
   1359              [..] In this Mode it is advised to use the following functions:
   1360                   (+) void FMPI2C_ClearITPendingBit(FMPI2C_TypeDef* FMPI2Cx, uint32_t FMPI2C_IT);
   1361                   (+) ITStatus FMPI2C_GetITStatus(FMPI2C_TypeDef* FMPI2Cx, uint32_t FMPI2C_IT);
   1362          
   1363          @endverbatim
   1364            * @{
   1365            */  
   1366          
   1367          /**
   1368            * @brief  Checks whether the specified FMPI2C flag is set or not.
   1369            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
   1370            * @param  FMPI2C_FLAG: specifies the flag to check. 
   1371            *   This parameter can be one of the following values:
   1372            *     @arg FMPI2C_FLAG_TXE: Transmit data register empty
   1373            *     @arg FMPI2C_FLAG_TXIS: Transmit interrupt status
   1374            *     @arg FMPI2C_FLAG_RXNE: Receive data register not empty
   1375            *     @arg FMPI2C_FLAG_ADDR: Address matched (slave mode)
   1376            *     @arg FMPI2C_FLAG_NACKF: NACK received flag
   1377            *     @arg FMPI2C_FLAG_STOPF: STOP detection flag
   1378            *     @arg FMPI2C_FLAG_TC: Transfer complete (master mode)
   1379            *     @arg FMPI2C_FLAG_TCR: Transfer complete reload
   1380            *     @arg FMPI2C_FLAG_BERR: Bus error
   1381            *     @arg FMPI2C_FLAG_ARLO: Arbitration lost
   1382            *     @arg FMPI2C_FLAG_OVR: Overrun/Underrun
   1383            *     @arg FMPI2C_FLAG_PECERR: PEC error in reception
   1384            *     @arg FMPI2C_FLAG_TIMEOUT: Timeout or Tlow detection flag
   1385            *     @arg FMPI2C_FLAG_ALERT: SMBus Alert
   1386            *     @arg FMPI2C_FLAG_BUSY: Bus busy
   1387            * @retval The new state of FMPI2C_FLAG (SET or RESET).
   1388            */
   1389          FlagStatus FMPI2C_GetFlagStatus(FMPI2C_TypeDef* FMPI2Cx, uint32_t FMPI2C_FLAG)
   1390          {
   1391            uint32_t tmpreg = 0;
   1392            FlagStatus bitstatus = RESET;
   1393            
   1394            /* Check the parameters */
   1395            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
   1396            assert_param(IS_FMPI2C_GET_FLAG(FMPI2C_FLAG));
   1397            
   1398            /* Get the ISR register value */
   1399            tmpreg = FMPI2Cx->ISR;
   1400            
   1401            /* Get flag status */
   1402            tmpreg &= FMPI2C_FLAG;
   1403            
   1404            if(tmpreg != 0)
   1405            {
   1406              /* FMPI2C_FLAG is set */
   1407              bitstatus = SET;
   1408            }
   1409            else
   1410            {
   1411              /* FMPI2C_FLAG is reset */
   1412              bitstatus = RESET;
   1413            }
   1414            return bitstatus;
   1415          }  
   1416            
   1417          /**
   1418            * @brief  Clears the FMPI2Cx's pending flags.
   1419            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
   1420            * @param  FMPI2C_FLAG: specifies the flag to clear. 
   1421            *   This parameter can be any combination of the following values:
   1422            *     @arg FMPI2C_FLAG_ADDR: Address matched (slave mode)
   1423            *     @arg FMPI2C_FLAG_NACKF: NACK received flag
   1424            *     @arg FMPI2C_FLAG_STOPF: STOP detection flag
   1425            *     @arg FMPI2C_FLAG_BERR: Bus error
   1426            *     @arg FMPI2C_FLAG_ARLO: Arbitration lost
   1427            *     @arg FMPI2C_FLAG_OVR: Overrun/Underrun
   1428            *     @arg FMPI2C_FLAG_PECERR: PEC error in reception
   1429            *     @arg FMPI2C_FLAG_TIMEOUT: Timeout or Tlow detection flag
   1430            *     @arg FMPI2C_FLAG_ALERT: SMBus Alert
   1431            * @retval The new state of FMPI2C_FLAG (SET or RESET).
   1432            */
   1433          void FMPI2C_ClearFlag(FMPI2C_TypeDef* FMPI2Cx, uint32_t FMPI2C_FLAG)
   1434          { 
   1435            /* Check the parameters */
   1436            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
   1437            assert_param(IS_FMPI2C_CLEAR_FLAG(FMPI2C_FLAG));
   1438          
   1439            /* Clear the selected flag */
   1440            FMPI2Cx->ICR = FMPI2C_FLAG;
   1441            }
   1442          
   1443          /**
   1444            * @brief  Checks whether the specified FMPI2C interrupt has occurred or not.
   1445            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
   1446            * @param  FMPI2C_IT: specifies the interrupt source to check.
   1447            *   This parameter can be one of the following values:
   1448            *     @arg FMPI2C_IT_TXIS: Transmit interrupt status
   1449            *     @arg FMPI2C_IT_RXNE: Receive data register not empty
   1450            *     @arg FMPI2C_IT_ADDR: Address matched (slave mode)
   1451            *     @arg FMPI2C_IT_NACKF: NACK received flag
   1452            *     @arg FMPI2C_IT_STOPF: STOP detection flag
   1453            *     @arg FMPI2C_IT_TC: Transfer complete (master mode)
   1454            *     @arg FMPI2C_IT_TCR: Transfer complete reload
   1455            *     @arg FMPI2C_IT_BERR: Bus error
   1456            *     @arg FMPI2C_IT_ARLO: Arbitration lost
   1457            *     @arg FMPI2C_IT_OVR: Overrun/Underrun
   1458            *     @arg FMPI2C_IT_PECERR: PEC error in reception
   1459            *     @arg FMPI2C_IT_TIMEOUT: Timeout or Tlow detection flag
   1460            *     @arg FMPI2C_IT_ALERT: SMBus Alert
   1461            * @retval The new state of FMPI2C_IT (SET or RESET).
   1462            */
   1463          ITStatus FMPI2C_GetITStatus(FMPI2C_TypeDef* FMPI2Cx, uint32_t FMPI2C_IT)
   1464          {
   1465            uint32_t tmpreg = 0;
   1466            ITStatus bitstatus = RESET;
   1467            uint32_t enablestatus = 0;
   1468          
   1469            /* Check the parameters */
   1470            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
   1471            assert_param(IS_FMPI2C_GET_IT(FMPI2C_IT));
   1472          
   1473            /* Check if the interrupt source is enabled or not */
   1474            /* If Error interrupt */
   1475            if((uint32_t)(FMPI2C_IT & ERROR_IT_MASK))
   1476            {
   1477              enablestatus = (uint32_t)((FMPI2C_CR1_ERRIE) & (FMPI2Cx->CR1));
   1478            }
   1479            /* If TC interrupt */
   1480            else if((uint32_t)(FMPI2C_IT & TC_IT_MASK))
   1481            {
   1482              enablestatus = (uint32_t)((FMPI2C_CR1_TCIE) & (FMPI2Cx->CR1));
   1483            }
   1484            else
   1485            {
   1486              enablestatus = (uint32_t)((FMPI2C_IT) & (FMPI2Cx->CR1));
   1487            }
   1488            
   1489            /* Get the ISR register value */
   1490            tmpreg = FMPI2Cx->ISR;
   1491          
   1492            /* Get flag status */
   1493            tmpreg &= FMPI2C_IT;
   1494          
   1495            /* Check the status of the specified FMPI2C flag */
   1496            if((tmpreg != RESET) && enablestatus)
   1497            {
   1498              /* FMPI2C_IT is set */
   1499              bitstatus = SET;
   1500            }
   1501            else
   1502            {
   1503              /* FMPI2C_IT is reset */
   1504              bitstatus = RESET;
   1505            }
   1506          
   1507            /* Return the FMPI2C_IT status */
   1508            return bitstatus;
   1509          }
   1510            
   1511          /**
   1512            * @brief  Clears the FMPI2Cx's interrupt pending bits.
   1513            * @param  FMPI2Cx: where x can be 1 to select the FMPI2C peripheral.
   1514            * @param  FMPI2C_IT: specifies the interrupt pending bit to clear.
   1515            *   This parameter can be any combination of the following values:
   1516            *     @arg FMPI2C_IT_ADDR: Address matched (slave mode)
   1517            *     @arg FMPI2C_IT_NACKF: NACK received flag
   1518            *     @arg FMPI2C_IT_STOPF: STOP detection flag
   1519            *     @arg FMPI2C_IT_BERR: Bus error
   1520            *     @arg FMPI2C_IT_ARLO: Arbitration lost
   1521            *     @arg FMPI2C_IT_OVR: Overrun/Underrun
   1522            *     @arg FMPI2C_IT_PECERR: PEC error in reception
   1523            *     @arg FMPI2C_IT_TIMEOUT: Timeout or Tlow detection flag
   1524            *     @arg FMPI2C_IT_ALERT: SMBus Alert
   1525            * @retval The new state of FMPI2C_IT (SET or RESET).
   1526            */
   1527          void FMPI2C_ClearITPendingBit(FMPI2C_TypeDef* FMPI2Cx, uint32_t FMPI2C_IT)
   1528          {
   1529            /* Check the parameters */
   1530            assert_param(IS_FMPI2C_ALL_PERIPH(FMPI2Cx));
   1531            assert_param(IS_FMPI2C_CLEAR_IT(FMPI2C_IT));
   1532          
   1533            /* Clear the selected flag */
   1534            FMPI2Cx->ICR = FMPI2C_IT;
   1535          }
   1536          
   1537          /**
   1538            * @}
   1539            */  
   1540            
   1541          /**
   1542            * @}
   1543            */
   1544          #endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
   1545          
   1546          /**
   1547            * @}
   1548            */
   1549          
   1550          /**
   1551            * @}
   1552            */
   1553          
   1554          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/


 
 
 0 bytes of memory

Errors: none
Warnings: none
