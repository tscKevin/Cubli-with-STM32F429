###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.2.214/W32 for ARM         14/Jul/2020  18:42:04
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fmc.c
#    Command line =
#        -f C:\Users\Evan\AppData\Local\Temp\EW9632.tmp
#        (E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fmc.c
#        -D USE_STDPERIPH_DRIVER -D STM32F429_439xx -lC
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List
#        -o
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\IAR Systems\Embedded
#        Workbench 8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\iar\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\user\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\user\src\
#        -Ol --use_c++_inline -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List\stm32f4xx_fmc.lst
#    Object file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj\stm32f4xx_fmc.o
#
###############################################################################

E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fmc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_fmc.c
      4            * @author  MCD Application Team
      5            * @version V1.8.0
      6            * @date    04-November-2016
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the FMC peripheral:           
      9            *           + Interface with SRAM, PSRAM, NOR and OneNAND memories
     10            *           + Interface with NAND memories
     11            *           + Interface with 16-bit PC Card compatible memories 
     12            *           + Interface with SDRAM memories    
     13            *           + Interrupts and flags management   
     14            *           
     15            ******************************************************************************
     16            * @attention
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
     19            *
     20            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     21            * You may not use this file except in compliance with the License.
     22            * You may obtain a copy of the License at:
     23            *
     24            *        http://www.st.com/software_license_agreement_liberty_v2
     25            *
     26            * Unless required by applicable law or agreed to in writing, software 
     27            * distributed under the License is distributed on an "AS IS" BASIS, 
     28            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     29            * See the License for the specific language governing permissions and
     30            * limitations under the License.
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "stm32f4xx_fmc.h"
     37          #include "stm32f4xx_rcc.h"
     38          
     39          /** @addtogroup STM32F4xx_StdPeriph_Driver
     40            * @{
     41            */
     42          
     43          /** @defgroup FMC 
     44            * @brief FMC driver modules
     45            * @{
     46            */ 
     47          
     48          /* Private typedef -----------------------------------------------------------*/

   \                                 In section .rodata, align 4
     49          const FMC_NORSRAMTimingInitTypeDef FMC_DefaultTimingStruct = {0x0F, /* FMC_AddressSetupTime */
   \                     FMC_DefaultTimingStruct:
   \        0x0   0x0000'000F        DC32 15, 15, 255, 15, 15, 15, 0
   \              0x0000'000F  
   \              0x0000'00FF  
   \              0x0000'000F  
   \              0x0000'000F  
   \              0x0000'000F  
   \              0x0000'0000  
     50                                                                        0x0F, /* FMC_AddressHoldTime */
     51                                                                        0xFF, /* FMC_DataSetupTime */
     52                                                                        0x0F, /* FMC_BusTurnAroundDuration */
     53                                                                        0x0F, /* FMC_CLKDivision */
     54                                                                        0x0F, /* FMC_DataLatency */
     55                                                                        FMC_AccessMode_A /* FMC_AccessMode */
     56                                                                        };
     57          /* --------------------- FMC registers bit mask ---------------------------- */
     58          /* FMC BCRx Mask */
     59          #define BCR_MBKEN_SET              ((uint32_t)0x00000001)
     60          #define BCR_MBKEN_RESET            ((uint32_t)0x000FFFFE)
     61          #define BCR_FACCEN_SET             ((uint32_t)0x00000040)
     62          
     63          /* FMC PCRx Mask */
     64          #define PCR_PBKEN_SET              ((uint32_t)0x00000004)
     65          #define PCR_PBKEN_RESET            ((uint32_t)0x000FFFFB)
     66          #define PCR_ECCEN_SET              ((uint32_t)0x00000040)
     67          #define PCR_ECCEN_RESET            ((uint32_t)0x000FFFBF)
     68          #define PCR_MEMORYTYPE_NAND        ((uint32_t)0x00000008)
     69          
     70          /* FMC SDCRx write protection Mask*/
     71          #define SDCR_WriteProtection_RESET ((uint32_t)0x00007DFF) 
     72          
     73          /* FMC SDCMR Mask*/
     74          #define SDCMR_CTB1_RESET           ((uint32_t)0x003FFFEF)
     75          #define SDCMR_CTB2_RESET           ((uint32_t)0x003FFFF7)
     76          #define SDCMR_CTB1_2_RESET         ((uint32_t)0x003FFFE7)
     77          
     78          /* Private macro -------------------------------------------------------------*/
     79          /* Private variables ---------------------------------------------------------*/
     80          /* Private function prototypes -----------------------------------------------*/
     81          /* Private functions ---------------------------------------------------------*/
     82          
     83          /** @defgroup FMC_Private_Functions
     84            * @{
     85            */
     86          
     87          /** @defgroup FMC_Group1 NOR/SRAM Controller functions
     88            * @brief    NOR/SRAM Controller functions 
     89            *
     90          @verbatim   
     91           ===============================================================================
     92                              ##### NOR and SRAM Controller functions #####
     93           ===============================================================================  
     94          
     95           [..] The following sequence should be followed to configure the FMC to interface
     96                with SRAM, PSRAM, NOR or OneNAND memory connected to the NOR/SRAM Bank:
     97           
     98             (#) Enable the clock for the FMC and associated GPIOs using the following functions:
     99                    RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FMC, ENABLE);
    100                    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
    101          
    102             (#) FMC pins configuration 
    103                 (++) Connect the involved FMC pins to AF12 using the following function 
    104                      GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FMC); 
    105                 (++) Configure these FMC pins in alternate function mode by calling the function
    106                      GPIO_Init();    
    107                 
    108             (#) Declare a FMC_NORSRAMInitTypeDef structure, for example:
    109                    FMC_NORSRAMInitTypeDef  FMC_NORSRAMInitStructure;
    110                and fill the FMC_NORSRAMInitStructure variable with the allowed values of
    111                the structure member.
    112                
    113             (#) Initialize the NOR/SRAM Controller by calling the function
    114                    FMC_NORSRAMInit(&FMC_NORSRAMInitStructure); 
    115          
    116             (#) Then enable the NOR/SRAM Bank, for example:
    117                    FMC_NORSRAMCmd(FMC_Bank1_NORSRAM2, ENABLE);  
    118          
    119             (#) At this stage you can read/write from/to the memory connected to the NOR/SRAM Bank. 
    120             
    121          @endverbatim
    122            * @{
    123            */
    124          
    125          /**
    126            * @brief  De-initializes the FMC NOR/SRAM Banks registers to their default 
    127            *   reset values.
    128            * @param  FMC_Bank: specifies the FMC Bank to be used
    129            *          This parameter can be one of the following values:
    130            *            @arg FMC_Bank1_NORSRAM1: FMC Bank1 NOR/SRAM1  
    131            *            @arg FMC_Bank1_NORSRAM2: FMC Bank1 NOR/SRAM2 
    132            *            @arg FMC_Bank1_NORSRAM3: FMC Bank1 NOR/SRAM3 
    133            *            @arg FMC_Bank1_NORSRAM4: FMC Bank1 NOR/SRAM4 
    134            * @retval None
    135            */

   \                                 In section .text, align 2, keep-with-next
    136          void FMC_NORSRAMDeInit(uint32_t FMC_Bank)
    137          {
    138            /* Check the parameter */
    139            assert_param(IS_FMC_NORSRAM_BANK(FMC_Bank));
    140            
    141            /* FMC_Bank1_NORSRAM1 */
    142            if(FMC_Bank == FMC_Bank1_NORSRAM1)
   \                     FMC_NORSRAMDeInit: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD106             BNE.N    ??FMC_NORSRAMDeInit_0
    143            {
    144              FMC_Bank1->BTCR[FMC_Bank] = 0x000030DB;    
   \        0x4   0xF243 0x01DB      MOVW     R1,#+12507
   \        0x8   0xF05F 0x4220      MOVS     R2,#-1610612736
   \        0xC   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \       0x10   0xE005             B.N      ??FMC_NORSRAMDeInit_1
    145            }
    146            /* FMC_Bank1_NORSRAM2,  FMC_Bank1_NORSRAM3 or FMC_Bank1_NORSRAM4 */
    147            else
    148            {   
    149              FMC_Bank1->BTCR[FMC_Bank] = 0x000030D2; 
   \                     ??FMC_NORSRAMDeInit_0: (+1)
   \       0x12   0xF243 0x01D2      MOVW     R1,#+12498
   \       0x16   0xF05F 0x4220      MOVS     R2,#-1610612736
   \       0x1A   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    150            }
    151            FMC_Bank1->BTCR[FMC_Bank + 1] = 0x0FFFFFFF;
   \                     ??FMC_NORSRAMDeInit_1: (+1)
   \       0x1E   0xF07F 0x4170      MVNS     R1,#-268435456
   \       0x22   0xF05F 0x4220      MOVS     R2,#-1610612736
   \       0x26   0xEB02 0x0280      ADD      R2,R2,R0, LSL #+2
   \       0x2A   0x6051             STR      R1,[R2, #+4]
    152            FMC_Bank1E->BWTR[FMC_Bank] = 0x0FFFFFFF;  
   \       0x2C   0x....'....        LDR.W    R2,??DataTable23  ;; 0xa0000104
   \       0x30   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    153          }
   \       0x34   0x4770             BX       LR               ;; return
    154          
    155          /**
    156            * @brief  Initializes the FMC NOR/SRAM Banks according to the specified
    157            *         parameters in the FMC_NORSRAMInitStruct.
    158            * @param  FMC_NORSRAMInitStruct : pointer to a FMC_NORSRAMInitTypeDef structure
    159            *         that contains the configuration information for the FMC NOR/SRAM 
    160            *         specified Banks.                       
    161            * @retval None
    162            */

   \                                 In section .text, align 2, keep-with-next
    163          void FMC_NORSRAMInit(FMC_NORSRAMInitTypeDef* FMC_NORSRAMInitStruct)
    164          {
   \                     FMC_NORSRAMInit: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    165            uint32_t tmpr = 0, tmpbcr = 0, tmpbwr = 0;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x2100             MOVS     R1,#+0
    166            
    167            /* Check the parameters */
    168            assert_param(IS_FMC_NORSRAM_BANK(FMC_NORSRAMInitStruct->FMC_Bank));
    169            assert_param(IS_FMC_MUX(FMC_NORSRAMInitStruct->FMC_DataAddressMux));
    170            assert_param(IS_FMC_MEMORY(FMC_NORSRAMInitStruct->FMC_MemoryType));
    171            assert_param(IS_FMC_NORSRAM_MEMORY_WIDTH(FMC_NORSRAMInitStruct->FMC_MemoryDataWidth));
    172            assert_param(IS_FMC_BURSTMODE(FMC_NORSRAMInitStruct->FMC_BurstAccessMode));
    173            assert_param(IS_FMC_WAIT_POLARITY(FMC_NORSRAMInitStruct->FMC_WaitSignalPolarity));
    174            assert_param(IS_FMC_WRAP_MODE(FMC_NORSRAMInitStruct->FMC_WrapMode));
    175            assert_param(IS_FMC_WAIT_SIGNAL_ACTIVE(FMC_NORSRAMInitStruct->FMC_WaitSignalActive));
    176            assert_param(IS_FMC_WRITE_OPERATION(FMC_NORSRAMInitStruct->FMC_WriteOperation));
    177            assert_param(IS_FMC_WAITE_SIGNAL(FMC_NORSRAMInitStruct->FMC_WaitSignal));
    178            assert_param(IS_FMC_EXTENDED_MODE(FMC_NORSRAMInitStruct->FMC_ExtendedMode));
    179            assert_param(IS_FMC_ASYNWAIT(FMC_NORSRAMInitStruct->FMC_AsynchronousWait));
    180            assert_param(IS_FMC_WRITE_BURST(FMC_NORSRAMInitStruct->FMC_WriteBurst));
    181            assert_param(IS_FMC_CONTINOUS_CLOCK(FMC_NORSRAMInitStruct->FMC_ContinousClock));  
    182            assert_param(IS_FMC_ADDRESS_SETUP_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressSetupTime));
    183            assert_param(IS_FMC_ADDRESS_HOLD_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressHoldTime));
    184            assert_param(IS_FMC_DATASETUP_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataSetupTime));
    185            assert_param(IS_FMC_TURNAROUND_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_BusTurnAroundDuration));
    186            assert_param(IS_FMC_CLK_DIV(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_CLKDivision));
    187            assert_param(IS_FMC_DATA_LATENCY(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataLatency));
    188            assert_param(IS_FMC_ACCESS_MODE(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AccessMode)); 
    189            
    190            /* Get the BTCR register value */
    191            tmpbcr = FMC_Bank1->BTCR[FMC_NORSRAMInitStruct->FMC_Bank];
   \        0x8   0xF05F 0x4220      MOVS     R2,#-1610612736
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0xF852 0x3021      LDR      R3,[R2, R1, LSL #+2]
    192           
    193            /* Clear MBKEN, MUXEN, MTYP, MWID, FACCEN, BURSTEN, WAITPOL, WRAPMOD, WAITCFG, WREN,
    194                     WAITEN, EXTMOD, ASYNCWAIT, CBURSTRW and CCLKEN bits */
    195            tmpbcr &= ((uint32_t)~(FMC_BCR1_MBKEN   | FMC_BCR1_MUXEN    | FMC_BCR1_MTYP     | \
    196                                   FMC_BCR1_MWID     | FMC_BCR1_FACCEN   | FMC_BCR1_BURSTEN  | \
    197                                   FMC_BCR1_WAITPOL  | FMC_BCR1_WRAPMOD  | FMC_BCR1_WAITCFG  | \
    198                                   FMC_BCR1_WREN     | FMC_BCR1_WAITEN   | FMC_BCR1_EXTMOD   | \
    199                                   FMC_BCR1_ASYNCWAIT| FMC_BCR1_CBURSTRW | FMC_BCR1_CCLKEN));
   \       0x12   0x....'....        LDR.W    R1,??DataTable23_1  ;; 0xffe70080
   \       0x16   0x400B             ANDS     R3,R1,R3
    200          
    201            /* NOR/SRAM Bank control register configuration */ 
    202            tmpbcr |=  (uint32_t)FMC_NORSRAMInitStruct->FMC_DataAddressMux |
    203                                 FMC_NORSRAMInitStruct->FMC_MemoryType |
    204                                 FMC_NORSRAMInitStruct->FMC_MemoryDataWidth |
    205                                 FMC_NORSRAMInitStruct->FMC_BurstAccessMode |
    206                                 FMC_NORSRAMInitStruct->FMC_WaitSignalPolarity |
    207                                 FMC_NORSRAMInitStruct->FMC_WrapMode |
    208                                 FMC_NORSRAMInitStruct->FMC_WaitSignalActive |
    209                                 FMC_NORSRAMInitStruct->FMC_WriteOperation |
    210                                 FMC_NORSRAMInitStruct->FMC_WaitSignal |
    211                                 FMC_NORSRAMInitStruct->FMC_ExtendedMode |
    212                                 FMC_NORSRAMInitStruct->FMC_AsynchronousWait |
    213                                 FMC_NORSRAMInitStruct->FMC_WriteBurst |
    214                                 FMC_NORSRAMInitStruct->FMC_ContinousClock;
   \       0x18   0x6844             LDR      R4,[R0, #+4]
   \       0x1A   0x6881             LDR      R1,[R0, #+8]
   \       0x1C   0x430C             ORRS     R4,R1,R4
   \       0x1E   0x68C1             LDR      R1,[R0, #+12]
   \       0x20   0x430C             ORRS     R4,R1,R4
   \       0x22   0x6901             LDR      R1,[R0, #+16]
   \       0x24   0x430C             ORRS     R4,R1,R4
   \       0x26   0x6941             LDR      R1,[R0, #+20]
   \       0x28   0x430C             ORRS     R4,R1,R4
   \       0x2A   0x6981             LDR      R1,[R0, #+24]
   \       0x2C   0x430C             ORRS     R4,R1,R4
   \       0x2E   0x69C1             LDR      R1,[R0, #+28]
   \       0x30   0x430C             ORRS     R4,R1,R4
   \       0x32   0x6A01             LDR      R1,[R0, #+32]
   \       0x34   0x430C             ORRS     R4,R1,R4
   \       0x36   0x6A41             LDR      R1,[R0, #+36]
   \       0x38   0x430C             ORRS     R4,R1,R4
   \       0x3A   0x6A81             LDR      R1,[R0, #+40]
   \       0x3C   0x430C             ORRS     R4,R1,R4
   \       0x3E   0x6AC1             LDR      R1,[R0, #+44]
   \       0x40   0x430C             ORRS     R4,R1,R4
   \       0x42   0x6B01             LDR      R1,[R0, #+48]
   \       0x44   0x430C             ORRS     R4,R1,R4
   \       0x46   0x6B41             LDR      R1,[R0, #+52]
   \       0x48   0x430C             ORRS     R4,R1,R4
   \       0x4A   0x4323             ORRS     R3,R4,R3
    215          
    216            FMC_Bank1->BTCR[FMC_NORSRAMInitStruct->FMC_Bank] = tmpbcr;
   \       0x4C   0x6801             LDR      R1,[R0, #+0]
   \       0x4E   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
    217          
    218            if(FMC_NORSRAMInitStruct->FMC_MemoryType == FMC_MemoryType_NOR)
   \       0x52   0x6881             LDR      R1,[R0, #+8]
   \       0x54   0x2908             CMP      R1,#+8
   \       0x56   0xD107             BNE.N    ??FMC_NORSRAMInit_0
    219            {
    220              FMC_Bank1->BTCR[FMC_NORSRAMInitStruct->FMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
   \       0x58   0x6801             LDR      R1,[R0, #+0]
   \       0x5A   0xF852 0x1021      LDR      R1,[R2, R1, LSL #+2]
   \       0x5E   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0x62   0x6803             LDR      R3,[R0, #+0]
   \       0x64   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
    221            }
    222          
    223            /* Configure Continuous clock feature when bank2..4 is used */
    224            if((FMC_NORSRAMInitStruct->FMC_ContinousClock == FMC_CClock_SyncAsync) && (FMC_NORSRAMInitStruct->FMC_Bank != FMC_Bank1_NORSRAM1))
   \                     ??FMC_NORSRAMInit_0: (+1)
   \       0x68   0x6B41             LDR      R1,[R0, #+52]
   \       0x6A   0xF5B1 0x1F80      CMP      R1,#+1048576
   \       0x6E   0xD115             BNE.N    ??FMC_NORSRAMInit_1
   \       0x70   0x6801             LDR      R1,[R0, #+0]
   \       0x72   0x2900             CMP      R1,#+0
   \       0x74   0xD012             BEQ.N    ??FMC_NORSRAMInit_1
    225            {
    226              tmpr = (uint32_t)((FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1+1]) & ~(((uint32_t)0x0F) << 20));    
   \       0x76   0x....'....        LDR.W    R4,??DataTable23_2  ;; 0xa0000004
   \       0x7A   0x6823             LDR      R3,[R4, #+0]
   \       0x7C   0xF433 0x0370      BICS     R3,R3,#0xF00000
    227              
    228              FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1]  |= FMC_NORSRAMInitStruct->FMC_ContinousClock;
   \       0x80   0x6815             LDR      R5,[R2, #+0]
   \       0x82   0x6B41             LDR      R1,[R0, #+52]
   \       0x84   0x430D             ORRS     R5,R1,R5
   \       0x86   0x6015             STR      R5,[R2, #+0]
    229              FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1]  |= FMC_BurstAccessMode_Enable;
   \       0x88   0x6811             LDR      R1,[R2, #+0]
   \       0x8A   0xF451 0x7180      ORRS     R1,R1,#0x100
   \       0x8E   0x6011             STR      R1,[R2, #+0]
    230              FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1+1] = (uint32_t)(tmpr | (((FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_CLKDivision)-1) << 20));
   \       0x90   0x6B81             LDR      R1,[R0, #+56]
   \       0x92   0x6909             LDR      R1,[R1, #+16]
   \       0x94   0x1E49             SUBS     R1,R1,#+1
   \       0x96   0xEA53 0x5301      ORRS     R3,R3,R1, LSL #+20
   \       0x9A   0x6023             STR      R3,[R4, #+0]
    231            }
    232            
    233            /* NOR/SRAM Bank timing register configuration */
    234            FMC_Bank1->BTCR[FMC_NORSRAMInitStruct->FMC_Bank+1] =   
    235                      (uint32_t)FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressSetupTime |
    236                                (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressHoldTime << 4) |
    237                                (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataSetupTime << 8) |
    238                                (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_BusTurnAroundDuration << 16) |
    239                                (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_CLKDivision << 20) |
    240                                (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataLatency << 24) |
    241                                FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AccessMode;
   \                     ??FMC_NORSRAMInit_1: (+1)
   \       0x9C   0x6B81             LDR      R1,[R0, #+56]
   \       0x9E   0x680A             LDR      R2,[R1, #+0]
   \       0xA0   0x6B81             LDR      R1,[R0, #+56]
   \       0xA2   0x6849             LDR      R1,[R1, #+4]
   \       0xA4   0xEA52 0x1201      ORRS     R2,R2,R1, LSL #+4
   \       0xA8   0x6B81             LDR      R1,[R0, #+56]
   \       0xAA   0x6889             LDR      R1,[R1, #+8]
   \       0xAC   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \       0xB0   0x6B81             LDR      R1,[R0, #+56]
   \       0xB2   0x68C9             LDR      R1,[R1, #+12]
   \       0xB4   0xEA52 0x4201      ORRS     R2,R2,R1, LSL #+16
   \       0xB8   0x6B81             LDR      R1,[R0, #+56]
   \       0xBA   0x6909             LDR      R1,[R1, #+16]
   \       0xBC   0xEA52 0x5201      ORRS     R2,R2,R1, LSL #+20
   \       0xC0   0x6B81             LDR      R1,[R0, #+56]
   \       0xC2   0x6949             LDR      R1,[R1, #+20]
   \       0xC4   0xEA52 0x6201      ORRS     R2,R2,R1, LSL #+24
   \       0xC8   0x6B81             LDR      R1,[R0, #+56]
   \       0xCA   0x6989             LDR      R1,[R1, #+24]
   \       0xCC   0x430A             ORRS     R2,R1,R2
   \       0xCE   0xF05F 0x4120      MOVS     R1,#-1610612736
   \       0xD2   0x6803             LDR      R3,[R0, #+0]
   \       0xD4   0xEB01 0x0183      ADD      R1,R1,R3, LSL #+2
   \       0xD8   0x604A             STR      R2,[R1, #+4]
    242               
    243            /* NOR/SRAM Bank timing register for write configuration, if extended mode is used */
    244            if(FMC_NORSRAMInitStruct->FMC_ExtendedMode == FMC_ExtendedMode_Enable)
   \       0xDA   0x6A81             LDR      R1,[R0, #+40]
   \       0xDC   0xF5B1 0x4F80      CMP      R1,#+16384
   \       0xE0   0xD11D             BNE.N    ??FMC_NORSRAMInit_2
    245            {
    246              assert_param(IS_FMC_ADDRESS_SETUP_TIME(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressSetupTime));
    247              assert_param(IS_FMC_ADDRESS_HOLD_TIME(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressHoldTime));
    248              assert_param(IS_FMC_DATASETUP_TIME(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_DataSetupTime));
    249              assert_param(IS_FMC_TURNAROUND_TIME(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_BusTurnAroundDuration));
    250              assert_param(IS_FMC_ACCESS_MODE(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AccessMode));
    251              
    252              /* Get the BWTR register value */
    253              tmpbwr = FMC_Bank1E->BWTR[FMC_NORSRAMInitStruct->FMC_Bank];
   \       0xE2   0x....'....        LDR.W    R2,??DataTable23  ;; 0xa0000104
   \       0xE6   0x6801             LDR      R1,[R0, #+0]
   \       0xE8   0xF852 0x3021      LDR      R3,[R2, R1, LSL #+2]
    254          
    255              /* Clear ADDSET, ADDHLD, DATAST, BUSTURN and ACCMOD bits */
    256              tmpbwr &= ((uint32_t)~(FMC_BWTR1_ADDSET  | FMC_BWTR1_ADDHLD | FMC_BWTR1_DATAST | \
    257                                     FMC_BWTR1_BUSTURN | FMC_BWTR1_ACCMOD));
   \       0xEC   0x....'....        LDR.W    R1,??DataTable23_3  ;; 0xcff00000
   \       0xF0   0x400B             ANDS     R3,R1,R3
    258              
    259              tmpbwr |= (uint32_t)(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressSetupTime |
    260                                  (FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressHoldTime << 4)|
    261                                  (FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_DataSetupTime << 8) |
    262                                  (FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_BusTurnAroundDuration << 16) |
    263                                   FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AccessMode);
   \       0xF2   0x6BC1             LDR      R1,[R0, #+60]
   \       0xF4   0x680C             LDR      R4,[R1, #+0]
   \       0xF6   0x6BC1             LDR      R1,[R0, #+60]
   \       0xF8   0x6849             LDR      R1,[R1, #+4]
   \       0xFA   0xEA54 0x1401      ORRS     R4,R4,R1, LSL #+4
   \       0xFE   0x6BC1             LDR      R1,[R0, #+60]
   \      0x100   0x6889             LDR      R1,[R1, #+8]
   \      0x102   0xEA54 0x2401      ORRS     R4,R4,R1, LSL #+8
   \      0x106   0x6BC1             LDR      R1,[R0, #+60]
   \      0x108   0x68C9             LDR      R1,[R1, #+12]
   \      0x10A   0xEA54 0x4401      ORRS     R4,R4,R1, LSL #+16
   \      0x10E   0x6BC1             LDR      R1,[R0, #+60]
   \      0x110   0x6989             LDR      R1,[R1, #+24]
   \      0x112   0x430C             ORRS     R4,R1,R4
   \      0x114   0x4323             ORRS     R3,R4,R3
    264          
    265              FMC_Bank1E->BWTR[FMC_NORSRAMInitStruct->FMC_Bank] = tmpbwr;
   \      0x116   0x6800             LDR      R0,[R0, #+0]
   \      0x118   0xF842 0x3020      STR      R3,[R2, R0, LSL #+2]
   \      0x11C   0xE006             B.N      ??FMC_NORSRAMInit_3
    266            }
    267            else
    268            {
    269              FMC_Bank1E->BWTR[FMC_NORSRAMInitStruct->FMC_Bank] = 0x0FFFFFFF;
   \                     ??FMC_NORSRAMInit_2: (+1)
   \      0x11E   0xF07F 0x4170      MVNS     R1,#-268435456
   \      0x122   0x....'....        LDR.W    R2,??DataTable23  ;; 0xa0000104
   \      0x126   0x6800             LDR      R0,[R0, #+0]
   \      0x128   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    270            }
    271            
    272          }
   \                     ??FMC_NORSRAMInit_3: (+1)
   \      0x12C   0xBC30             POP      {R4,R5}
   \      0x12E   0x4770             BX       LR               ;; return
    273          
    274          /**
    275            * @brief  Fills each FMC_NORSRAMInitStruct member with its default value.
    276            * @param  FMC_NORSRAMInitStruct: pointer to a FMC_NORSRAMInitTypeDef structure 
    277            *         which will be initialized.
    278            * @retval None
    279            */

   \                                 In section .text, align 2, keep-with-next
    280          void FMC_NORSRAMStructInit(FMC_NORSRAMInitTypeDef* FMC_NORSRAMInitStruct)
    281          {  
    282            /* Reset NOR/SRAM Init structure parameters values */
    283            FMC_NORSRAMInitStruct->FMC_Bank = FMC_Bank1_NORSRAM1;
   \                     FMC_NORSRAMStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    284            FMC_NORSRAMInitStruct->FMC_DataAddressMux = FMC_DataAddressMux_Enable;
   \        0x4   0x2102             MOVS     R1,#+2
   \        0x6   0x6041             STR      R1,[R0, #+4]
    285            FMC_NORSRAMInitStruct->FMC_MemoryType = FMC_MemoryType_SRAM;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6081             STR      R1,[R0, #+8]
    286            FMC_NORSRAMInitStruct->FMC_MemoryDataWidth = FMC_NORSRAM_MemoryDataWidth_16b;
   \        0xC   0x2110             MOVS     R1,#+16
   \        0xE   0x60C1             STR      R1,[R0, #+12]
    287            FMC_NORSRAMInitStruct->FMC_BurstAccessMode = FMC_BurstAccessMode_Disable;
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x6101             STR      R1,[R0, #+16]
    288            FMC_NORSRAMInitStruct->FMC_AsynchronousWait = FMC_AsynchronousWait_Disable;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x62C1             STR      R1,[R0, #+44]
    289            FMC_NORSRAMInitStruct->FMC_WaitSignalPolarity = FMC_WaitSignalPolarity_Low;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6141             STR      R1,[R0, #+20]
    290            FMC_NORSRAMInitStruct->FMC_WrapMode = FMC_WrapMode_Disable;
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x6181             STR      R1,[R0, #+24]
    291            FMC_NORSRAMInitStruct->FMC_WaitSignalActive = FMC_WaitSignalActive_BeforeWaitState;
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x61C1             STR      R1,[R0, #+28]
    292            FMC_NORSRAMInitStruct->FMC_WriteOperation = FMC_WriteOperation_Enable;
   \       0x24   0xF44F 0x5180      MOV      R1,#+4096
   \       0x28   0x6201             STR      R1,[R0, #+32]
    293            FMC_NORSRAMInitStruct->FMC_WaitSignal = FMC_WaitSignal_Enable;
   \       0x2A   0xF44F 0x5100      MOV      R1,#+8192
   \       0x2E   0x6241             STR      R1,[R0, #+36]
    294            FMC_NORSRAMInitStruct->FMC_ExtendedMode = FMC_ExtendedMode_Disable;
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x6281             STR      R1,[R0, #+40]
    295            FMC_NORSRAMInitStruct->FMC_WriteBurst = FMC_WriteBurst_Disable;
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x6301             STR      R1,[R0, #+48]
    296            FMC_NORSRAMInitStruct->FMC_ContinousClock = FMC_CClock_SyncOnly;
   \       0x38   0x2100             MOVS     R1,#+0
   \       0x3A   0x6341             STR      R1,[R0, #+52]
    297            
    298            FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct = (FMC_NORSRAMTimingInitTypeDef*)((uint32_t)&FMC_DefaultTimingStruct);
   \       0x3C   0x....'....        LDR.W    R1,??DataTable23_4
   \       0x40   0x6381             STR      R1,[R0, #+56]
    299            FMC_NORSRAMInitStruct->FMC_WriteTimingStruct = (FMC_NORSRAMTimingInitTypeDef*)((uint32_t)&FMC_DefaultTimingStruct);
   \       0x42   0x63C1             STR      R1,[R0, #+60]
    300          }
   \       0x44   0x4770             BX       LR               ;; return
    301          
    302          /**
    303            * @brief  Enables or disables the specified NOR/SRAM Memory Bank.
    304            * @param  FMC_Bank: specifies the FMC Bank to be used
    305            *          This parameter can be one of the following values:
    306            *            @arg FMC_Bank1_NORSRAM1: FMC Bank1 NOR/SRAM1  
    307            *            @arg FMC_Bank1_NORSRAM2: FMC Bank1 NOR/SRAM2 
    308            *            @arg FMC_Bank1_NORSRAM3: FMC Bank1 NOR/SRAM3 
    309            *            @arg FMC_Bank1_NORSRAM4: FMC Bank1 NOR/SRAM4 
    310            * @param  NewState: new state of the FMC_Bank. This parameter can be: ENABLE or DISABLE.
    311            * @retval None
    312            */

   \                                 In section .text, align 2, keep-with-next
    313          void FMC_NORSRAMCmd(uint32_t FMC_Bank, FunctionalState NewState)
    314          {
    315            assert_param(IS_FMC_NORSRAM_BANK(FMC_Bank));
    316            assert_param(IS_FUNCTIONAL_STATE(NewState));
    317            
    318            if (NewState != DISABLE)
   \                     FMC_NORSRAMCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD008             BEQ.N    ??FMC_NORSRAMCmd_0
    319            {
    320              /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
    321              FMC_Bank1->BTCR[FMC_Bank] |= BCR_MBKEN_SET;
   \        0x6   0xF05F 0x4120      MOVS     R1,#-1610612736
   \        0xA   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \        0xE   0xF052 0x0201      ORRS     R2,R2,#0x1
   \       0x12   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \       0x16   0xE008             B.N      ??FMC_NORSRAMCmd_1
    322            }
    323            else
    324            {
    325              /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
    326              FMC_Bank1->BTCR[FMC_Bank] &= BCR_MBKEN_RESET;
   \                     ??FMC_NORSRAMCmd_0: (+1)
   \       0x18   0xF05F 0x4220      MOVS     R2,#-1610612736
   \       0x1C   0xF852 0x3020      LDR      R3,[R2, R0, LSL #+2]
   \       0x20   0x....'....        LDR.W    R1,??DataTable23_5  ;; 0xffffe
   \       0x24   0x400B             ANDS     R3,R1,R3
   \       0x26   0xF842 0x3020      STR      R3,[R2, R0, LSL #+2]
    327            }
    328          }
   \                     ??FMC_NORSRAMCmd_1: (+1)
   \       0x2A   0x4770             BX       LR               ;; return
    329          /**
    330            * @}
    331            */
    332          
    333          /** @defgroup FMC_Group2 NAND Controller functions
    334            * @brief    NAND Controller functions 
    335            *
    336          @verbatim   
    337           ===============================================================================
    338                              ##### NAND Controller functions #####
    339           ===============================================================================  
    340          
    341           [..]  The following sequence should be followed to configure the FMC to interface 
    342                 with 8-bit or 16-bit NAND memory connected to the NAND Bank:
    343           
    344            (#) Enable the clock for the FMC and associated GPIOs using the following functions:
    345                (++)  RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FMC, ENABLE);
    346                (++)  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
    347          
    348            (#) FMC pins configuration 
    349                (++) Connect the involved FMC pins to AF12 using the following function 
    350                     GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FMC); 
    351                (++) Configure these FMC pins in alternate function mode by calling the function
    352                     GPIO_Init();    
    353                 
    354            (#) Declare a FMC_NANDInitTypeDef structure, for example:
    355                FMC_NANDInitTypeDef  FMC_NANDInitStructure;
    356                and fill the FMC_NANDInitStructure variable with the allowed values of
    357                the structure member.
    358                
    359            (#) Initialize the NAND Controller by calling the function
    360                FMC_NANDInit(&FMC_NANDInitStructure); 
    361          
    362            (#) Then enable the NAND Bank, for example:
    363                FMC_NANDCmd(FMC_Bank3_NAND, ENABLE);  
    364          
    365            (#) At this stage you can read/write from/to the memory connected to the NAND Bank. 
    366             
    367           [..]
    368            (@) To enable the Error Correction Code (ECC), you have to use the function
    369                FMC_NANDECCCmd(FMC_Bank3_NAND, ENABLE);  
    370           [..]
    371            (@) and to get the current ECC value you have to use the function
    372                ECCval = FMC_GetECC(FMC_Bank3_NAND); 
    373          
    374          @endverbatim
    375            * @{
    376            */
    377            
    378          /**
    379            * @brief  De-initializes the FMC NAND Banks registers to their default reset values.
    380            * @param  FMC_Bank: specifies the FMC Bank to be used
    381            *          This parameter can be one of the following values:
    382            *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
    383            *            @arg FMC_Bank3_NAND: FMC Bank3 NAND 
    384            * @retval None
    385            */

   \                                 In section .text, align 2, keep-with-next
    386          void FMC_NANDDeInit(uint32_t FMC_Bank)
    387          {
    388            /* Check the parameter */
    389            assert_param(IS_FMC_NAND_BANK(FMC_Bank));
    390            
    391            if(FMC_Bank == FMC_Bank2_NAND)
   \                     FMC_NANDDeInit: (+1)
   \        0x0   0x2810             CMP      R0,#+16
   \        0x2   0xD110             BNE.N    ??FMC_NANDDeInit_0
    392            {
    393              /* Set the FMC_Bank2 registers to their reset values */
    394              FMC_Bank2->PCR2 = 0x00000018;
   \        0x4   0x2018             MOVS     R0,#+24
   \        0x6   0x....'....        LDR.W    R1,??DataTable23_6  ;; 0xa0000060
   \        0xA   0x6008             STR      R0,[R1, #+0]
    395              FMC_Bank2->SR2 = 0x00000040;
   \        0xC   0x2040             MOVS     R0,#+64
   \        0xE   0x....'....        LDR.W    R1,??DataTable23_7  ;; 0xa0000064
   \       0x12   0x6008             STR      R0,[R1, #+0]
    396              FMC_Bank2->PMEM2 = 0xFCFCFCFC;
   \       0x14   0xF05F 0x30FC      MOVS     R0,#-50529028
   \       0x18   0x....'....        LDR.W    R1,??DataTable23_8  ;; 0xa0000068
   \       0x1C   0x6008             STR      R0,[R1, #+0]
    397              FMC_Bank2->PATT2 = 0xFCFCFCFC;  
   \       0x1E   0x....'....        LDR.W    R1,??DataTable23_9  ;; 0xa000006c
   \       0x22   0x6008             STR      R0,[R1, #+0]
   \       0x24   0xE00F             B.N      ??FMC_NANDDeInit_1
    398            }
    399            /* FMC_Bank3_NAND */  
    400            else
    401            {
    402              /* Set the FMC_Bank3 registers to their reset values */
    403              FMC_Bank3->PCR3 = 0x00000018;
   \                     ??FMC_NANDDeInit_0: (+1)
   \       0x26   0x2018             MOVS     R0,#+24
   \       0x28   0x....'....        LDR.W    R1,??DataTable23_10  ;; 0xa0000080
   \       0x2C   0x6008             STR      R0,[R1, #+0]
    404              FMC_Bank3->SR3 = 0x00000040;
   \       0x2E   0x2040             MOVS     R0,#+64
   \       0x30   0x....'....        LDR.W    R1,??DataTable23_11  ;; 0xa0000084
   \       0x34   0x6008             STR      R0,[R1, #+0]
    405              FMC_Bank3->PMEM3 = 0xFCFCFCFC;
   \       0x36   0xF05F 0x30FC      MOVS     R0,#-50529028
   \       0x3A   0x....'....        LDR.W    R1,??DataTable23_12  ;; 0xa0000088
   \       0x3E   0x6008             STR      R0,[R1, #+0]
    406              FMC_Bank3->PATT3 = 0xFCFCFCFC; 
   \       0x40   0x....'....        LDR.W    R1,??DataTable23_13  ;; 0xa000008c
   \       0x44   0x6008             STR      R0,[R1, #+0]
    407            }  
    408          }
   \                     ??FMC_NANDDeInit_1: (+1)
   \       0x46   0x4770             BX       LR               ;; return
    409          
    410          /**
    411            * @brief  Initializes the FMC NAND Banks according to the specified parameters
    412            *         in the FMC_NANDInitStruct.
    413            * @param  FMC_NANDInitStruct : pointer to a FMC_NANDInitTypeDef structure that
    414            *         contains the configuration information for the FMC NAND specified Banks.                       
    415            * @retval None
    416            */

   \                                 In section .text, align 2, keep-with-next
    417          void FMC_NANDInit(FMC_NANDInitTypeDef* FMC_NANDInitStruct)
    418          {
   \                     FMC_NANDInit: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    419            uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x2100             MOVS     R1,#+0
    420              
    421            /* Check the parameters */
    422            assert_param(IS_FMC_NAND_BANK(FMC_NANDInitStruct->FMC_Bank));
    423            assert_param(IS_FMC_WAIT_FEATURE(FMC_NANDInitStruct->FMC_Waitfeature));
    424            assert_param(IS_FMC_NAND_MEMORY_WIDTH(FMC_NANDInitStruct->FMC_MemoryDataWidth));
    425            assert_param(IS_FMC_ECC_STATE(FMC_NANDInitStruct->FMC_ECC));
    426            assert_param(IS_FMC_ECCPAGE_SIZE(FMC_NANDInitStruct->FMC_ECCPageSize));
    427            assert_param(IS_FMC_TCLR_TIME(FMC_NANDInitStruct->FMC_TCLRSetupTime));
    428            assert_param(IS_FMC_TAR_TIME(FMC_NANDInitStruct->FMC_TARSetupTime));
    429            assert_param(IS_FMC_SETUP_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime));
    430            assert_param(IS_FMC_WAIT_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime));
    431            assert_param(IS_FMC_HOLD_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime));
    432            assert_param(IS_FMC_HIZ_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime));
    433            assert_param(IS_FMC_SETUP_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime));
    434            assert_param(IS_FMC_WAIT_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime));
    435            assert_param(IS_FMC_HOLD_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime));
    436            assert_param(IS_FMC_HIZ_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime));
    437          
    438            if(FMC_NANDInitStruct->FMC_Bank == FMC_Bank2_NAND)
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0x2910             CMP      R1,#+16
   \        0xC   0xD103             BNE.N    ??FMC_NANDInit_0
    439            {
    440              /* Get the NAND bank 2 register value */
    441              tmppcr = FMC_Bank2->PCR2;
   \        0xE   0x....'....        LDR.W    R1,??DataTable23_6  ;; 0xa0000060
   \       0x12   0x680A             LDR      R2,[R1, #+0]
   \       0x14   0xE002             B.N      ??FMC_NANDInit_1
    442            }
    443            else
    444            {
    445              /* Get the NAND bank 3 register value */
    446              tmppcr = FMC_Bank3->PCR3;
   \                     ??FMC_NANDInit_0: (+1)
   \       0x16   0x....'....        LDR.W    R1,??DataTable23_10  ;; 0xa0000080
   \       0x1A   0x680A             LDR      R2,[R1, #+0]
    447            }
    448            
    449            /* Clear PWAITEN, PBKEN, PTYP, PWID, ECCEN, TCLR, TAR and ECCPS bits */
    450            tmppcr &= ((uint32_t)~(FMC_PCR2_PWAITEN  | FMC_PCR2_PBKEN | FMC_PCR2_PTYP | \
    451                                 FMC_PCR2_PWID | FMC_PCR2_ECCEN | FMC_PCR2_TCLR | \
    452                                 FMC_PCR2_TAR | FMC_PCR2_ECCPS)); 
   \                     ??FMC_NANDInit_1: (+1)
   \       0x1C   0x....'....        LDR.W    R1,??DataTable23_14  ;; 0xfff00181
   \       0x20   0x400A             ANDS     R2,R1,R2
    453          
    454            /* Set the tmppcr value according to FMC_NANDInitStruct parameters */
    455            tmppcr |= (uint32_t)FMC_NANDInitStruct->FMC_Waitfeature |
    456                                PCR_MEMORYTYPE_NAND |
    457                                FMC_NANDInitStruct->FMC_MemoryDataWidth |
    458                                FMC_NANDInitStruct->FMC_ECC |
    459                                FMC_NANDInitStruct->FMC_ECCPageSize |
    460                                (FMC_NANDInitStruct->FMC_TCLRSetupTime << 9 )|
    461                                (FMC_NANDInitStruct->FMC_TARSetupTime << 13);
   \       0x22   0x6843             LDR      R3,[R0, #+4]
   \       0x24   0x6881             LDR      R1,[R0, #+8]
   \       0x26   0x430B             ORRS     R3,R1,R3
   \       0x28   0x68C1             LDR      R1,[R0, #+12]
   \       0x2A   0x430B             ORRS     R3,R1,R3
   \       0x2C   0x6901             LDR      R1,[R0, #+16]
   \       0x2E   0x430B             ORRS     R3,R1,R3
   \       0x30   0x6941             LDR      R1,[R0, #+20]
   \       0x32   0xEA53 0x2341      ORRS     R3,R3,R1, LSL #+9
   \       0x36   0x6981             LDR      R1,[R0, #+24]
   \       0x38   0xEA53 0x3341      ORRS     R3,R3,R1, LSL #+13
   \       0x3C   0xF053 0x0308      ORRS     R3,R3,#0x8
   \       0x40   0x431A             ORRS     R2,R3,R2
    462              
    463            if(FMC_NANDInitStruct->FMC_Bank == FMC_Bank2_NAND)
   \       0x42   0x6801             LDR      R1,[R0, #+0]
   \       0x44   0x2910             CMP      R1,#+16
   \       0x46   0xD103             BNE.N    ??FMC_NANDInit_2
    464            {
    465              /* Get the NAND bank 2 register value */
    466              tmppmem = FMC_Bank2->PMEM2;
   \       0x48   0x....'....        LDR.W    R1,??DataTable23_8  ;; 0xa0000068
   \       0x4C   0x6809             LDR      R1,[R1, #+0]
   \       0x4E   0xE002             B.N      ??FMC_NANDInit_3
    467            }
    468            else
    469            {
    470              /* Get the NAND bank 3 register value */
    471              tmppmem = FMC_Bank3->PMEM3;
   \                     ??FMC_NANDInit_2: (+1)
   \       0x50   0x....'....        LDR.W    R1,??DataTable23_12  ;; 0xa0000088
   \       0x54   0x6809             LDR      R1,[R1, #+0]
    472            } 
    473            
    474            /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
    475            tmppmem &= ((uint32_t)~(FMC_PMEM2_MEMSET2  | FMC_PMEM2_MEMWAIT2 | FMC_PMEM2_MEMHOLD2 | \
    476                                    FMC_PMEM2_MEMHIZ2)); 
   \                     ??FMC_NANDInit_3: (+1)
   \       0x56   0x2100             MOVS     R1,#+0
    477          
    478            /* Set tmppmem value according to FMC_CommonSpaceTimingStructure parameters */
    479            tmppmem |= (uint32_t)FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime |
    480                                 (FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime << 8) |
    481                                 (FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime << 16)|
    482                                 (FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime << 24); 
   \       0x58   0x69C3             LDR      R3,[R0, #+28]
   \       0x5A   0x681B             LDR      R3,[R3, #+0]
   \       0x5C   0x69C4             LDR      R4,[R0, #+28]
   \       0x5E   0x6864             LDR      R4,[R4, #+4]
   \       0x60   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \       0x64   0x69C4             LDR      R4,[R0, #+28]
   \       0x66   0x68A4             LDR      R4,[R4, #+8]
   \       0x68   0xEA53 0x4304      ORRS     R3,R3,R4, LSL #+16
   \       0x6C   0x69C4             LDR      R4,[R0, #+28]
   \       0x6E   0x68E4             LDR      R4,[R4, #+12]
   \       0x70   0xEA53 0x6304      ORRS     R3,R3,R4, LSL #+24
   \       0x74   0x4319             ORRS     R1,R3,R1
    483          
    484            if(FMC_NANDInitStruct->FMC_Bank == FMC_Bank2_NAND)
   \       0x76   0x6803             LDR      R3,[R0, #+0]
   \       0x78   0x2B10             CMP      R3,#+16
   \       0x7A   0xD103             BNE.N    ??FMC_NANDInit_4
    485            {
    486              /* Get the NAND bank 2 register value */
    487              tmppatt = FMC_Bank2->PATT2;
   \       0x7C   0x....'....        LDR.W    R3,??DataTable23_9  ;; 0xa000006c
   \       0x80   0x681B             LDR      R3,[R3, #+0]
   \       0x82   0xE002             B.N      ??FMC_NANDInit_5
    488            }
    489            else
    490            {
    491              /* Get the NAND bank 3 register value */
    492              tmppatt = FMC_Bank3->PATT3;
   \                     ??FMC_NANDInit_4: (+1)
   \       0x84   0x....'....        LDR.W    R3,??DataTable23_13  ;; 0xa000008c
   \       0x88   0x681B             LDR      R3,[R3, #+0]
    493            } 
    494            
    495            /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
    496            tmppatt &= ((uint32_t)~(FMC_PATT2_ATTSET2  | FMC_PATT2_ATTWAIT2 | FMC_PATT2_ATTHOLD2 | \
    497                                 FMC_PATT2_ATTHIZ2)); 
   \                     ??FMC_NANDInit_5: (+1)
   \       0x8A   0x2300             MOVS     R3,#+0
    498          
    499            /* Set tmppatt value according to FMC_AttributeSpaceTimingStructure parameters */
    500            tmppatt |= (uint32_t)FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime |
    501                                (FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime << 8) |
    502                                (FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime << 16)|
    503                                (FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime << 24);
   \       0x8C   0x6A04             LDR      R4,[R0, #+32]
   \       0x8E   0x6824             LDR      R4,[R4, #+0]
   \       0x90   0x6A05             LDR      R5,[R0, #+32]
   \       0x92   0x686D             LDR      R5,[R5, #+4]
   \       0x94   0xEA54 0x2405      ORRS     R4,R4,R5, LSL #+8
   \       0x98   0x6A05             LDR      R5,[R0, #+32]
   \       0x9A   0x68AD             LDR      R5,[R5, #+8]
   \       0x9C   0xEA54 0x4405      ORRS     R4,R4,R5, LSL #+16
   \       0xA0   0x6A05             LDR      R5,[R0, #+32]
   \       0xA2   0x68ED             LDR      R5,[R5, #+12]
   \       0xA4   0xEA54 0x6405      ORRS     R4,R4,R5, LSL #+24
   \       0xA8   0x4323             ORRS     R3,R4,R3
    504          
    505            if(FMC_NANDInitStruct->FMC_Bank == FMC_Bank2_NAND)
   \       0xAA   0x6800             LDR      R0,[R0, #+0]
   \       0xAC   0x2810             CMP      R0,#+16
   \       0xAE   0xD109             BNE.N    ??FMC_NANDInit_6
    506            {
    507              /* FMC_Bank2_NAND registers configuration */
    508              FMC_Bank2->PCR2 = tmppcr;
   \       0xB0   0x....'....        LDR.W    R0,??DataTable23_6  ;; 0xa0000060
   \       0xB4   0x6002             STR      R2,[R0, #+0]
    509              FMC_Bank2->PMEM2 = tmppmem;
   \       0xB6   0x....'....        LDR.W    R0,??DataTable23_8  ;; 0xa0000068
   \       0xBA   0x6001             STR      R1,[R0, #+0]
    510              FMC_Bank2->PATT2 = tmppatt;
   \       0xBC   0x....'....        LDR.W    R0,??DataTable23_9  ;; 0xa000006c
   \       0xC0   0x6003             STR      R3,[R0, #+0]
   \       0xC2   0xE008             B.N      ??FMC_NANDInit_7
    511            }
    512            else
    513            {
    514              /* FMC_Bank3_NAND registers configuration */
    515              FMC_Bank3->PCR3 = tmppcr;
   \                     ??FMC_NANDInit_6: (+1)
   \       0xC4   0x....'....        LDR.W    R0,??DataTable23_10  ;; 0xa0000080
   \       0xC8   0x6002             STR      R2,[R0, #+0]
    516              FMC_Bank3->PMEM3 = tmppmem;
   \       0xCA   0x....'....        LDR.W    R0,??DataTable23_12  ;; 0xa0000088
   \       0xCE   0x6001             STR      R1,[R0, #+0]
    517              FMC_Bank3->PATT3 = tmppatt;
   \       0xD0   0x....'....        LDR.W    R0,??DataTable23_13  ;; 0xa000008c
   \       0xD4   0x6003             STR      R3,[R0, #+0]
    518            }
    519          }
   \                     ??FMC_NANDInit_7: (+1)
   \       0xD6   0xBC30             POP      {R4,R5}
   \       0xD8   0x4770             BX       LR               ;; return
    520          
    521          
    522          /**
    523            * @brief  Fills each FMC_NANDInitStruct member with its default value.
    524            * @param  FMC_NANDInitStruct: pointer to a FMC_NANDInitTypeDef structure which
    525            *         will be initialized.
    526            * @retval None
    527            */

   \                                 In section .text, align 2, keep-with-next
    528          void FMC_NANDStructInit(FMC_NANDInitTypeDef* FMC_NANDInitStruct)
    529          { 
    530            /* Reset NAND Init structure parameters values */
    531            FMC_NANDInitStruct->FMC_Bank = FMC_Bank2_NAND;
   \                     FMC_NANDStructInit: (+1)
   \        0x0   0x2110             MOVS     R1,#+16
   \        0x2   0x6001             STR      R1,[R0, #+0]
    532            FMC_NANDInitStruct->FMC_Waitfeature = FMC_Waitfeature_Disable;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6041             STR      R1,[R0, #+4]
    533            FMC_NANDInitStruct->FMC_MemoryDataWidth = FMC_NAND_MemoryDataWidth_16b;
   \        0x8   0x2110             MOVS     R1,#+16
   \        0xA   0x6081             STR      R1,[R0, #+8]
    534            FMC_NANDInitStruct->FMC_ECC = FMC_ECC_Disable;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x60C1             STR      R1,[R0, #+12]
    535            FMC_NANDInitStruct->FMC_ECCPageSize = FMC_ECCPageSize_256Bytes;
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x6101             STR      R1,[R0, #+16]
    536            FMC_NANDInitStruct->FMC_TCLRSetupTime = 0x0;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6141             STR      R1,[R0, #+20]
    537            FMC_NANDInitStruct->FMC_TARSetupTime = 0x0;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6181             STR      R1,[R0, #+24]
    538            FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime = 252;
   \       0x1C   0x21FC             MOVS     R1,#+252
   \       0x1E   0x69C2             LDR      R2,[R0, #+28]
   \       0x20   0x6011             STR      R1,[R2, #+0]
    539            FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime = 252;
   \       0x22   0x21FC             MOVS     R1,#+252
   \       0x24   0x69C2             LDR      R2,[R0, #+28]
   \       0x26   0x6051             STR      R1,[R2, #+4]
    540            FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime = 252;
   \       0x28   0x21FC             MOVS     R1,#+252
   \       0x2A   0x69C2             LDR      R2,[R0, #+28]
   \       0x2C   0x6091             STR      R1,[R2, #+8]
    541            FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime = 252;
   \       0x2E   0x21FC             MOVS     R1,#+252
   \       0x30   0x69C2             LDR      R2,[R0, #+28]
   \       0x32   0x60D1             STR      R1,[R2, #+12]
    542            FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime = 252;
   \       0x34   0x21FC             MOVS     R1,#+252
   \       0x36   0x6A02             LDR      R2,[R0, #+32]
   \       0x38   0x6011             STR      R1,[R2, #+0]
    543            FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime = 252;
   \       0x3A   0x21FC             MOVS     R1,#+252
   \       0x3C   0x6A02             LDR      R2,[R0, #+32]
   \       0x3E   0x6051             STR      R1,[R2, #+4]
    544            FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime = 252;
   \       0x40   0x21FC             MOVS     R1,#+252
   \       0x42   0x6A02             LDR      R2,[R0, #+32]
   \       0x44   0x6091             STR      R1,[R2, #+8]
    545            FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime = 252;	  
   \       0x46   0x21FC             MOVS     R1,#+252
   \       0x48   0x6A00             LDR      R0,[R0, #+32]
   \       0x4A   0x60C1             STR      R1,[R0, #+12]
    546          }
   \       0x4C   0x4770             BX       LR               ;; return
    547          
    548          /**
    549            * @brief  Enables or disables the specified NAND Memory Bank.
    550            * @param  FMC_Bank: specifies the FMC Bank to be used
    551            *          This parameter can be one of the following values:
    552            *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
    553            *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
    554            * @param  NewState: new state of the FMC_Bank. This parameter can be: ENABLE or DISABLE.
    555            * @retval None
    556            */

   \                                 In section .text, align 2, keep-with-next
    557          void FMC_NANDCmd(uint32_t FMC_Bank, FunctionalState NewState)
    558          {
    559            assert_param(IS_FMC_NAND_BANK(FMC_Bank));
    560            assert_param(IS_FUNCTIONAL_STATE(NewState));
    561            
    562            if (NewState != DISABLE)
   \                     FMC_NANDCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD00F             BEQ.N    ??FMC_NANDCmd_0
    563            {
    564              /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
    565              if(FMC_Bank == FMC_Bank2_NAND)
   \        0x6   0x2810             CMP      R0,#+16
   \        0x8   0xD106             BNE.N    ??FMC_NANDCmd_1
    566              {
    567                FMC_Bank2->PCR2 |= PCR_PBKEN_SET;
   \        0xA   0x....'....        LDR.W    R0,??DataTable23_6  ;; 0xa0000060
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0xF051 0x0104      ORRS     R1,R1,#0x4
   \       0x14   0x6001             STR      R1,[R0, #+0]
   \       0x16   0xE017             B.N      ??FMC_NANDCmd_2
    568              }
    569              else
    570              {
    571                FMC_Bank3->PCR3 |= PCR_PBKEN_SET;
   \                     ??FMC_NANDCmd_1: (+1)
   \       0x18   0x....'....        LDR.W    R0,??DataTable23_10  ;; 0xa0000080
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
   \       0x1E   0xF051 0x0104      ORRS     R1,R1,#0x4
   \       0x22   0x6001             STR      R1,[R0, #+0]
   \       0x24   0xE010             B.N      ??FMC_NANDCmd_2
    572              }
    573            }
    574            else
    575            {
    576              /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
    577              if(FMC_Bank == FMC_Bank2_NAND)
   \                     ??FMC_NANDCmd_0: (+1)
   \       0x26   0x2810             CMP      R0,#+16
   \       0x28   0xD107             BNE.N    ??FMC_NANDCmd_3
    578              {
    579                FMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
   \       0x2A   0x....'....        LDR.W    R1,??DataTable23_6  ;; 0xa0000060
   \       0x2E   0x680A             LDR      R2,[R1, #+0]
   \       0x30   0x....'....        LDR.W    R0,??DataTable23_15  ;; 0xffffb
   \       0x34   0x4002             ANDS     R2,R0,R2
   \       0x36   0x600A             STR      R2,[R1, #+0]
   \       0x38   0xE006             B.N      ??FMC_NANDCmd_2
    580              }
    581              else
    582              {
    583                FMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
   \                     ??FMC_NANDCmd_3: (+1)
   \       0x3A   0x....'....        LDR.W    R1,??DataTable23_10  ;; 0xa0000080
   \       0x3E   0x680A             LDR      R2,[R1, #+0]
   \       0x40   0x....'....        LDR.W    R0,??DataTable23_15  ;; 0xffffb
   \       0x44   0x4002             ANDS     R2,R0,R2
   \       0x46   0x600A             STR      R2,[R1, #+0]
    584              }
    585            }
    586          }
   \                     ??FMC_NANDCmd_2: (+1)
   \       0x48   0x4770             BX       LR               ;; return
    587          /**
    588            * @brief  Enables or disables the FMC NAND ECC feature.
    589            * @param  FMC_Bank: specifies the FMC Bank to be used
    590            *          This parameter can be one of the following values:
    591            *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
    592            *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
    593            * @param  NewState: new state of the FMC NAND ECC feature.  
    594            *          This parameter can be: ENABLE or DISABLE.
    595            * @retval None
    596            */

   \                                 In section .text, align 2, keep-with-next
    597          void FMC_NANDECCCmd(uint32_t FMC_Bank, FunctionalState NewState)
    598          {
    599            assert_param(IS_FMC_NAND_BANK(FMC_Bank));
    600            assert_param(IS_FUNCTIONAL_STATE(NewState));
    601            
    602            if (NewState != DISABLE)
   \                     FMC_NANDECCCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD00F             BEQ.N    ??FMC_NANDECCCmd_0
    603            {
    604              /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
    605              if(FMC_Bank == FMC_Bank2_NAND)
   \        0x6   0x2810             CMP      R0,#+16
   \        0x8   0xD106             BNE.N    ??FMC_NANDECCCmd_1
    606              {
    607                FMC_Bank2->PCR2 |= PCR_ECCEN_SET;
   \        0xA   0x....'....        LDR.W    R0,??DataTable23_6  ;; 0xa0000060
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0x14   0x6001             STR      R1,[R0, #+0]
   \       0x16   0xE017             B.N      ??FMC_NANDECCCmd_2
    608              }
    609              else
    610              {
    611                FMC_Bank3->PCR3 |= PCR_ECCEN_SET;
   \                     ??FMC_NANDECCCmd_1: (+1)
   \       0x18   0x....'....        LDR.W    R0,??DataTable23_10  ;; 0xa0000080
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
   \       0x1E   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0x22   0x6001             STR      R1,[R0, #+0]
   \       0x24   0xE010             B.N      ??FMC_NANDECCCmd_2
    612              }
    613            }
    614            else
    615            {
    616              /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
    617              if(FMC_Bank == FMC_Bank2_NAND)
   \                     ??FMC_NANDECCCmd_0: (+1)
   \       0x26   0x2810             CMP      R0,#+16
   \       0x28   0xD107             BNE.N    ??FMC_NANDECCCmd_3
    618              {
    619                FMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
   \       0x2A   0x....'....        LDR.W    R1,??DataTable23_6  ;; 0xa0000060
   \       0x2E   0x680A             LDR      R2,[R1, #+0]
   \       0x30   0x....'....        LDR.W    R0,??DataTable23_16  ;; 0xfffbf
   \       0x34   0x4002             ANDS     R2,R0,R2
   \       0x36   0x600A             STR      R2,[R1, #+0]
   \       0x38   0xE006             B.N      ??FMC_NANDECCCmd_2
    620              }
    621              else
    622              {
    623                FMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
   \                     ??FMC_NANDECCCmd_3: (+1)
   \       0x3A   0x....'....        LDR.W    R1,??DataTable23_10  ;; 0xa0000080
   \       0x3E   0x680A             LDR      R2,[R1, #+0]
   \       0x40   0x....'....        LDR.W    R0,??DataTable23_16  ;; 0xfffbf
   \       0x44   0x4002             ANDS     R2,R0,R2
   \       0x46   0x600A             STR      R2,[R1, #+0]
    624              }
    625            }
    626          }
   \                     ??FMC_NANDECCCmd_2: (+1)
   \       0x48   0x4770             BX       LR               ;; return
    627          
    628          /**
    629            * @brief  Returns the error correction code register value.
    630            * @param  FMC_Bank: specifies the FMC Bank to be used
    631            *          This parameter can be one of the following values:
    632            *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
    633            *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
    634            * @retval The Error Correction Code (ECC) value.
    635            */

   \                                 In section .text, align 2, keep-with-next
    636          uint32_t FMC_GetECC(uint32_t FMC_Bank)
    637          {
    638            uint32_t eccval = 0x00000000;
   \                     FMC_GetECC: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
    639            
    640            if(FMC_Bank == FMC_Bank2_NAND)
   \        0x2   0x2810             CMP      R0,#+16
   \        0x4   0xD103             BNE.N    ??FMC_GetECC_0
    641            {
    642              /* Get the ECCR2 register value */
    643              eccval = FMC_Bank2->ECCR2;
   \        0x6   0x....'....        LDR.W    R0,??DataTable23_17  ;; 0xa0000074
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0xE002             B.N      ??FMC_GetECC_1
    644            }
    645            else
    646            {
    647              /* Get the ECCR3 register value */
    648              eccval = FMC_Bank3->ECCR3;
   \                     ??FMC_GetECC_0: (+1)
   \        0xE   0x....'....        LDR.W    R0,??DataTable23_18  ;; 0xa0000094
   \       0x12   0x6800             LDR      R0,[R0, #+0]
    649            }
    650            /* Return the error correction code value */
    651            return(eccval);
   \                     ??FMC_GetECC_1: (+1)
   \       0x14   0x4770             BX       LR               ;; return
    652          }
    653          /**
    654            * @}
    655            */
    656          
    657          /** @defgroup FMC_Group3 PCCARD Controller functions
    658            * @brief    PCCARD Controller functions 
    659            *
    660          @verbatim   
    661           ===============================================================================
    662                              ##### PCCARD Controller functions #####
    663           ===============================================================================  
    664          
    665           [..]  he following sequence should be followed to configure the FMC to interface 
    666                 with 16-bit PC Card compatible memory connected to the PCCARD Bank:
    667           
    668            (#)  Enable the clock for the FMC and associated GPIOs using the following functions:
    669                 (++)  RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FMC, ENABLE);
    670                 (++)  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
    671          
    672            (#) FMC pins configuration 
    673                 (++) Connect the involved FMC pins to AF12 using the following function 
    674                      GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FMC); 
    675                 (++) Configure these FMC pins in alternate function mode by calling the function
    676                      GPIO_Init();    
    677                 
    678            (#) Declare a FMC_PCCARDInitTypeDef structure, for example:
    679                FMC_PCCARDInitTypeDef  FMC_PCCARDInitStructure;
    680                and fill the FMC_PCCARDInitStructure variable with the allowed values of
    681                the structure member.
    682                
    683            (#) Initialize the PCCARD Controller by calling the function
    684                FMC_PCCARDInit(&FMC_PCCARDInitStructure); 
    685          
    686            (#) Then enable the PCCARD Bank:
    687                FMC_PCCARDCmd(ENABLE);  
    688          
    689            (#) At this stage you can read/write from/to the memory connected to the PCCARD Bank. 
    690           
    691          @endverbatim
    692            * @{
    693            */
    694          
    695          /**
    696            * @brief  De-initializes the FMC PCCARD Bank registers to their default reset values.
    697            * @param  None                       
    698            * @retval None
    699            */

   \                                 In section .text, align 2, keep-with-next
    700          void FMC_PCCARDDeInit(void)
    701          {
    702            /* Set the FMC_Bank4 registers to their reset values */
    703            FMC_Bank4->PCR4 = 0x00000018; 
   \                     FMC_PCCARDDeInit: (+1)
   \        0x0   0x2018             MOVS     R0,#+24
   \        0x2   0x....'....        LDR.W    R1,??DataTable23_19  ;; 0xa00000a0
   \        0x6   0x6008             STR      R0,[R1, #+0]
    704            FMC_Bank4->SR4 = 0x00000000;	
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x....'....        LDR.W    R1,??DataTable23_20  ;; 0xa00000a4
   \        0xE   0x6008             STR      R0,[R1, #+0]
    705            FMC_Bank4->PMEM4 = 0xFCFCFCFC;
   \       0x10   0xF05F 0x30FC      MOVS     R0,#-50529028
   \       0x14   0x....'....        LDR.W    R1,??DataTable23_21  ;; 0xa00000a8
   \       0x18   0x6008             STR      R0,[R1, #+0]
    706            FMC_Bank4->PATT4 = 0xFCFCFCFC;
   \       0x1A   0x....'....        LDR.W    R1,??DataTable23_22  ;; 0xa00000ac
   \       0x1E   0x6008             STR      R0,[R1, #+0]
    707            FMC_Bank4->PIO4 = 0xFCFCFCFC;
   \       0x20   0x....'....        LDR.W    R1,??DataTable23_23  ;; 0xa00000b0
   \       0x24   0x6008             STR      R0,[R1, #+0]
    708          }
   \       0x26   0x4770             BX       LR               ;; return
    709          
    710          /**
    711            * @brief  Initializes the FMC PCCARD Bank according to the specified parameters
    712            *         in the FMC_PCCARDInitStruct.
    713            * @param  FMC_PCCARDInitStruct : pointer to a FMC_PCCARDInitTypeDef structure
    714            *         that contains the configuration information for the FMC PCCARD Bank.                       
    715            * @retval None
    716            */

   \                                 In section .text, align 2, keep-with-next
    717          void FMC_PCCARDInit(FMC_PCCARDInitTypeDef* FMC_PCCARDInitStruct)
    718          {
   \                     FMC_PCCARDInit: (+1)
   \        0x0   0xB410             PUSH     {R4}
    719            /* temporary registers */
    720            uint32_t tmppcr = 0, tmpmem = 0, tmppatt = 0, tmppio = 0;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x2100             MOVS     R1,#+0
    721            
    722            /* Check the parameters */
    723            assert_param(IS_FMC_WAIT_FEATURE(FMC_PCCARDInitStruct->FMC_Waitfeature));
    724            assert_param(IS_FMC_TCLR_TIME(FMC_PCCARDInitStruct->FMC_TCLRSetupTime));
    725            assert_param(IS_FMC_TAR_TIME(FMC_PCCARDInitStruct->FMC_TARSetupTime));
    726           
    727            assert_param(IS_FMC_SETUP_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime));
    728            assert_param(IS_FMC_WAIT_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime));
    729            assert_param(IS_FMC_HOLD_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime));
    730            assert_param(IS_FMC_HIZ_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime));
    731            
    732            assert_param(IS_FMC_SETUP_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime));
    733            assert_param(IS_FMC_WAIT_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime));
    734            assert_param(IS_FMC_HOLD_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime));
    735            assert_param(IS_FMC_HIZ_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime));
    736            assert_param(IS_FMC_SETUP_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_SetupTime));
    737            assert_param(IS_FMC_WAIT_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_WaitSetupTime));
    738            assert_param(IS_FMC_HOLD_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HoldSetupTime));
    739            assert_param(IS_FMC_HIZ_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HiZSetupTime));
    740            
    741            /* Get PCCARD control register value */
    742            tmppcr = FMC_Bank4->PCR4;
   \        0xA   0x....'....        LDR.W    R3,??DataTable23_19  ;; 0xa00000a0
   \        0xE   0x681A             LDR      R2,[R3, #+0]
    743            
    744            /* Clear TAR, TCLR, PWAITEN and PWID bits */
    745            tmppcr &= ((uint32_t)~(FMC_PCR4_TAR  | FMC_PCR4_TCLR | FMC_PCR4_PWAITEN | \
    746                                   FMC_PCR4_PWID));
   \       0x10   0x....'....        LDR.W    R1,??DataTable23_24  ;; 0xfffe01cd
   \       0x14   0x400A             ANDS     R2,R1,R2
    747          
    748            /* Set the PCR4 register value according to FMC_PCCARDInitStruct parameters */
    749            tmppcr |= (uint32_t)FMC_PCCARDInitStruct->FMC_Waitfeature |
    750                                FMC_NAND_MemoryDataWidth_16b |  
    751                                (FMC_PCCARDInitStruct->FMC_TCLRSetupTime << 9) |
    752                                (FMC_PCCARDInitStruct->FMC_TARSetupTime << 13);
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0x6844             LDR      R4,[R0, #+4]
   \       0x1A   0xEA51 0x2144      ORRS     R1,R1,R4, LSL #+9
   \       0x1E   0x6884             LDR      R4,[R0, #+8]
   \       0x20   0xEA51 0x3144      ORRS     R1,R1,R4, LSL #+13
   \       0x24   0xF051 0x0110      ORRS     R1,R1,#0x10
   \       0x28   0x430A             ORRS     R2,R1,R2
    753          
    754            FMC_Bank4->PCR4 = tmppcr;
   \       0x2A   0x601A             STR      R2,[R3, #+0]
    755          
    756            /* Get PCCARD common space timing register value */
    757            tmpmem = FMC_Bank4->PMEM4;
   \       0x2C   0x....'....        LDR.W    R2,??DataTable23_21  ;; 0xa00000a8
   \       0x30   0x6811             LDR      R1,[R2, #+0]
    758            
    759            /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
    760            tmpmem &= ((uint32_t)~(FMC_PMEM4_MEMSET4  | FMC_PMEM4_MEMWAIT4 | FMC_PMEM4_MEMHOLD4 | \
    761                                   FMC_PMEM4_MEMHIZ4));
   \       0x32   0x2100             MOVS     R1,#+0
    762          
    763            /* Set PMEM4 register value according to FMC_CommonSpaceTimingStructure parameters */
    764            tmpmem |= (uint32_t)FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime |
    765                                (FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime << 8) |
    766                                (FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime << 16)|
    767                                (FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime << 24); 
   \       0x34   0x68C3             LDR      R3,[R0, #+12]
   \       0x36   0x681B             LDR      R3,[R3, #+0]
   \       0x38   0x68C4             LDR      R4,[R0, #+12]
   \       0x3A   0x6864             LDR      R4,[R4, #+4]
   \       0x3C   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \       0x40   0x68C4             LDR      R4,[R0, #+12]
   \       0x42   0x68A4             LDR      R4,[R4, #+8]
   \       0x44   0xEA53 0x4304      ORRS     R3,R3,R4, LSL #+16
   \       0x48   0x68C4             LDR      R4,[R0, #+12]
   \       0x4A   0x68E4             LDR      R4,[R4, #+12]
   \       0x4C   0xEA53 0x6304      ORRS     R3,R3,R4, LSL #+24
   \       0x50   0x4319             ORRS     R1,R3,R1
    768          
    769            FMC_Bank4->PMEM4 = tmpmem; 
   \       0x52   0x6011             STR      R1,[R2, #+0]
    770          
    771            /* Get PCCARD timing parameters */
    772            tmppatt = FMC_Bank4->PATT4;
   \       0x54   0x....'....        LDR.W    R2,??DataTable23_22  ;; 0xa00000ac
   \       0x58   0x6811             LDR      R1,[R2, #+0]
    773            
    774            /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
    775            tmppatt &= ((uint32_t)~(FMC_PATT4_ATTSET4  | FMC_PATT4_ATTWAIT4 | FMC_PATT4_ATTHOLD4 | \
    776                                    FMC_PATT4_ATTHIZ4));
   \       0x5A   0x2100             MOVS     R1,#+0
    777          
    778            /* Set PATT4 register value according to FMC_AttributeSpaceTimingStructure parameters */
    779            tmppatt |= (uint32_t)FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime |
    780                                 (FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime << 8) |
    781                                 (FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime << 16)|
    782                                 (FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime << 24);	
   \       0x5C   0x6903             LDR      R3,[R0, #+16]
   \       0x5E   0x681B             LDR      R3,[R3, #+0]
   \       0x60   0x6904             LDR      R4,[R0, #+16]
   \       0x62   0x6864             LDR      R4,[R4, #+4]
   \       0x64   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \       0x68   0x6904             LDR      R4,[R0, #+16]
   \       0x6A   0x68A4             LDR      R4,[R4, #+8]
   \       0x6C   0xEA53 0x4304      ORRS     R3,R3,R4, LSL #+16
   \       0x70   0x6904             LDR      R4,[R0, #+16]
   \       0x72   0x68E4             LDR      R4,[R4, #+12]
   \       0x74   0xEA53 0x6304      ORRS     R3,R3,R4, LSL #+24
   \       0x78   0x4319             ORRS     R1,R3,R1
    783          
    784            FMC_Bank4->PATT4 = tmppatt;
   \       0x7A   0x6011             STR      R1,[R2, #+0]
    785          
    786            /* Get FMC_PCCARD device timing parameters */
    787            tmppio = FMC_Bank4->PIO4;
   \       0x7C   0x....'....        LDR.W    R2,??DataTable23_23  ;; 0xa00000b0
   \       0x80   0x6811             LDR      R1,[R2, #+0]
    788          
    789            /* Clear IOSET4, IOWAIT4, IOHOLD4 and IOHIZ4 bits */
    790            tmppio &= ((uint32_t)~(FMC_PIO4_IOSET4  | FMC_PIO4_IOWAIT4 | FMC_PIO4_IOHOLD4 | \
    791                                   FMC_PIO4_IOHIZ4));
   \       0x82   0x2100             MOVS     R1,#+0
    792          
    793            /* Set PIO4 register value according to FMC_IOSpaceTimingStructure parameters */
    794            tmppio |= (uint32_t)FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_SetupTime |
    795                                (FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_WaitSetupTime << 8) |
    796                                (FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HoldSetupTime << 16)|
    797                                (FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HiZSetupTime << 24);             
   \       0x84   0x6943             LDR      R3,[R0, #+20]
   \       0x86   0x681B             LDR      R3,[R3, #+0]
   \       0x88   0x6944             LDR      R4,[R0, #+20]
   \       0x8A   0x6864             LDR      R4,[R4, #+4]
   \       0x8C   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \       0x90   0x6944             LDR      R4,[R0, #+20]
   \       0x92   0x68A4             LDR      R4,[R4, #+8]
   \       0x94   0xEA53 0x4304      ORRS     R3,R3,R4, LSL #+16
   \       0x98   0x6940             LDR      R0,[R0, #+20]
   \       0x9A   0x68C0             LDR      R0,[R0, #+12]
   \       0x9C   0xEA53 0x6300      ORRS     R3,R3,R0, LSL #+24
   \       0xA0   0x4319             ORRS     R1,R3,R1
    798            
    799            FMC_Bank4->PIO4 = tmppio;
   \       0xA2   0x6011             STR      R1,[R2, #+0]
    800          }
   \       0xA4   0xBC10             POP      {R4}
   \       0xA6   0x4770             BX       LR               ;; return
    801          
    802          /**
    803            * @brief  Fills each FMC_PCCARDInitStruct member with its default value.
    804            * @param  FMC_PCCARDInitStruct: pointer to a FMC_PCCARDInitTypeDef structure
    805            *         which will be initialized.
    806            * @retval None
    807            */

   \                                 In section .text, align 2, keep-with-next
    808          void FMC_PCCARDStructInit(FMC_PCCARDInitTypeDef* FMC_PCCARDInitStruct)
    809          {
    810            /* Reset PCCARD Init structure parameters values */
    811            FMC_PCCARDInitStruct->FMC_Waitfeature = FMC_Waitfeature_Disable;
   \                     FMC_PCCARDStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    812            FMC_PCCARDInitStruct->FMC_TCLRSetupTime = 0;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6041             STR      R1,[R0, #+4]
    813            FMC_PCCARDInitStruct->FMC_TARSetupTime = 0;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6081             STR      R1,[R0, #+8]
    814            FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime = 252;
   \        0xC   0x21FC             MOVS     R1,#+252
   \        0xE   0x68C2             LDR      R2,[R0, #+12]
   \       0x10   0x6011             STR      R1,[R2, #+0]
    815            FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime = 252;
   \       0x12   0x21FC             MOVS     R1,#+252
   \       0x14   0x68C2             LDR      R2,[R0, #+12]
   \       0x16   0x6051             STR      R1,[R2, #+4]
    816            FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime = 252;
   \       0x18   0x21FC             MOVS     R1,#+252
   \       0x1A   0x68C2             LDR      R2,[R0, #+12]
   \       0x1C   0x6091             STR      R1,[R2, #+8]
    817            FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime = 252;
   \       0x1E   0x21FC             MOVS     R1,#+252
   \       0x20   0x68C2             LDR      R2,[R0, #+12]
   \       0x22   0x60D1             STR      R1,[R2, #+12]
    818            FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime = 252;
   \       0x24   0x21FC             MOVS     R1,#+252
   \       0x26   0x6902             LDR      R2,[R0, #+16]
   \       0x28   0x6011             STR      R1,[R2, #+0]
    819            FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime = 252;
   \       0x2A   0x21FC             MOVS     R1,#+252
   \       0x2C   0x6902             LDR      R2,[R0, #+16]
   \       0x2E   0x6051             STR      R1,[R2, #+4]
    820            FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime = 252;
   \       0x30   0x21FC             MOVS     R1,#+252
   \       0x32   0x6902             LDR      R2,[R0, #+16]
   \       0x34   0x6091             STR      R1,[R2, #+8]
    821            FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime = 252;	
   \       0x36   0x21FC             MOVS     R1,#+252
   \       0x38   0x6902             LDR      R2,[R0, #+16]
   \       0x3A   0x60D1             STR      R1,[R2, #+12]
    822            FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_SetupTime = 252;
   \       0x3C   0x21FC             MOVS     R1,#+252
   \       0x3E   0x6942             LDR      R2,[R0, #+20]
   \       0x40   0x6011             STR      R1,[R2, #+0]
    823            FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_WaitSetupTime = 252;
   \       0x42   0x21FC             MOVS     R1,#+252
   \       0x44   0x6942             LDR      R2,[R0, #+20]
   \       0x46   0x6051             STR      R1,[R2, #+4]
    824            FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HoldSetupTime = 252;
   \       0x48   0x21FC             MOVS     R1,#+252
   \       0x4A   0x6942             LDR      R2,[R0, #+20]
   \       0x4C   0x6091             STR      R1,[R2, #+8]
    825            FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HiZSetupTime = 252;
   \       0x4E   0x21FC             MOVS     R1,#+252
   \       0x50   0x6940             LDR      R0,[R0, #+20]
   \       0x52   0x60C1             STR      R1,[R0, #+12]
    826          }
   \       0x54   0x4770             BX       LR               ;; return
    827          
    828          /**
    829            * @brief  Enables or disables the PCCARD Memory Bank.
    830            * @param  NewState: new state of the PCCARD Memory Bank.  
    831            *          This parameter can be: ENABLE or DISABLE.
    832            * @retval None
    833            */

   \                                 In section .text, align 2, keep-with-next
    834          void FMC_PCCARDCmd(FunctionalState NewState)
    835          {
    836            assert_param(IS_FUNCTIONAL_STATE(NewState));
    837            
    838            if (NewState != DISABLE)
   \                     FMC_PCCARDCmd: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD006             BEQ.N    ??FMC_PCCARDCmd_0
    839            {
    840              /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
    841              FMC_Bank4->PCR4 |= PCR_PBKEN_SET;
   \        0x6   0x....'....        LDR.W    R0,??DataTable23_19  ;; 0xa00000a0
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF051 0x0104      ORRS     R1,R1,#0x4
   \       0x10   0x6001             STR      R1,[R0, #+0]
   \       0x12   0xE006             B.N      ??FMC_PCCARDCmd_1
    842            }
    843            else
    844            {
    845              /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
    846              FMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
   \                     ??FMC_PCCARDCmd_0: (+1)
   \       0x14   0x....'....        LDR.W    R1,??DataTable23_19  ;; 0xa00000a0
   \       0x18   0x680A             LDR      R2,[R1, #+0]
   \       0x1A   0x....'....        LDR.W    R0,??DataTable23_15  ;; 0xffffb
   \       0x1E   0x4002             ANDS     R2,R0,R2
   \       0x20   0x600A             STR      R2,[R1, #+0]
    847            }
    848          }
   \                     ??FMC_PCCARDCmd_1: (+1)
   \       0x22   0x4770             BX       LR               ;; return
    849          
    850          /**
    851            * @}
    852            */
    853          
    854          /** @defgroup FMC_Group4  SDRAM Controller functions
    855            * @brief    SDRAM Controller functions
    856            *
    857          @verbatim   
    858           ===============================================================================
    859                               ##### SDRAM Controller functions ##### 
    860           ===============================================================================  
    861            
    862           [..]  The following sequence should be followed to configure the FMC to interface
    863                 with SDRAM memory connected to the SDRAM Bank 1 or SDRAM bank 2:
    864           
    865            (#) Enable the clock for the FMC and associated GPIOs using the following functions:
    866                (++) RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FMC, ENABLE);
    867                (++) RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
    868          
    869            (#) FMC pins configuration 
    870                (++) Connect the involved FMC pins to AF12 using the following function 
    871                     GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_FMC); 
    872                (++) Configure these FMC pins in alternate function mode by calling the function
    873                     GPIO_Init();    
    874                 
    875            (#) Declare a FMC_SDRAMInitTypeDef structure, for example:
    876                 FMC_SDRAMInitTypeDef  FMC_SDRAMInitStructure;
    877                and fill the FMC_SDRAMInitStructure variable with the allowed values of
    878                the structure member.  
    879                
    880            (#) Initialize the SDRAM Controller by calling the function
    881                    FMC_SDRAMInit(&FMC_SDRAMInitStructure);
    882                    
    883            (#) Declare a FMC_SDRAMCommandTypeDef structure, for example:
    884                  FMC_SDRAMCommandTypeDef  FMC_SDRAMCommandStructure;
    885                and fill the FMC_SDRAMCommandStructure variable with the allowed values of
    886                the structure member.        
    887          
    888            (#) Configure the SDCMR register with the desired command parameters by calling 
    889                the function FMC_SDRAMCmdConfig(&FMC_SDRAMCommandStructure);  
    890          
    891            (#) At this stage, the SDRAM memory is ready for any valid command.
    892             
    893          @endverbatim
    894            * @{
    895            */
    896          
    897          /**
    898            * @brief  De-initializes the FMC SDRAM Banks registers to their default 
    899            *         reset values.
    900            * @param  FMC_Bank: specifies the FMC Bank to be used
    901            *          This parameter can be one of the following values:
    902            *            @arg FMC_Bank1_SDRAM: FMC Bank1 SDRAM 
    903            *            @arg FMC_Bank2_SDRAM: FMC Bank2 SDRAM 
    904            * @retval None
    905            */

   \                                 In section .text, align 2, keep-with-next
    906          void FMC_SDRAMDeInit(uint32_t FMC_Bank)
    907          {
    908            /* Check the parameter */
    909            assert_param(IS_FMC_SDRAM_BANK(FMC_Bank));
    910            
    911            FMC_Bank5_6->SDCR[FMC_Bank] = 0x000002D0;
   \                     FMC_SDRAMDeInit: (+1)
   \        0x0   0xF44F 0x7134      MOV      R1,#+720
   \        0x4   0x....'....        LDR.W    R2,??DataTable23_25  ;; 0xa0000140
   \        0x8   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    912            FMC_Bank5_6->SDTR[FMC_Bank] = 0x0FFFFFFF;    
   \        0xC   0xF07F 0x4170      MVNS     R1,#-268435456
   \       0x10   0x....'....        LDR.W    R2,??DataTable23_26  ;; 0xa0000148
   \       0x14   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    913            FMC_Bank5_6->SDCMR = 0x00000000;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x....'....        LDR.W    R1,??DataTable23_27  ;; 0xa0000150
   \       0x1E   0x6008             STR      R0,[R1, #+0]
    914            FMC_Bank5_6->SDRTR = 0x00000000;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x....'....        LDR.W    R1,??DataTable23_28  ;; 0xa0000154
   \       0x26   0x6008             STR      R0,[R1, #+0]
    915            FMC_Bank5_6->SDSR = 0x00000000; 
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x....'....        LDR.W    R1,??DataTable23_29  ;; 0xa0000158
   \       0x2E   0x6008             STR      R0,[R1, #+0]
    916          }  
   \       0x30   0x4770             BX       LR               ;; return
    917          
    918          /**
    919            * @brief  Initializes the FMC SDRAM Banks according to the specified
    920            *         parameters in the FMC_SDRAMInitStruct.
    921            * @param  FMC_SDRAMInitStruct : pointer to a FMC_SDRAMInitTypeDef structure
    922            *         that contains the configuration information for the FMC SDRAM 
    923            *         specified Banks.                       
    924            * @retval None
    925            */

   \                                 In section .text, align 2, keep-with-next
    926          void FMC_SDRAMInit(FMC_SDRAMInitTypeDef* FMC_SDRAMInitStruct)
    927          { 
   \                     FMC_SDRAMInit: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    928            /* temporary registers */
    929            uint32_t tmpr1 = 0, tmpr2 = 0, tmpr3 = 0, tmpr4 = 0;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x2100             MOVS     R1,#+0
    930            
    931            /* Check the parameters */
    932            
    933            /* Control parameters */
    934            assert_param(IS_FMC_SDRAM_BANK(FMC_SDRAMInitStruct->FMC_Bank));
    935            assert_param(IS_FMC_COLUMNBITS_NUMBER(FMC_SDRAMInitStruct->FMC_ColumnBitsNumber)); 
    936            assert_param(IS_FMC_ROWBITS_NUMBER(FMC_SDRAMInitStruct->FMC_RowBitsNumber));
    937            assert_param(IS_FMC_SDMEMORY_WIDTH(FMC_SDRAMInitStruct->FMC_SDMemoryDataWidth));
    938            assert_param(IS_FMC_INTERNALBANK_NUMBER(FMC_SDRAMInitStruct->FMC_InternalBankNumber)); 
    939            assert_param(IS_FMC_CAS_LATENCY(FMC_SDRAMInitStruct->FMC_CASLatency));
    940            assert_param(IS_FMC_WRITE_PROTECTION(FMC_SDRAMInitStruct->FMC_WriteProtection));
    941            assert_param(IS_FMC_SDCLOCK_PERIOD(FMC_SDRAMInitStruct->FMC_SDClockPeriod));
    942            assert_param(IS_FMC_READ_BURST(FMC_SDRAMInitStruct->FMC_ReadBurst));
    943            assert_param(IS_FMC_READPIPE_DELAY(FMC_SDRAMInitStruct->FMC_ReadPipeDelay));   
    944            
    945            /* Timing parameters */
    946            assert_param(IS_FMC_LOADTOACTIVE_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay)); 
    947            assert_param(IS_FMC_EXITSELFREFRESH_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay));
    948            assert_param(IS_FMC_SELFREFRESH_TIME(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime));
    949            assert_param(IS_FMC_ROWCYCLE_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay));
    950            assert_param(IS_FMC_WRITE_RECOVERY_TIME(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime)); 
    951            assert_param(IS_FMC_RP_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay)); 
    952            assert_param(IS_FMC_RCD_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RCDDelay));    
    953            
    954            /* Get SDRAM register value */
    955            tmpr1 = FMC_Bank5_6->SDCR[FMC_SDRAMInitStruct->FMC_Bank];
   \        0xA   0x....'....        LDR.W    R2,??DataTable23_25  ;; 0xa0000140
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0xF852 0x3021      LDR      R3,[R2, R1, LSL #+2]
    956          
    957            /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    958            tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
    959                                  FMC_SDCR1_NB | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
    960                                  FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
   \       0x14   0x0BDB             LSRS     R3,R3,#+15
   \       0x16   0x03DB             LSLS     R3,R3,#+15
    961          
    962            /* SDRAM bank control register configuration */ 
    963            tmpr1 |=   (uint32_t)FMC_SDRAMInitStruct->FMC_ColumnBitsNumber |
    964                                 FMC_SDRAMInitStruct->FMC_RowBitsNumber |
    965                                 FMC_SDRAMInitStruct->FMC_SDMemoryDataWidth |
    966                                 FMC_SDRAMInitStruct->FMC_InternalBankNumber |           
    967                                 FMC_SDRAMInitStruct->FMC_CASLatency |
    968                                 FMC_SDRAMInitStruct->FMC_WriteProtection |
    969                                 FMC_SDRAMInitStruct->FMC_SDClockPeriod |
    970                                 FMC_SDRAMInitStruct->FMC_ReadBurst | 
    971                                 FMC_SDRAMInitStruct->FMC_ReadPipeDelay;
   \       0x18   0x6844             LDR      R4,[R0, #+4]
   \       0x1A   0x6881             LDR      R1,[R0, #+8]
   \       0x1C   0x430C             ORRS     R4,R1,R4
   \       0x1E   0x68C1             LDR      R1,[R0, #+12]
   \       0x20   0x430C             ORRS     R4,R1,R4
   \       0x22   0x6901             LDR      R1,[R0, #+16]
   \       0x24   0x430C             ORRS     R4,R1,R4
   \       0x26   0x6941             LDR      R1,[R0, #+20]
   \       0x28   0x430C             ORRS     R4,R1,R4
   \       0x2A   0x6981             LDR      R1,[R0, #+24]
   \       0x2C   0x430C             ORRS     R4,R1,R4
   \       0x2E   0x69C1             LDR      R1,[R0, #+28]
   \       0x30   0x430C             ORRS     R4,R1,R4
   \       0x32   0x6A01             LDR      R1,[R0, #+32]
   \       0x34   0x430C             ORRS     R4,R1,R4
   \       0x36   0x6A41             LDR      R1,[R0, #+36]
   \       0x38   0x430C             ORRS     R4,R1,R4
   \       0x3A   0x4323             ORRS     R3,R4,R3
    972                      
    973            if(FMC_SDRAMInitStruct->FMC_Bank == FMC_Bank1_SDRAM )
   \       0x3C   0x6801             LDR      R1,[R0, #+0]
   \       0x3E   0x2900             CMP      R1,#+0
   \       0x40   0xD103             BNE.N    ??FMC_SDRAMInit_0
    974            {
    975              FMC_Bank5_6->SDCR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr1;
   \       0x42   0x6801             LDR      R1,[R0, #+0]
   \       0x44   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \       0x48   0xE00C             B.N      ??FMC_SDRAMInit_1
    976            }
    977            else   /* SDCR2 "don't care" bits configuration */
    978            {
    979              /* Get SDCR register value */
    980              tmpr3 = FMC_Bank5_6->SDCR[FMC_Bank1_SDRAM];
   \                     ??FMC_SDRAMInit_0: (+1)
   \       0x4A   0x6814             LDR      R4,[R2, #+0]
    981          
    982              /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    983              tmpr3 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
    984                                    FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
    985                                    FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
   \       0x4C   0x0BE4             LSRS     R4,R4,#+15
   \       0x4E   0x03E4             LSLS     R4,R4,#+15
    986          
    987              tmpr3 |= (uint32_t)FMC_SDRAMInitStruct->FMC_SDClockPeriod |
    988                                 FMC_SDRAMInitStruct->FMC_ReadBurst | 
    989                                 FMC_SDRAMInitStruct->FMC_ReadPipeDelay;
   \       0x50   0x69C5             LDR      R5,[R0, #+28]
   \       0x52   0x6A01             LDR      R1,[R0, #+32]
   \       0x54   0x430D             ORRS     R5,R1,R5
   \       0x56   0x6A41             LDR      R1,[R0, #+36]
   \       0x58   0x430D             ORRS     R5,R1,R5
   \       0x5A   0x432C             ORRS     R4,R5,R4
    990              
    991              FMC_Bank5_6->SDCR[FMC_Bank1_SDRAM] = tmpr3;
   \       0x5C   0x6014             STR      R4,[R2, #+0]
    992              FMC_Bank5_6->SDCR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr1;
   \       0x5E   0x6801             LDR      R1,[R0, #+0]
   \       0x60   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
    993            }
    994            /* SDRAM bank timing register configuration */
    995            if(FMC_SDRAMInitStruct->FMC_Bank == FMC_Bank1_SDRAM )
   \                     ??FMC_SDRAMInit_1: (+1)
   \       0x64   0x6801             LDR      R1,[R0, #+0]
   \       0x66   0x2900             CMP      R1,#+0
   \       0x68   0xD12C             BNE.N    ??FMC_SDRAMInit_2
    996            {
    997              /* Get SDTR register value */
    998              tmpr2 = FMC_Bank5_6->SDTR[FMC_SDRAMInitStruct->FMC_Bank];
   \       0x6A   0x....'....        LDR.W    R1,??DataTable23_26  ;; 0xa0000148
   \       0x6E   0x6802             LDR      R2,[R0, #+0]
   \       0x70   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
    999          
   1000              /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
   1001              tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
   1002                                    FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
   1003                                    FMC_SDTR1_TRCD));
   \       0x74   0xF012 0x4270      ANDS     R2,R2,#0xF0000000
   1004          
   1005              tmpr2 |=   (uint32_t)((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay)-1) |
   1006                                    (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay)-1) << 4) |
   1007                                    (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime)-1) << 8) |
   1008                                    (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay)-1) << 12) |
   1009                                    (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime)-1) << 16) |
   1010                                    (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay)-1) << 20) |
   1011                                    (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RCDDelay)-1) << 24);
   \       0x78   0x6A83             LDR      R3,[R0, #+40]
   \       0x7A   0x681B             LDR      R3,[R3, #+0]
   \       0x7C   0x1E5B             SUBS     R3,R3,#+1
   \       0x7E   0x6A84             LDR      R4,[R0, #+40]
   \       0x80   0x6864             LDR      R4,[R4, #+4]
   \       0x82   0x1E64             SUBS     R4,R4,#+1
   \       0x84   0xEA53 0x1304      ORRS     R3,R3,R4, LSL #+4
   \       0x88   0x6A84             LDR      R4,[R0, #+40]
   \       0x8A   0x68A4             LDR      R4,[R4, #+8]
   \       0x8C   0x1E64             SUBS     R4,R4,#+1
   \       0x8E   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \       0x92   0x6A84             LDR      R4,[R0, #+40]
   \       0x94   0x68E4             LDR      R4,[R4, #+12]
   \       0x96   0x1E64             SUBS     R4,R4,#+1
   \       0x98   0xEA53 0x3304      ORRS     R3,R3,R4, LSL #+12
   \       0x9C   0x6A84             LDR      R4,[R0, #+40]
   \       0x9E   0x6924             LDR      R4,[R4, #+16]
   \       0xA0   0x1E64             SUBS     R4,R4,#+1
   \       0xA2   0xEA53 0x4304      ORRS     R3,R3,R4, LSL #+16
   \       0xA6   0x6A84             LDR      R4,[R0, #+40]
   \       0xA8   0x6964             LDR      R4,[R4, #+20]
   \       0xAA   0x1E64             SUBS     R4,R4,#+1
   \       0xAC   0xEA53 0x5304      ORRS     R3,R3,R4, LSL #+20
   \       0xB0   0x6A84             LDR      R4,[R0, #+40]
   \       0xB2   0x69A4             LDR      R4,[R4, #+24]
   \       0xB4   0x1E64             SUBS     R4,R4,#+1
   \       0xB6   0xEA53 0x6304      ORRS     R3,R3,R4, LSL #+24
   \       0xBA   0x431A             ORRS     R2,R3,R2
   1012                      
   1013                      FMC_Bank5_6->SDTR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr2;
   \       0xBC   0x6800             LDR      R0,[R0, #+0]
   \       0xBE   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \       0xC2   0xE02A             B.N      ??FMC_SDRAMInit_3
   1014            }
   1015            else   /* SDTR "don't care bits configuration */
   1016            {
   1017              /* Get SDTR register value */
   1018              tmpr2 = FMC_Bank5_6->SDTR[FMC_SDRAMInitStruct->FMC_Bank];
   \                     ??FMC_SDRAMInit_2: (+1)
   \       0xC4   0x....'....        LDR.W    R1,??DataTable23_26  ;; 0xa0000148
   \       0xC8   0x6802             LDR      R2,[R0, #+0]
   \       0xCA   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
   1019          
   1020              /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
   1021              tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
   1022                                    FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
   1023                                    FMC_SDTR1_TRCD));
   \       0xCE   0xF012 0x4270      ANDS     R2,R2,#0xF0000000
   1024          
   1025              tmpr2 |=   (uint32_t)((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay)-1) |
   1026                                    (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay)-1) << 4) |
   1027                                    (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime)-1) << 8) |
   1028                                    (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime)-1) << 16);
   \       0xD2   0x6A83             LDR      R3,[R0, #+40]
   \       0xD4   0x681B             LDR      R3,[R3, #+0]
   \       0xD6   0x1E5B             SUBS     R3,R3,#+1
   \       0xD8   0x6A84             LDR      R4,[R0, #+40]
   \       0xDA   0x6864             LDR      R4,[R4, #+4]
   \       0xDC   0x1E64             SUBS     R4,R4,#+1
   \       0xDE   0xEA53 0x1304      ORRS     R3,R3,R4, LSL #+4
   \       0xE2   0x6A84             LDR      R4,[R0, #+40]
   \       0xE4   0x68A4             LDR      R4,[R4, #+8]
   \       0xE6   0x1E64             SUBS     R4,R4,#+1
   \       0xE8   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \       0xEC   0x6A84             LDR      R4,[R0, #+40]
   \       0xEE   0x6924             LDR      R4,[R4, #+16]
   \       0xF0   0x1E64             SUBS     R4,R4,#+1
   \       0xF2   0xEA53 0x4304      ORRS     R3,R3,R4, LSL #+16
   \       0xF6   0x431A             ORRS     R2,R3,R2
   1029              
   1030              /* Get SDTR register value */
   1031              tmpr4 = FMC_Bank5_6->SDTR[FMC_Bank1_SDRAM];
   \       0xF8   0x680B             LDR      R3,[R1, #+0]
   1032          
   1033              /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
   1034              tmpr4 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
   1035                                    FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
   1036                                    FMC_SDTR1_TRCD));
   \       0xFA   0xF013 0x4370      ANDS     R3,R3,#0xF0000000
   1037          
   1038              tmpr4 |=   (uint32_t)(((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay)-1) << 12) |
   1039                                    (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay)-1) << 20);
   \       0xFE   0x6A84             LDR      R4,[R0, #+40]
   \      0x100   0x68E4             LDR      R4,[R4, #+12]
   \      0x102   0x1E64             SUBS     R4,R4,#+1
   \      0x104   0x6A85             LDR      R5,[R0, #+40]
   \      0x106   0x696D             LDR      R5,[R5, #+20]
   \      0x108   0x1E6D             SUBS     R5,R5,#+1
   \      0x10A   0x052D             LSLS     R5,R5,#+20
   \      0x10C   0xEA55 0x3504      ORRS     R5,R5,R4, LSL #+12
   \      0x110   0x432B             ORRS     R3,R5,R3
   1040                      
   1041                      FMC_Bank5_6->SDTR[FMC_Bank1_SDRAM] = tmpr4;
   \      0x112   0x600B             STR      R3,[R1, #+0]
   1042                      FMC_Bank5_6->SDTR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr2;
   \      0x114   0x6800             LDR      R0,[R0, #+0]
   \      0x116   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   1043            }
   1044            
   1045          }
   \                     ??FMC_SDRAMInit_3: (+1)
   \      0x11A   0xBC30             POP      {R4,R5}
   \      0x11C   0x4770             BX       LR               ;; return
   1046          
   1047          /**
   1048            * @brief  Fills each FMC_SDRAMInitStruct member with its default value.
   1049            * @param  FMC_SDRAMInitStruct: pointer to a FMC_SDRAMInitTypeDef structure 
   1050            *         which will be initialized.
   1051            * @retval None
   1052            */

   \                                 In section .text, align 2, keep-with-next
   1053          void FMC_SDRAMStructInit(FMC_SDRAMInitTypeDef* FMC_SDRAMInitStruct)  
   1054          {  
   1055            /* Reset SDRAM Init structure parameters values */
   1056            FMC_SDRAMInitStruct->FMC_Bank = FMC_Bank1_SDRAM;
   \                     FMC_SDRAMStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
   1057            FMC_SDRAMInitStruct->FMC_ColumnBitsNumber = FMC_ColumnBits_Number_8b;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6041             STR      R1,[R0, #+4]
   1058            FMC_SDRAMInitStruct->FMC_RowBitsNumber = FMC_RowBits_Number_11b; 
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6081             STR      R1,[R0, #+8]
   1059            FMC_SDRAMInitStruct->FMC_SDMemoryDataWidth = FMC_SDMemory_Width_16b;
   \        0xC   0x2110             MOVS     R1,#+16
   \        0xE   0x60C1             STR      R1,[R0, #+12]
   1060            FMC_SDRAMInitStruct->FMC_InternalBankNumber = FMC_InternalBank_Number_4; 
   \       0x10   0x2140             MOVS     R1,#+64
   \       0x12   0x6101             STR      R1,[R0, #+16]
   1061            FMC_SDRAMInitStruct->FMC_CASLatency = FMC_CAS_Latency_1;  
   \       0x14   0x2180             MOVS     R1,#+128
   \       0x16   0x6141             STR      R1,[R0, #+20]
   1062            FMC_SDRAMInitStruct->FMC_WriteProtection = FMC_Write_Protection_Enable;
   \       0x18   0xF44F 0x7100      MOV      R1,#+512
   \       0x1C   0x6181             STR      R1,[R0, #+24]
   1063            FMC_SDRAMInitStruct->FMC_SDClockPeriod = FMC_SDClock_Disable;
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0x61C1             STR      R1,[R0, #+28]
   1064            FMC_SDRAMInitStruct->FMC_ReadBurst = FMC_Read_Burst_Disable;
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x6201             STR      R1,[R0, #+32]
   1065            FMC_SDRAMInitStruct->FMC_ReadPipeDelay = FMC_ReadPipe_Delay_0; 
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0x6241             STR      R1,[R0, #+36]
   1066             
   1067            FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay = 16;
   \       0x2A   0x2110             MOVS     R1,#+16
   \       0x2C   0x6A82             LDR      R2,[R0, #+40]
   \       0x2E   0x6011             STR      R1,[R2, #+0]
   1068            FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay = 16;
   \       0x30   0x2110             MOVS     R1,#+16
   \       0x32   0x6A82             LDR      R2,[R0, #+40]
   \       0x34   0x6051             STR      R1,[R2, #+4]
   1069            FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime = 16;
   \       0x36   0x2110             MOVS     R1,#+16
   \       0x38   0x6A82             LDR      R2,[R0, #+40]
   \       0x3A   0x6091             STR      R1,[R2, #+8]
   1070            FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay = 16;
   \       0x3C   0x2110             MOVS     R1,#+16
   \       0x3E   0x6A82             LDR      R2,[R0, #+40]
   \       0x40   0x60D1             STR      R1,[R2, #+12]
   1071            FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime = 16;
   \       0x42   0x2110             MOVS     R1,#+16
   \       0x44   0x6A82             LDR      R2,[R0, #+40]
   \       0x46   0x6111             STR      R1,[R2, #+16]
   1072            FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay = 16;
   \       0x48   0x2110             MOVS     R1,#+16
   \       0x4A   0x6A82             LDR      R2,[R0, #+40]
   \       0x4C   0x6151             STR      R1,[R2, #+20]
   1073            FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RCDDelay = 16;
   \       0x4E   0x2110             MOVS     R1,#+16
   \       0x50   0x6A80             LDR      R0,[R0, #+40]
   \       0x52   0x6181             STR      R1,[R0, #+24]
   1074            
   1075          }
   \       0x54   0x4770             BX       LR               ;; return
   1076          
   1077          /**
   1078            * @brief  Configures the SDRAM memory command issued when the device is accessed.   
   1079            * @param  FMC_SDRAMCommandStruct: pointer to a FMC_SDRAMCommandTypeDef structure 
   1080            *         which will be configured.
   1081            * @retval None
   1082            */

   \                                 In section .text, align 2, keep-with-next
   1083          void FMC_SDRAMCmdConfig(FMC_SDRAMCommandTypeDef* FMC_SDRAMCommandStruct)
   1084          {
   1085            uint32_t tmpr = 0x0;
   \                     FMC_SDRAMCmdConfig: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   1086              
   1087            /* check parameters */
   1088            assert_param(IS_FMC_COMMAND_MODE(FMC_SDRAMCommandStruct->FMC_CommandMode));
   1089            assert_param(IS_FMC_COMMAND_TARGET(FMC_SDRAMCommandStruct->FMC_CommandTarget));
   1090            assert_param(IS_FMC_AUTOREFRESH_NUMBER(FMC_SDRAMCommandStruct->FMC_AutoRefreshNumber));
   1091            assert_param(IS_FMC_MODE_REGISTER(FMC_SDRAMCommandStruct->FMC_ModeRegisterDefinition));
   1092            
   1093            tmpr =   (uint32_t)(FMC_SDRAMCommandStruct->FMC_CommandMode |
   1094                                FMC_SDRAMCommandStruct->FMC_CommandTarget |
   1095                               (((FMC_SDRAMCommandStruct->FMC_AutoRefreshNumber)-1)<<5) |
   1096                               ((FMC_SDRAMCommandStruct->FMC_ModeRegisterDefinition)<<9));
   \        0x2   0x6802             LDR      R2,[R0, #+0]
   \        0x4   0x6841             LDR      R1,[R0, #+4]
   \        0x6   0x430A             ORRS     R2,R1,R2
   \        0x8   0x6881             LDR      R1,[R0, #+8]
   \        0xA   0x1E49             SUBS     R1,R1,#+1
   \        0xC   0xEA52 0x1241      ORRS     R2,R2,R1, LSL #+5
   \       0x10   0x68C0             LDR      R0,[R0, #+12]
   \       0x12   0xEA52 0x2240      ORRS     R2,R2,R0, LSL #+9
   1097            
   1098            FMC_Bank5_6->SDCMR = tmpr;
   \       0x16   0x....             LDR.N    R0,??DataTable23_27  ;; 0xa0000150
   \       0x18   0x6002             STR      R2,[R0, #+0]
   1099          
   1100          }
   \       0x1A   0x4770             BX       LR               ;; return
   1101          
   1102          
   1103          /**
   1104            * @brief  Returns the indicated FMC SDRAM bank mode status.
   1105            * @param  SDRAM_Bank: Defines the FMC SDRAM bank. This parameter can be 
   1106            *                     FMC_Bank1_SDRAM or FMC_Bank2_SDRAM. 
   1107            * @retval The FMC SDRAM bank mode status         
   1108            */

   \                                 In section .text, align 2, keep-with-next
   1109          uint32_t FMC_GetModeStatus(uint32_t SDRAM_Bank)
   1110          {
   1111            uint32_t tmpreg = 0;
   \                     FMC_GetModeStatus: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   1112            
   1113            /* Check the parameter */
   1114            assert_param(IS_FMC_SDRAM_BANK(SDRAM_Bank));
   1115          
   1116            /* Get the busy flag status */
   1117            if(SDRAM_Bank == FMC_Bank1_SDRAM)
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD104             BNE.N    ??FMC_GetModeStatus_0
   1118            {
   1119              tmpreg = (uint32_t)(FMC_Bank5_6->SDSR & FMC_SDSR_MODES1); 
   \        0x6   0x....             LDR.N    R0,??DataTable23_29  ;; 0xa0000158
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0xF010 0x0006      ANDS     R0,R0,#0x6
   \        0xE   0xE004             B.N      ??FMC_GetModeStatus_1
   1120            }
   1121            else
   1122            {
   1123              tmpreg = ((uint32_t)(FMC_Bank5_6->SDSR & FMC_SDSR_MODES2) >> 2);
   \                     ??FMC_GetModeStatus_0: (+1)
   \       0x10   0x....             LDR.N    R0,??DataTable23_29  ;; 0xa0000158
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x0880             LSRS     R0,R0,#+2
   \       0x16   0xF010 0x0006      ANDS     R0,R0,#0x6
   1124            }
   1125            
   1126            /* Return the mode status */
   1127            return tmpreg;
   \                     ??FMC_GetModeStatus_1: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
   1128          }
   1129          
   1130          /**
   1131            * @brief  defines the SDRAM Memory Refresh rate.
   1132            * @param  FMC_Count: specifies the Refresh timer count.       
   1133            * @retval None
   1134            */

   \                                 In section .text, align 2, keep-with-next
   1135          void FMC_SetRefreshCount(uint32_t FMC_Count)
   1136          {
   1137            /* check the parameters */
   1138            assert_param(IS_FMC_REFRESH_COUNT(FMC_Count));
   1139            
   1140            FMC_Bank5_6->SDRTR |= (FMC_Count<<1);
   \                     FMC_SetRefreshCount: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable23_28  ;; 0xa0000154
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xEA52 0x0240      ORRS     R2,R2,R0, LSL #+1
   \        0x8   0x600A             STR      R2,[R1, #+0]
   1141             
   1142          }
   \        0xA   0x4770             BX       LR               ;; return
   1143          
   1144          /**
   1145            * @brief  Sets the Number of consecutive SDRAM Memory auto Refresh commands.
   1146            * @param  FMC_Number: specifies the auto Refresh number.       
   1147            * @retval None
   1148            */

   \                                 In section .text, align 2, keep-with-next
   1149          void FMC_SetAutoRefresh_Number(uint32_t FMC_Number)
   1150          {
   1151            /* check the parameters */
   1152            assert_param(IS_FMC_AUTOREFRESH_NUMBER(FMC_Number));
   1153            
   1154            FMC_Bank5_6->SDCMR |= (FMC_Number << 5);   
   \                     FMC_SetAutoRefresh_Number: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable23_27  ;; 0xa0000150
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xEA52 0x1240      ORRS     R2,R2,R0, LSL #+5
   \        0x8   0x600A             STR      R2,[R1, #+0]
   1155          }
   \        0xA   0x4770             BX       LR               ;; return
   1156          
   1157          /**
   1158            * @brief  Enables or disables write protection to the specified FMC SDRAM Bank.
   1159            * @param  SDRAM_Bank: Defines the FMC SDRAM bank. This parameter can be 
   1160            *                     FMC_Bank1_SDRAM or FMC_Bank2_SDRAM.   
   1161            * @param  NewState: new state of the write protection flag.
   1162            *          This parameter can be: ENABLE or DISABLE.
   1163            * @retval None
   1164            */

   \                                 In section .text, align 2, keep-with-next
   1165          void FMC_SDRAMWriteProtectionConfig(uint32_t SDRAM_Bank, FunctionalState NewState)
   1166          {
   1167            /* Check the parameter */
   1168            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1169            assert_param(IS_FMC_SDRAM_BANK(SDRAM_Bank));
   1170            
   1171            if (NewState != DISABLE)
   \                     FMC_SDRAMWriteProtectionConfig: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD007             BEQ.N    ??FMC_SDRAMWriteProtectionConfig_0
   1172            {
   1173              FMC_Bank5_6->SDCR[SDRAM_Bank] |= FMC_Write_Protection_Enable;    
   \        0x6   0x....             LDR.N    R1,??DataTable23_25  ;; 0xa0000140
   \        0x8   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \        0xC   0xF452 0x7200      ORRS     R2,R2,#0x200
   \       0x10   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \       0x14   0xE007             B.N      ??FMC_SDRAMWriteProtectionConfig_1
   1174            }
   1175            else
   1176            {
   1177              FMC_Bank5_6->SDCR[SDRAM_Bank] &= SDCR_WriteProtection_RESET;
   \                     ??FMC_SDRAMWriteProtectionConfig_0: (+1)
   \       0x16   0x....             LDR.N    R2,??DataTable23_25  ;; 0xa0000140
   \       0x18   0xF852 0x3020      LDR      R3,[R2, R0, LSL #+2]
   \       0x1C   0xF647 0x51FF      MOVW     R1,#+32255
   \       0x20   0x400B             ANDS     R3,R1,R3
   \       0x22   0xF842 0x3020      STR      R3,[R2, R0, LSL #+2]
   1178            } 
   1179            
   1180          }
   \                     ??FMC_SDRAMWriteProtectionConfig_1: (+1)
   \       0x26   0x4770             BX       LR               ;; return
   1181          
   1182          /**
   1183            * @}
   1184            */
   1185          
   1186          /** @defgroup FMC_Group5  Interrupts and flags management functions
   1187            * @brief    Interrupts and flags management functions
   1188            *
   1189          @verbatim   
   1190           ===============================================================================
   1191                       ##### Interrupts and flags management functions #####
   1192           ===============================================================================  
   1193          
   1194          @endverbatim
   1195            * @{
   1196            */
   1197          
   1198          /**
   1199            * @brief  Enables or disables the specified FMC interrupts.
   1200            * @param  FMC_Bank: specifies the FMC Bank to be used
   1201            *          This parameter can be one of the following values:
   1202            *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
   1203            *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
   1204            *            @arg FMC_Bank4_PCCARD: FMC Bank4 PCCARD
   1205            *            @arg FMC_Bank1_SDRAM: FMC Bank1 SDRAM 
   1206            *            @arg FMC_Bank2_SDRAM: FMC Bank2 SDRAM   
   1207            * @param  FMC_IT: specifies the FMC interrupt sources to be enabled or disabled.
   1208            *          This parameter can be any combination of the following values:
   1209            *            @arg FMC_IT_RisingEdge: Rising edge detection interrupt. 
   1210            *            @arg FMC_IT_Level: Level edge detection interrupt.
   1211            *            @arg FMC_IT_FallingEdge: Falling edge detection interrupt.
   1212            *            @arg FMC_IT_Refresh: Refresh error detection interrupt.  
   1213            * @param  NewState: new state of the specified FMC interrupts.
   1214            *          This parameter can be: ENABLE or DISABLE.
   1215            * @retval None
   1216            */

   \                                 In section .text, align 2, keep-with-next
   1217          void FMC_ITConfig(uint32_t FMC_Bank, uint32_t FMC_IT, FunctionalState NewState)
   1218          {
   1219            assert_param(IS_FMC_IT_BANK(FMC_Bank));
   1220            assert_param(IS_FMC_IT(FMC_IT));	
   1221            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1222            
   1223            if (NewState != DISABLE)
   \                     FMC_ITConfig: (+1)
   \        0x0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD01B             BEQ.N    ??FMC_ITConfig_0
   1224            {
   1225              /* Enable the selected FMC_Bank2 interrupts */
   1226              if(FMC_Bank == FMC_Bank2_NAND)
   \        0x6   0x2810             CMP      R0,#+16
   \        0x8   0xD104             BNE.N    ??FMC_ITConfig_1
   1227              {
   1228                FMC_Bank2->SR2 |= FMC_IT;
   \        0xA   0x....             LDR.N    R0,??DataTable23_7  ;; 0xa0000064
   \        0xC   0x6802             LDR      R2,[R0, #+0]
   \        0xE   0x4311             ORRS     R1,R1,R2
   \       0x10   0x6001             STR      R1,[R0, #+0]
   \       0x12   0xE033             B.N      ??FMC_ITConfig_2
   1229              }
   1230              /* Enable the selected FMC_Bank3 interrupts */
   1231              else if (FMC_Bank == FMC_Bank3_NAND)
   \                     ??FMC_ITConfig_1: (+1)
   \       0x14   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x18   0xD104             BNE.N    ??FMC_ITConfig_3
   1232              {
   1233                FMC_Bank3->SR3 |= FMC_IT;
   \       0x1A   0x....             LDR.N    R0,??DataTable23_11  ;; 0xa0000084
   \       0x1C   0x6802             LDR      R2,[R0, #+0]
   \       0x1E   0x4311             ORRS     R1,R1,R2
   \       0x20   0x6001             STR      R1,[R0, #+0]
   \       0x22   0xE02B             B.N      ??FMC_ITConfig_2
   1234              }
   1235              /* Enable the selected FMC_Bank4 interrupts */
   1236              else if (FMC_Bank == FMC_Bank4_PCCARD)
   \                     ??FMC_ITConfig_3: (+1)
   \       0x24   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x28   0xD104             BNE.N    ??FMC_ITConfig_4
   1237              {
   1238                FMC_Bank4->SR4 |= FMC_IT;    
   \       0x2A   0x....             LDR.N    R0,??DataTable23_20  ;; 0xa00000a4
   \       0x2C   0x6802             LDR      R2,[R0, #+0]
   \       0x2E   0x4311             ORRS     R1,R1,R2
   \       0x30   0x6001             STR      R1,[R0, #+0]
   \       0x32   0xE023             B.N      ??FMC_ITConfig_2
   1239              }
   1240              /* Enable the selected FMC_Bank5_6 interrupt */
   1241              else
   1242              {
   1243                /* Enables the interrupt if the refresh error flag is set */
   1244                FMC_Bank5_6->SDRTR |= FMC_IT; 
   \                     ??FMC_ITConfig_4: (+1)
   \       0x34   0x....             LDR.N    R0,??DataTable23_28  ;; 0xa0000154
   \       0x36   0x6802             LDR      R2,[R0, #+0]
   \       0x38   0x4311             ORRS     R1,R1,R2
   \       0x3A   0x6001             STR      R1,[R0, #+0]
   \       0x3C   0xE01E             B.N      ??FMC_ITConfig_2
   1245              }
   1246            }
   1247            else
   1248            {
   1249              /* Disable the selected FMC_Bank2 interrupts */
   1250              if(FMC_Bank == FMC_Bank2_NAND)
   \                     ??FMC_ITConfig_0: (+1)
   \       0x3E   0x2810             CMP      R0,#+16
   \       0x40   0xD105             BNE.N    ??FMC_ITConfig_5
   1251              {
   1252                
   1253                FMC_Bank2->SR2 &= (uint32_t)~FMC_IT;
   \       0x42   0x....             LDR.N    R0,??DataTable23_7  ;; 0xa0000064
   \       0x44   0x6802             LDR      R2,[R0, #+0]
   \       0x46   0xEA32 0x0101      BICS     R1,R2,R1
   \       0x4A   0x6001             STR      R1,[R0, #+0]
   \       0x4C   0xE016             B.N      ??FMC_ITConfig_2
   1254              }
   1255              /* Disable the selected FMC_Bank3 interrupts */
   1256              else if (FMC_Bank == FMC_Bank3_NAND)
   \                     ??FMC_ITConfig_5: (+1)
   \       0x4E   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x52   0xD105             BNE.N    ??FMC_ITConfig_6
   1257              {
   1258                FMC_Bank3->SR3 &= (uint32_t)~FMC_IT;
   \       0x54   0x....             LDR.N    R0,??DataTable23_11  ;; 0xa0000084
   \       0x56   0x6802             LDR      R2,[R0, #+0]
   \       0x58   0xEA32 0x0101      BICS     R1,R2,R1
   \       0x5C   0x6001             STR      R1,[R0, #+0]
   \       0x5E   0xE00D             B.N      ??FMC_ITConfig_2
   1259              }
   1260              /* Disable the selected FMC_Bank4 interrupts */
   1261              else if(FMC_Bank == FMC_Bank4_PCCARD)
   \                     ??FMC_ITConfig_6: (+1)
   \       0x60   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x64   0xD105             BNE.N    ??FMC_ITConfig_7
   1262              {
   1263                FMC_Bank4->SR4 &= (uint32_t)~FMC_IT;    
   \       0x66   0x....             LDR.N    R0,??DataTable23_20  ;; 0xa00000a4
   \       0x68   0x6802             LDR      R2,[R0, #+0]
   \       0x6A   0xEA32 0x0101      BICS     R1,R2,R1
   \       0x6E   0x6001             STR      R1,[R0, #+0]
   \       0x70   0xE004             B.N      ??FMC_ITConfig_2
   1264              }
   1265              /* Disable the selected FMC_Bank5_6 interrupt */
   1266              else
   1267              {
   1268                /* Disables the interrupt if the refresh error flag is not set */
   1269                FMC_Bank5_6->SDRTR &= (uint32_t)~FMC_IT; 
   \                     ??FMC_ITConfig_7: (+1)
   \       0x72   0x....             LDR.N    R0,??DataTable23_28  ;; 0xa0000154
   \       0x74   0x6802             LDR      R2,[R0, #+0]
   \       0x76   0xEA32 0x0101      BICS     R1,R2,R1
   \       0x7A   0x6001             STR      R1,[R0, #+0]
   1270              }
   1271            }
   1272          }
   \                     ??FMC_ITConfig_2: (+1)
   \       0x7C   0x4770             BX       LR               ;; return
   1273          
   1274          /**
   1275            * @brief  Checks whether the specified FMC flag is set or not.
   1276            * @param  FMC_Bank: specifies the FMC Bank to be used
   1277            *          This parameter can be one of the following values:
   1278            *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
   1279            *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
   1280            *            @arg FMC_Bank4_PCCARD: FMC Bank4 PCCARD
   1281            *            @arg FMC_Bank1_SDRAM: FMC Bank1 SDRAM 
   1282            *            @arg FMC_Bank2_SDRAM: FMC Bank2 SDRAM 
   1283            *            @arg FMC_Bank1_SDRAM | FMC_Bank2_SDRAM: FMC Bank1 or Bank2 SDRAM    
   1284            * @param  FMC_FLAG: specifies the flag to check.
   1285            *          This parameter can be one of the following values:
   1286            *            @arg FMC_FLAG_RisingEdge: Rising edge detection Flag.
   1287            *            @arg FMC_FLAG_Level: Level detection Flag.
   1288            *            @arg FMC_FLAG_FallingEdge: Falling edge detection Flag.
   1289            *            @arg FMC_FLAG_FEMPT: Fifo empty Flag.
   1290            *            @arg FMC_FLAG_Refresh: Refresh error Flag.
   1291            *            @arg FMC_FLAG_Busy: Busy status Flag.     
   1292            * @retval The new state of FMC_FLAG (SET or RESET).
   1293            */

   \                                 In section .text, align 2, keep-with-next
   1294          FlagStatus FMC_GetFlagStatus(uint32_t FMC_Bank, uint32_t FMC_FLAG)
   1295          {
   1296            FlagStatus bitstatus = RESET;
   \                     FMC_GetFlagStatus: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1297            uint32_t tmpsr = 0x00000000;
   \        0x2   0x2200             MOVS     R2,#+0
   1298            
   1299            /* Check the parameters */
   1300            assert_param(IS_FMC_GETFLAG_BANK(FMC_Bank));
   1301            assert_param(IS_FMC_GET_FLAG(FMC_FLAG));
   1302            
   1303            if(FMC_Bank == FMC_Bank2_NAND)
   \        0x4   0x2810             CMP      R0,#+16
   \        0x6   0xD102             BNE.N    ??FMC_GetFlagStatus_0
   1304            {
   1305              tmpsr = FMC_Bank2->SR2;
   \        0x8   0x....             LDR.N    R0,??DataTable23_7  ;; 0xa0000064
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0xE00D             B.N      ??FMC_GetFlagStatus_1
   1306            }  
   1307            else if(FMC_Bank == FMC_Bank3_NAND)
   \                     ??FMC_GetFlagStatus_0: (+1)
   \        0xE   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x12   0xD102             BNE.N    ??FMC_GetFlagStatus_2
   1308            {
   1309              tmpsr = FMC_Bank3->SR3;
   \       0x14   0x....             LDR.N    R0,??DataTable23_11  ;; 0xa0000084
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0xE007             B.N      ??FMC_GetFlagStatus_1
   1310            }
   1311            else if(FMC_Bank == FMC_Bank4_PCCARD)
   \                     ??FMC_GetFlagStatus_2: (+1)
   \       0x1A   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x1E   0xD102             BNE.N    ??FMC_GetFlagStatus_3
   1312            {
   1313              tmpsr = FMC_Bank4->SR4;
   \       0x20   0x....             LDR.N    R0,??DataTable23_20  ;; 0xa00000a4
   \       0x22   0x6800             LDR      R0,[R0, #+0]
   \       0x24   0xE001             B.N      ??FMC_GetFlagStatus_1
   1314            }
   1315            else 
   1316            {
   1317              tmpsr = FMC_Bank5_6->SDSR;
   \                     ??FMC_GetFlagStatus_3: (+1)
   \       0x26   0x....             LDR.N    R0,??DataTable23_29  ;; 0xa0000158
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   1318            }
   1319            
   1320            /* Get the flag status */
   1321            if ((tmpsr & FMC_FLAG) != FMC_FLAG )
   \                     ??FMC_GetFlagStatus_1: (+1)
   \       0x2A   0x4008             ANDS     R0,R1,R0
   \       0x2C   0x4288             CMP      R0,R1
   \       0x2E   0xD001             BEQ.N    ??FMC_GetFlagStatus_4
   1322            {
   1323              bitstatus = RESET;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xE000             B.N      ??FMC_GetFlagStatus_5
   1324            }
   1325            else
   1326            {
   1327              bitstatus = SET;
   \                     ??FMC_GetFlagStatus_4: (+1)
   \       0x34   0x2001             MOVS     R0,#+1
   1328            }
   1329            /* Return the flag status */
   1330            return bitstatus;
   \                     ??FMC_GetFlagStatus_5: (+1)
   \       0x36   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x38   0x4770             BX       LR               ;; return
   1331          }
   1332          
   1333          /**
   1334            * @brief  Clears the FMC's pending flags.
   1335            * @param  FMC_Bank: specifies the FMC Bank to be used
   1336            *          This parameter can be one of the following values:
   1337            *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
   1338            *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
   1339            *            @arg FMC_Bank4_PCCARD: FMC Bank4 PCCARD
   1340            *            @arg FMC_Bank1_SDRAM: FMC Bank1 SDRAM 
   1341            *            @arg FMC_Bank2_SDRAM: FMC Bank2 SDRAM  
   1342            * @param  FMC_FLAG: specifies the flag to clear.
   1343            *          This parameter can be any combination of the following values:
   1344            *            @arg FMC_FLAG_RisingEdge: Rising edge detection Flag.
   1345            *            @arg FMC_FLAG_Level: Level detection Flag.
   1346            *            @arg FMC_FLAG_FallingEdge: Falling edge detection Flag.
   1347            *            @arg FMC_FLAG_Refresh: Refresh error Flag.  
   1348            * @retval None
   1349            */

   \                                 In section .text, align 2, keep-with-next
   1350          void FMC_ClearFlag(uint32_t FMC_Bank, uint32_t FMC_FLAG)
   1351          {
   1352           /* Check the parameters */
   1353            assert_param(IS_FMC_GETFLAG_BANK(FMC_Bank));
   1354            assert_param(IS_FMC_CLEAR_FLAG(FMC_FLAG)) ;
   1355              
   1356            if(FMC_Bank == FMC_Bank2_NAND)
   \                     FMC_ClearFlag: (+1)
   \        0x0   0x2810             CMP      R0,#+16
   \        0x2   0xD105             BNE.N    ??FMC_ClearFlag_0
   1357            {
   1358              FMC_Bank2->SR2 &= (~FMC_FLAG); 
   \        0x4   0x....             LDR.N    R0,??DataTable23_7  ;; 0xa0000064
   \        0x6   0x6802             LDR      R2,[R0, #+0]
   \        0x8   0xEA32 0x0101      BICS     R1,R2,R1
   \        0xC   0x6001             STR      R1,[R0, #+0]
   \        0xE   0xE016             B.N      ??FMC_ClearFlag_1
   1359            }  
   1360            else if(FMC_Bank == FMC_Bank3_NAND)
   \                     ??FMC_ClearFlag_0: (+1)
   \       0x10   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x14   0xD105             BNE.N    ??FMC_ClearFlag_2
   1361            {
   1362              FMC_Bank3->SR3 &= (~FMC_FLAG);
   \       0x16   0x....             LDR.N    R0,??DataTable23_11  ;; 0xa0000084
   \       0x18   0x6802             LDR      R2,[R0, #+0]
   \       0x1A   0xEA32 0x0101      BICS     R1,R2,R1
   \       0x1E   0x6001             STR      R1,[R0, #+0]
   \       0x20   0xE00D             B.N      ??FMC_ClearFlag_1
   1363            }
   1364            else if(FMC_Bank == FMC_Bank4_PCCARD)
   \                     ??FMC_ClearFlag_2: (+1)
   \       0x22   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x26   0xD105             BNE.N    ??FMC_ClearFlag_3
   1365            {
   1366              FMC_Bank4->SR4 &= (~FMC_FLAG);
   \       0x28   0x....             LDR.N    R0,??DataTable23_20  ;; 0xa00000a4
   \       0x2A   0x6802             LDR      R2,[R0, #+0]
   \       0x2C   0xEA32 0x0101      BICS     R1,R2,R1
   \       0x30   0x6001             STR      R1,[R0, #+0]
   \       0x32   0xE004             B.N      ??FMC_ClearFlag_1
   1367            }
   1368            /* FMC_Bank5_6 SDRAM*/
   1369            else
   1370            {
   1371              FMC_Bank5_6->SDRTR &= (~FMC_FLAG);
   \                     ??FMC_ClearFlag_3: (+1)
   \       0x34   0x....             LDR.N    R0,??DataTable23_28  ;; 0xa0000154
   \       0x36   0x6802             LDR      R2,[R0, #+0]
   \       0x38   0xEA32 0x0101      BICS     R1,R2,R1
   \       0x3C   0x6001             STR      R1,[R0, #+0]
   1372            }
   1373            
   1374          }
   \                     ??FMC_ClearFlag_1: (+1)
   \       0x3E   0x4770             BX       LR               ;; return
   1375          
   1376          /**
   1377            * @brief  Checks whether the specified FMC interrupt has occurred or not.
   1378            * @param  FMC_Bank: specifies the FMC Bank to be used
   1379            *          This parameter can be one of the following values:
   1380            *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
   1381            *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
   1382            *            @arg FMC_Bank4_PCCARD: FMC Bank4 PCCARD
   1383            *            @arg FMC_Bank1_SDRAM: FMC Bank1 SDRAM 
   1384            *            @arg FMC_Bank2_SDRAM: FMC Bank2 SDRAM   
   1385            * @param  FMC_IT: specifies the FMC interrupt source to check.
   1386            *          This parameter can be one of the following values:
   1387            *            @arg FMC_IT_RisingEdge: Rising edge detection interrupt. 
   1388            *            @arg FMC_IT_Level: Level edge detection interrupt.
   1389            *            @arg FMC_IT_FallingEdge: Falling edge detection interrupt.
   1390            *            @arg FMC_IT_Refresh: Refresh error detection interrupt.    
   1391            * @retval The new state of FMC_IT (SET or RESET).
   1392            */

   \                                 In section .text, align 2, keep-with-next
   1393          ITStatus FMC_GetITStatus(uint32_t FMC_Bank, uint32_t FMC_IT)
   1394          {
   \                     FMC_GetITStatus: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1395            ITStatus bitstatus = RESET;
   \        0x2   0x2200             MOVS     R2,#+0
   1396            uint32_t tmpsr = 0x0;
   \        0x4   0x2200             MOVS     R2,#+0
   1397            uint32_t tmpsr2 = 0x0;
   \        0x6   0x2400             MOVS     R4,#+0
   1398            uint32_t itstatus = 0x0;
   \        0x8   0x2200             MOVS     R2,#+0
   1399            uint32_t itenable = 0x0; 
   \        0xA   0x2200             MOVS     R2,#+0
   1400            
   1401            /* Check the parameters */
   1402            assert_param(IS_FMC_IT_BANK(FMC_Bank));
   1403            assert_param(IS_FMC_GET_IT(FMC_IT));
   1404            
   1405            if(FMC_Bank == FMC_Bank2_NAND)
   \        0xC   0x2810             CMP      R0,#+16
   \        0xE   0xD102             BNE.N    ??FMC_GetITStatus_0
   1406            {
   1407              tmpsr = FMC_Bank2->SR2;
   \       0x10   0x....             LDR.N    R2,??DataTable23_7  ;; 0xa0000064
   \       0x12   0x6813             LDR      R3,[R2, #+0]
   \       0x14   0xE00F             B.N      ??FMC_GetITStatus_1
   1408            }  
   1409            else if(FMC_Bank == FMC_Bank3_NAND)
   \                     ??FMC_GetITStatus_0: (+1)
   \       0x16   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x1A   0xD102             BNE.N    ??FMC_GetITStatus_2
   1410            {
   1411              tmpsr = FMC_Bank3->SR3;
   \       0x1C   0x....             LDR.N    R2,??DataTable23_11  ;; 0xa0000084
   \       0x1E   0x6813             LDR      R3,[R2, #+0]
   \       0x20   0xE009             B.N      ??FMC_GetITStatus_1
   1412            }
   1413            else if(FMC_Bank == FMC_Bank4_PCCARD)
   \                     ??FMC_GetITStatus_2: (+1)
   \       0x22   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x26   0xD102             BNE.N    ??FMC_GetITStatus_3
   1414            {
   1415              tmpsr = FMC_Bank4->SR4;
   \       0x28   0x....             LDR.N    R2,??DataTable23_20  ;; 0xa00000a4
   \       0x2A   0x6813             LDR      R3,[R2, #+0]
   \       0x2C   0xE003             B.N      ??FMC_GetITStatus_1
   1416            }
   1417            /* FMC_Bank5_6 SDRAM*/
   1418            else
   1419            {
   1420              tmpsr = FMC_Bank5_6->SDRTR;
   \                     ??FMC_GetITStatus_3: (+1)
   \       0x2E   0x....             LDR.N    R2,??DataTable23_28  ;; 0xa0000154
   \       0x30   0x6813             LDR      R3,[R2, #+0]
   1421              tmpsr2 = FMC_Bank5_6->SDSR;
   \       0x32   0x....             LDR.N    R2,??DataTable23_29  ;; 0xa0000158
   \       0x34   0x6814             LDR      R4,[R2, #+0]
   1422            } 
   1423            
   1424            /* get the IT enable bit status*/
   1425            itenable = tmpsr & FMC_IT;
   \                     ??FMC_GetITStatus_1: (+1)
   \       0x36   0xEA11 0x0203      ANDS     R2,R1,R3
   1426            
   1427            /* get the corresponding IT Flag status*/
   1428            if((FMC_Bank == FMC_Bank1_SDRAM) || (FMC_Bank == FMC_Bank2_SDRAM))
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD001             BEQ.N    ??FMC_GetITStatus_4
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD103             BNE.N    ??FMC_GetITStatus_5
   1429            {
   1430              itstatus = tmpsr2 & FMC_SDSR_RE;  
   \                     ??FMC_GetITStatus_4: (+1)
   \       0x42   0x0023             MOVS     R3,R4
   \       0x44   0xF013 0x0301      ANDS     R3,R3,#0x1
   \       0x48   0xE001             B.N      ??FMC_GetITStatus_6
   1431            }           
   1432            else
   1433            {
   1434              itstatus = tmpsr & (FMC_IT >> 3);  
   \                     ??FMC_GetITStatus_5: (+1)
   \       0x4A   0xEA13 0x03D1      ANDS     R3,R3,R1, LSR #+3
   1435            }  
   1436            
   1437            if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
   \                     ??FMC_GetITStatus_6: (+1)
   \       0x4E   0x2B00             CMP      R3,#+0
   \       0x50   0xD003             BEQ.N    ??FMC_GetITStatus_7
   \       0x52   0x2A00             CMP      R2,#+0
   \       0x54   0xD001             BEQ.N    ??FMC_GetITStatus_7
   1438            {
   1439              bitstatus = SET;
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0xE000             B.N      ??FMC_GetITStatus_8
   1440            }
   1441            else
   1442            {
   1443              bitstatus = RESET;
   \                     ??FMC_GetITStatus_7: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   1444            }
   1445            return bitstatus; 
   \                     ??FMC_GetITStatus_8: (+1)
   \       0x5C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x5E   0xBC10             POP      {R4}
   \       0x60   0x4770             BX       LR               ;; return
   1446          }
   1447          
   1448          /**
   1449            * @brief  Clears the FMC's interrupt pending bits.
   1450            * @param  FMC_Bank: specifies the FMC Bank to be used
   1451            *          This parameter can be one of the following values:
   1452            *            @arg FMC_Bank2_NAND: FMC Bank2 NAND 
   1453            *            @arg FMC_Bank3_NAND: FMC Bank3 NAND
   1454            *            @arg FMC_Bank4_PCCARD: FMC Bank4 PCCARD
   1455            *            @arg FMC_Bank1_SDRAM: FMC Bank1 SDRAM 
   1456            *            @arg FMC_Bank2_SDRAM: FMC Bank2 SDRAM   
   1457            * @param  FMC_IT: specifies the interrupt pending bit to clear.
   1458            *          This parameter can be any combination of the following values:
   1459            *            @arg FMC_IT_RisingEdge: Rising edge detection interrupt. 
   1460            *            @arg FMC_IT_Level: Level edge detection interrupt.
   1461            *            @arg FMC_IT_FallingEdge: Falling edge detection interrupt.
   1462            *            @arg FMC_IT_Refresh: Refresh error detection interrupt.  
   1463            * @retval None
   1464            */

   \                                 In section .text, align 2, keep-with-next
   1465          void FMC_ClearITPendingBit(uint32_t FMC_Bank, uint32_t FMC_IT)
   1466          {
   1467            /* Check the parameters */
   1468            assert_param(IS_FMC_IT_BANK(FMC_Bank));
   1469            assert_param(IS_FMC_IT(FMC_IT));
   1470              
   1471            if(FMC_Bank == FMC_Bank2_NAND)
   \                     FMC_ClearITPendingBit: (+1)
   \        0x0   0x2810             CMP      R0,#+16
   \        0x2   0xD105             BNE.N    ??FMC_ClearITPendingBit_0
   1472            {
   1473              FMC_Bank2->SR2 &= ~(FMC_IT >> 3); 
   \        0x4   0x....             LDR.N    R0,??DataTable23_7  ;; 0xa0000064
   \        0x6   0x6802             LDR      R2,[R0, #+0]
   \        0x8   0xEA32 0x02D1      BICS     R2,R2,R1, LSR #+3
   \        0xC   0x6002             STR      R2,[R0, #+0]
   \        0xE   0xE016             B.N      ??FMC_ClearITPendingBit_1
   1474            }  
   1475            else if(FMC_Bank == FMC_Bank3_NAND)
   \                     ??FMC_ClearITPendingBit_0: (+1)
   \       0x10   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x14   0xD105             BNE.N    ??FMC_ClearITPendingBit_2
   1476            {
   1477              FMC_Bank3->SR3 &= ~(FMC_IT >> 3);
   \       0x16   0x....             LDR.N    R0,??DataTable23_11  ;; 0xa0000084
   \       0x18   0x6802             LDR      R2,[R0, #+0]
   \       0x1A   0xEA32 0x02D1      BICS     R2,R2,R1, LSR #+3
   \       0x1E   0x6002             STR      R2,[R0, #+0]
   \       0x20   0xE00D             B.N      ??FMC_ClearITPendingBit_1
   1478            }
   1479            else if(FMC_Bank == FMC_Bank4_PCCARD)
   \                     ??FMC_ClearITPendingBit_2: (+1)
   \       0x22   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x26   0xD105             BNE.N    ??FMC_ClearITPendingBit_3
   1480            {
   1481              FMC_Bank4->SR4 &= ~(FMC_IT >> 3);
   \       0x28   0x....             LDR.N    R0,??DataTable23_20  ;; 0xa00000a4
   \       0x2A   0x6802             LDR      R2,[R0, #+0]
   \       0x2C   0xEA32 0x02D1      BICS     R2,R2,R1, LSR #+3
   \       0x30   0x6002             STR      R2,[R0, #+0]
   \       0x32   0xE004             B.N      ??FMC_ClearITPendingBit_1
   1482            }
   1483            /* FMC_Bank5_6 SDRAM*/
   1484            else
   1485            {
   1486              FMC_Bank5_6->SDRTR |= FMC_SDRTR_CRE;
   \                     ??FMC_ClearITPendingBit_3: (+1)
   \       0x34   0x....             LDR.N    R0,??DataTable23_28  ;; 0xa0000154
   \       0x36   0x6801             LDR      R1,[R0, #+0]
   \       0x38   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x3C   0x6001             STR      R1,[R0, #+0]
   1487            }
   1488          }
   \                     ??FMC_ClearITPendingBit_1: (+1)
   \       0x3E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0xA000'0104        DC32     0xa0000104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \        0x0   0xFFE7'0080        DC32     0xffe70080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \        0x0   0xA000'0004        DC32     0xa0000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \        0x0   0xCFF0'0000        DC32     0xcff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \        0x0   0x....'....        DC32     FMC_DefaultTimingStruct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \        0x0   0x000F'FFFE        DC32     0xffffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_6:
   \        0x0   0xA000'0060        DC32     0xa0000060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_7:
   \        0x0   0xA000'0064        DC32     0xa0000064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_8:
   \        0x0   0xA000'0068        DC32     0xa0000068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_9:
   \        0x0   0xA000'006C        DC32     0xa000006c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_10:
   \        0x0   0xA000'0080        DC32     0xa0000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_11:
   \        0x0   0xA000'0084        DC32     0xa0000084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_12:
   \        0x0   0xA000'0088        DC32     0xa0000088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_13:
   \        0x0   0xA000'008C        DC32     0xa000008c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_14:
   \        0x0   0xFFF0'0181        DC32     0xfff00181

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_15:
   \        0x0   0x000F'FFFB        DC32     0xffffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_16:
   \        0x0   0x000F'FFBF        DC32     0xfffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_17:
   \        0x0   0xA000'0074        DC32     0xa0000074

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_18:
   \        0x0   0xA000'0094        DC32     0xa0000094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_19:
   \        0x0   0xA000'00A0        DC32     0xa00000a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_20:
   \        0x0   0xA000'00A4        DC32     0xa00000a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_21:
   \        0x0   0xA000'00A8        DC32     0xa00000a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_22:
   \        0x0   0xA000'00AC        DC32     0xa00000ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_23:
   \        0x0   0xA000'00B0        DC32     0xa00000b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_24:
   \        0x0   0xFFFE'01CD        DC32     0xfffe01cd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_25:
   \        0x0   0xA000'0140        DC32     0xa0000140

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_26:
   \        0x0   0xA000'0148        DC32     0xa0000148

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_27:
   \        0x0   0xA000'0150        DC32     0xa0000150

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_28:
   \        0x0   0xA000'0154        DC32     0xa0000154

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_29:
   \        0x0   0xA000'0158        DC32     0xa0000158
   1489          
   1490          /**
   1491            * @}
   1492            */ 
   1493          
   1494          /**
   1495            * @}
   1496            */ 
   1497          
   1498          /**
   1499            * @}
   1500            */
   1501          
   1502          /**
   1503            * @}
   1504            */
   1505          
   1506          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FMC_ClearFlag
       0   FMC_ClearITPendingBit
       0   FMC_GetECC
       0   FMC_GetFlagStatus
       4   FMC_GetITStatus
       0   FMC_GetModeStatus
       0   FMC_ITConfig
       0   FMC_NANDCmd
       0   FMC_NANDDeInit
       0   FMC_NANDECCCmd
       8   FMC_NANDInit
       0   FMC_NANDStructInit
       0   FMC_NORSRAMCmd
       0   FMC_NORSRAMDeInit
       8   FMC_NORSRAMInit
       0   FMC_NORSRAMStructInit
       0   FMC_PCCARDCmd
       0   FMC_PCCARDDeInit
       4   FMC_PCCARDInit
       0   FMC_PCCARDStructInit
       0   FMC_SDRAMCmdConfig
       0   FMC_SDRAMDeInit
       8   FMC_SDRAMInit
       0   FMC_SDRAMStructInit
       0   FMC_SDRAMWriteProtectionConfig
       0   FMC_SetAutoRefresh_Number
       0   FMC_SetRefreshCount


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_10
       4  ??DataTable23_11
       4  ??DataTable23_12
       4  ??DataTable23_13
       4  ??DataTable23_14
       4  ??DataTable23_15
       4  ??DataTable23_16
       4  ??DataTable23_17
       4  ??DataTable23_18
       4  ??DataTable23_19
       4  ??DataTable23_2
       4  ??DataTable23_20
       4  ??DataTable23_21
       4  ??DataTable23_22
       4  ??DataTable23_23
       4  ??DataTable23_24
       4  ??DataTable23_25
       4  ??DataTable23_26
       4  ??DataTable23_27
       4  ??DataTable23_28
       4  ??DataTable23_29
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
       4  ??DataTable23_8
       4  ??DataTable23_9
      64  FMC_ClearFlag
      64  FMC_ClearITPendingBit
      28  FMC_DefaultTimingStruct
      22  FMC_GetECC
      58  FMC_GetFlagStatus
      98  FMC_GetITStatus
      28  FMC_GetModeStatus
     126  FMC_ITConfig
      74  FMC_NANDCmd
      72  FMC_NANDDeInit
      74  FMC_NANDECCCmd
     218  FMC_NANDInit
      78  FMC_NANDStructInit
      44  FMC_NORSRAMCmd
      54  FMC_NORSRAMDeInit
     304  FMC_NORSRAMInit
      70  FMC_NORSRAMStructInit
      36  FMC_PCCARDCmd
      40  FMC_PCCARDDeInit
     168  FMC_PCCARDInit
      86  FMC_PCCARDStructInit
      28  FMC_SDRAMCmdConfig
      50  FMC_SDRAMDeInit
     286  FMC_SDRAMInit
      86  FMC_SDRAMStructInit
      40  FMC_SDRAMWriteProtectionConfig
      12  FMC_SetAutoRefresh_Number
      12  FMC_SetRefreshCount

 
    28 bytes in section .rodata
 2'412 bytes in section .text
 
 2'412 bytes of CODE  memory
    28 bytes of CONST memory

Errors: none
Warnings: none
