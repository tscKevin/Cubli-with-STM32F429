###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.2.214/W32 for ARM         14/Jul/2020  18:42:07
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_spi.c
#    Command line =
#        -f C:\Users\Evan\AppData\Local\Temp\EWA51B.tmp
#        (E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_spi.c
#        -D USE_STDPERIPH_DRIVER -D STM32F429_439xx -lC
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List
#        -o
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\IAR Systems\Embedded
#        Workbench 8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\iar\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\user\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\user\src\
#        -Ol --use_c++_inline -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List\stm32f4xx_spi.lst
#    Object file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj\stm32f4xx_spi.o
#
###############################################################################

E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.8.0
      6            * @date    04-November-2016
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Serial peripheral interface (SPI):
      9            *           + Initialization and Configuration
     10            *           + Data transfers functions
     11            *           + Hardware CRC Calculation
     12            *           + DMA transfers management
     13            *           + Interrupts and flags management 
     14            *           
     15          @verbatim
     16          
     17           ===================================================================
     18                            ##### How to use this driver #####
     19           ===================================================================
     20           [..]
     21             (#) Enable peripheral clock using the following functions 
     22                 RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE) for SPI1
     23                 RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE) for SPI2
     24                 RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI3
     25                 RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI4
     26                 RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI5
     27                 RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI6.
     28            
     29             (#) Enable SCK, MOSI, MISO and NSS GPIO clocks using RCC_AHB1PeriphClockCmd()
     30                 function. In I2S mode, if an external clock source is used then the I2S 
     31                 CKIN pin GPIO clock should also be enabled.
     32            
     33             (#) Peripherals alternate function: 
     34                 (++) Connect the pin to the desired peripherals' Alternate Function (AF) 
     35                      using GPIO_PinAFConfig() function
     36                 (++) Configure the desired pin in alternate function by: 
     37                      GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     38                 (++) Select the type, pull-up/pull-down and output speed via GPIO_PuPd, 
     39                      GPIO_OType and GPIO_Speed members
     40                 (++) Call GPIO_Init() function In I2S mode, if an external clock source is 
     41                      used then the I2S CKIN pin should be also configured in Alternate 
     42                      function Push-pull pull-up mode. 
     43                    
     44             (#) Program the Polarity, Phase, First Data, Baud Rate Prescaler, Slave 
     45                 Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
     46                 function.
     47                 In I2S mode, program the Mode, Standard, Data Format, MCLK Output, Audio 
     48                 frequency and Polarity using I2S_Init() function. For I2S mode, make sure 
     49                 that either:
     50                 (++) I2S PLL is configured using the functions 
     51                      RCC_I2SCLKConfig(RCC_I2S2CLKSource_PLLI2S), RCC_PLLI2SCmd(ENABLE) and 
     52                      RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY); or 
     53                 (++) External clock source is configured using the function 
     54                      RCC_I2SCLKConfig(RCC_I2S2CLKSource_Ext) and after setting correctly 
     55                      the define constant I2S_EXTERNAL_CLOCK_VAL in the stm32f4xx_conf.h file. 
     56            
     57             (#) Enable the NVIC and the corresponding interrupt using the function 
     58                 SPI_ITConfig() if you need to use interrupt mode. 
     59            
     60             (#) When using the DMA mode 
     61                 (++) Configure the DMA using DMA_Init() function
     62                 (++) Active the needed channel Request using SPI_I2S_DMACmd() function
     63             
     64             (#) Enable the SPI using the SPI_Cmd() function or enable the I2S using
     65                 I2S_Cmd().
     66             
     67             (#) Enable the DMA using the DMA_Cmd() function when using DMA mode. 
     68            
     69             (#) Optionally, you can enable/configure the following parameters without
     70                 re-initialization (i.e there is no need to call again SPI_Init() function):
     71                 (++) When bidirectional mode (SPI_Direction_1Line_Rx or SPI_Direction_1Line_Tx)
     72                      is programmed as Data direction parameter using the SPI_Init() function
     73                      it can be possible to switch between SPI_Direction_Tx or SPI_Direction_Rx
     74                      using the SPI_BiDirectionalLineConfig() function.
     75                 (++) When SPI_NSS_Soft is selected as Slave Select Management parameter 
     76                      using the SPI_Init() function it can be possible to manage the 
     77                      NSS internal signal using the SPI_NSSInternalSoftwareConfig() function.
     78                 (++) Reconfigure the data size using the SPI_DataSizeConfig() function  
     79                 (++) Enable or disable the SS output using the SPI_SSOutputCmd() function  
     80                      
     81              (#) To use the CRC Hardware calculation feature refer to the Peripheral 
     82                  CRC hardware Calculation subsection.
     83               
     84            
     85           [..] It is possible to use SPI in I2S full duplex mode, in this case, each SPI 
     86                peripheral is able to manage sending and receiving data simultaneously
     87                using two data lines. Each SPI peripheral has an extended block called I2Sxext
     88                (ie. I2S2ext for SPI2 and I2S3ext for SPI3).
     89                The extension block is not a full SPI IP, it is used only as I2S slave to
     90                implement full duplex mode. The extension block uses the same clock sources
     91                as its master.          
     92                To configure I2S full duplex you have to:
     93                        
     94                (#) Configure SPIx in I2S mode (I2S_Init() function) as described above. 
     95                       
     96                (#) Call the I2S_FullDuplexConfig() function using the same structure passed to  
     97                    I2S_Init() function.
     98                        
     99                (#) Call I2S_Cmd() for SPIx then for its extended block.
    100                      
    101                (#) To configure interrupts or DMA requests and to get/clear flag status, 
    102                    use I2Sxext instance for the extension block.
    103                         
    104           [..] Functions that can be called with I2Sxext instances are: I2S_Cmd(), 
    105                I2S_FullDuplexConfig(), SPI_I2S_ReceiveData(), SPI_I2S_SendData(), 
    106                SPI_I2S_DMACmd(), SPI_I2S_ITConfig(), SPI_I2S_GetFlagStatus(), 
    107                SPI_I2S_ClearFlag(), SPI_I2S_GetITStatus() and SPI_I2S_ClearITPendingBit().
    108                             
    109                Example: To use SPI3 in Full duplex mode (SPI3 is Master Tx, I2S3ext is Slave Rx):
    110                        
    111                RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3, ENABLE);   
    112                I2S_StructInit(&I2SInitStruct);
    113                I2SInitStruct.Mode = I2S_Mode_MasterTx;     
    114                I2S_Init(SPI3, &I2SInitStruct);
    115                I2S_FullDuplexConfig(SPI3ext, &I2SInitStruct)
    116                I2S_Cmd(SPI3, ENABLE);
    117                I2S_Cmd(SPI3ext, ENABLE);
    118                ...
    119                while (SPI_I2S_GetFlagStatus(SPI2, SPI_FLAG_TXE) == RESET)
    120                {}
    121                SPI_I2S_SendData(SPI3, txdata[i]);
    122                ...  
    123                while (SPI_I2S_GetFlagStatus(I2S3ext, SPI_FLAG_RXNE) == RESET)
    124                {}
    125                rxdata[i] = SPI_I2S_ReceiveData(I2S3ext);
    126                ...          
    127                          
    128           [..]       
    129             (@) In I2S mode: if an external clock is used as source clock for the I2S,  
    130                 then the define I2S_EXTERNAL_CLOCK_VAL in file stm32f4xx_conf.h should 
    131                 be enabled and set to the value of the source clock frequency (in Hz).
    132             
    133             (@) In SPI mode: To use the SPI TI mode, call the function SPI_TIModeCmd() 
    134                 just after calling the function SPI_Init().
    135            
    136          @endverbatim  
    137            *                                  
    138            ******************************************************************************
    139            * @attention
    140            *
    141            * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
    142            *
    143            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    144            * You may not use this file except in compliance with the License.
    145            * You may obtain a copy of the License at:
    146            *
    147            *        http://www.st.com/software_license_agreement_liberty_v2
    148            *
    149            * Unless required by applicable law or agreed to in writing, software 
    150            * distributed under the License is distributed on an "AS IS" BASIS, 
    151            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    152            * See the License for the specific language governing permissions and
    153            * limitations under the License.
    154            *
    155            ******************************************************************************  
    156            */ 
    157          
    158          /* Includes ------------------------------------------------------------------*/
    159          #include "stm32f4xx_spi.h"
    160          #include "stm32f4xx_rcc.h"
    161          
    162          /** @addtogroup STM32F4xx_StdPeriph_Driver
    163            * @{
    164            */
    165          
    166          /** @defgroup SPI 
    167            * @brief SPI driver modules
    168            * @{
    169            */ 
    170          
    171          /* Private typedef -----------------------------------------------------------*/
    172          /* Private define ------------------------------------------------------------*/
    173          
    174          /* SPI registers Masks */
    175          #define CR1_CLEAR_MASK            ((uint16_t)0x3040)
    176          #define I2SCFGR_CLEAR_MASK        ((uint16_t)0xF040)
    177          
    178          /* RCC PLLs masks */
    179          #define PLLCFGR_PPLR_MASK         ((uint32_t)0x70000000)
    180          #define PLLCFGR_PPLN_MASK         ((uint32_t)0x00007FC0)
    181          
    182          #define SPI_CR2_FRF               ((uint16_t)0x0010)
    183          #define SPI_SR_TIFRFE             ((uint16_t)0x0100)
    184          
    185          /* Private macro -------------------------------------------------------------*/
    186          /* Private variables ---------------------------------------------------------*/
    187          /* Private function prototypes -----------------------------------------------*/
    188          /* Private functions ---------------------------------------------------------*/
    189          
    190          /** @defgroup SPI_Private_Functions
    191            * @{
    192            */
    193          
    194          /** @defgroup SPI_Group1 Initialization and Configuration functions
    195           *  @brief   Initialization and Configuration functions 
    196           *
    197          @verbatim   
    198           ===============================================================================
    199                       ##### Initialization and Configuration functions ##### 
    200           ===============================================================================  
    201           [..] This section provides a set of functions allowing to initialize the SPI 
    202                Direction, SPI Mode, SPI Data Size, SPI Polarity, SPI Phase, SPI NSS 
    203                Management, SPI Baud Rate Prescaler, SPI First Bit and SPI CRC Polynomial.
    204            
    205           [..] The SPI_Init() function follows the SPI configuration procedures for Master 
    206                mode and Slave mode (details for these procedures are available in reference 
    207                manual (RM0090)).
    208            
    209          @endverbatim
    210            * @{
    211            */
    212          
    213          /**
    214            * @brief  De-initialize the SPIx peripheral registers to their default reset values.
    215            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
    216            *         in SPI mode or 2 or 3 in I2S mode.   
    217            *         
    218            * @note   The extended I2S blocks (ie. I2S2ext and I2S3ext blocks) are de-initialized
    219            *         when the relative I2S peripheral is de-initialized (the extended block's clock
    220            *         is managed by the I2S peripheral clock).
    221            *             
    222            * @retval None
    223            */

   \                                 In section .text, align 2, keep-with-next
    224          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
    225          {
   \                     SPI_I2S_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    226            /* Check the parameters */
    227            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    228          
    229            if (SPIx == SPI1)
   \        0x2   0x....             LDR.N    R1,??DataTable1  ;; 0x40013000
   \        0x4   0x4288             CMP      R0,R1
   \        0x6   0xD10A             BNE.N    ??SPI_I2S_DeInit_0
    230            {
    231              /* Enable SPI1 reset state */
    232              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0xF44F 0x5080      MOV      R0,#+4096
   \        0xE   0x....'....        BL       RCC_APB2PeriphResetCmd
    233              /* Release SPI1 from reset state */
    234              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0xF44F 0x5080      MOV      R0,#+4096
   \       0x18   0x....'....        BL       RCC_APB2PeriphResetCmd
   \       0x1C   0xE044             B.N      ??SPI_I2S_DeInit_1
    235            }
    236            else if (SPIx == SPI2)
   \                     ??SPI_I2S_DeInit_0: (+1)
   \       0x1E   0x....             LDR.N    R1,??DataTable1_1  ;; 0x40003800
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD10A             BNE.N    ??SPI_I2S_DeInit_2
    237            {
    238              /* Enable SPI2 reset state */
    239              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0xF44F 0x4080      MOV      R0,#+16384
   \       0x2A   0x....'....        BL       RCC_APB1PeriphResetCmd
    240              /* Release SPI2 from reset state */
    241              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0xF44F 0x4080      MOV      R0,#+16384
   \       0x34   0x....'....        BL       RCC_APB1PeriphResetCmd
   \       0x38   0xE036             B.N      ??SPI_I2S_DeInit_1
    242            }
    243            else if (SPIx == SPI3)
   \                     ??SPI_I2S_DeInit_2: (+1)
   \       0x3A   0x....             LDR.N    R1,??DataTable1_2  ;; 0x40003c00
   \       0x3C   0x4288             CMP      R0,R1
   \       0x3E   0xD10A             BNE.N    ??SPI_I2S_DeInit_3
    244            {
    245              /* Enable SPI3 reset state */
    246              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
   \       0x40   0x2101             MOVS     R1,#+1
   \       0x42   0xF44F 0x4000      MOV      R0,#+32768
   \       0x46   0x....'....        BL       RCC_APB1PeriphResetCmd
    247              /* Release SPI3 from reset state */
    248              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0xF44F 0x4000      MOV      R0,#+32768
   \       0x50   0x....'....        BL       RCC_APB1PeriphResetCmd
   \       0x54   0xE028             B.N      ??SPI_I2S_DeInit_1
    249            }
    250            else if (SPIx == SPI4)
   \                     ??SPI_I2S_DeInit_3: (+1)
   \       0x56   0x....             LDR.N    R1,??DataTable1_3  ;; 0x40013400
   \       0x58   0x4288             CMP      R0,R1
   \       0x5A   0xD10A             BNE.N    ??SPI_I2S_DeInit_4
    251            {
    252              /* Enable SPI4 reset state */
    253              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, ENABLE);
   \       0x5C   0x2101             MOVS     R1,#+1
   \       0x5E   0xF44F 0x5000      MOV      R0,#+8192
   \       0x62   0x....'....        BL       RCC_APB2PeriphResetCmd
    254              /* Release SPI4 from reset state */
    255              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, DISABLE);
   \       0x66   0x2100             MOVS     R1,#+0
   \       0x68   0xF44F 0x5000      MOV      R0,#+8192
   \       0x6C   0x....'....        BL       RCC_APB2PeriphResetCmd
   \       0x70   0xE01A             B.N      ??SPI_I2S_DeInit_1
    256            }
    257            else if (SPIx == SPI5)
   \                     ??SPI_I2S_DeInit_4: (+1)
   \       0x72   0x....             LDR.N    R1,??DataTable1_4  ;; 0x40015000
   \       0x74   0x4288             CMP      R0,R1
   \       0x76   0xD10A             BNE.N    ??SPI_I2S_DeInit_5
    258            {
    259              /* Enable SPI5 reset state */
    260              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, ENABLE);
   \       0x78   0x2101             MOVS     R1,#+1
   \       0x7A   0xF45F 0x1080      MOVS     R0,#+1048576
   \       0x7E   0x....'....        BL       RCC_APB2PeriphResetCmd
    261              /* Release SPI5 from reset state */
    262              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, DISABLE);
   \       0x82   0x2100             MOVS     R1,#+0
   \       0x84   0xF45F 0x1080      MOVS     R0,#+1048576
   \       0x88   0x....'....        BL       RCC_APB2PeriphResetCmd
   \       0x8C   0xE00C             B.N      ??SPI_I2S_DeInit_1
    263            }
    264            else 
    265            {
    266              if (SPIx == SPI6)
   \                     ??SPI_I2S_DeInit_5: (+1)
   \       0x8E   0x....             LDR.N    R1,??DataTable1_5  ;; 0x40015400
   \       0x90   0x4288             CMP      R0,R1
   \       0x92   0xD109             BNE.N    ??SPI_I2S_DeInit_1
    267              {
    268                /* Enable SPI6 reset state */
    269                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, ENABLE);
   \       0x94   0x2101             MOVS     R1,#+1
   \       0x96   0xF45F 0x1000      MOVS     R0,#+2097152
   \       0x9A   0x....'....        BL       RCC_APB2PeriphResetCmd
    270                /* Release SPI6 from reset state */
    271                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, DISABLE);
   \       0x9E   0x2100             MOVS     R1,#+0
   \       0xA0   0xF45F 0x1000      MOVS     R0,#+2097152
   \       0xA4   0x....'....        BL       RCC_APB2PeriphResetCmd
    272              }
    273            }
    274          }
   \                     ??SPI_I2S_DeInit_1: (+1)
   \       0xA8   0xBD01             POP      {R0,PC}          ;; return
    275          
    276          /**
    277            * @brief  Initializes the SPIx peripheral according to the specified 
    278            *         parameters in the SPI_InitStruct.
    279            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    280            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    281            *         contains the configuration information for the specified SPI peripheral.
    282            * @retval None
    283            */

   \                                 In section .text, align 2, keep-with-next
    284          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    285          {
   \                     SPI_Init: (+1)
   \        0x0   0xB410             PUSH     {R4}
    286            uint16_t tmpreg = 0;
   \        0x2   0x2200             MOVS     R2,#+0
    287            
    288            /* check the parameters */
    289            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    290            
    291            /* Check the SPI parameters */
    292            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
    293            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
    294            assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
    295            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
    296            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
    297            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
    298            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
    299            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
    300            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
    301          
    302          /*---------------------------- SPIx CR1 Configuration ------------------------*/
    303            /* Get the SPIx CR1 value */
    304            tmpreg = SPIx->CR1;
   \        0x4   0x8803             LDRH     R3,[R0, #+0]
    305            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    306            tmpreg &= CR1_CLEAR_MASK;
   \        0x6   0xF413 0x5341      ANDS     R3,R3,#0x3040
    307            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    308               master/salve mode, CPOL and CPHA */
    309            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    310            /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    311            /* Set LSBFirst bit according to SPI_FirstBit value */
    312            /* Set BR bits according to SPI_BaudRatePrescaler value */
    313            /* Set CPOL bit according to SPI_CPOL value */
    314            /* Set CPHA bit according to SPI_CPHA value */
    315            tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
    316                            SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
    317                            SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
    318                            SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
   \        0xA   0x880C             LDRH     R4,[R1, #+0]
   \        0xC   0x884A             LDRH     R2,[R1, #+2]
   \        0xE   0x4314             ORRS     R4,R2,R4
   \       0x10   0x888A             LDRH     R2,[R1, #+4]
   \       0x12   0x4314             ORRS     R4,R2,R4
   \       0x14   0x88CA             LDRH     R2,[R1, #+6]
   \       0x16   0x4314             ORRS     R4,R2,R4
   \       0x18   0x890A             LDRH     R2,[R1, #+8]
   \       0x1A   0x4314             ORRS     R4,R2,R4
   \       0x1C   0x894A             LDRH     R2,[R1, #+10]
   \       0x1E   0x4314             ORRS     R4,R2,R4
   \       0x20   0x898A             LDRH     R2,[R1, #+12]
   \       0x22   0x4314             ORRS     R4,R2,R4
   \       0x24   0x89CA             LDRH     R2,[R1, #+14]
   \       0x26   0x4314             ORRS     R4,R2,R4
   \       0x28   0x4323             ORRS     R3,R4,R3
    319            /* Write to SPIx CR1 */
    320            SPIx->CR1 = tmpreg;
   \       0x2A   0x8003             STRH     R3,[R0, #+0]
    321          
    322            /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    323            SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
   \       0x2C   0x8B83             LDRH     R3,[R0, #+28]
   \       0x2E   0xF24F 0x72FF      MOVW     R2,#+63487
   \       0x32   0x4013             ANDS     R3,R2,R3
   \       0x34   0x8383             STRH     R3,[R0, #+28]
    324          /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    325            /* Write to SPIx CRCPOLY */
    326            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
   \       0x36   0x8A09             LDRH     R1,[R1, #+16]
   \       0x38   0x8201             STRH     R1,[R0, #+16]
    327          }
   \       0x3A   0xBC10             POP      {R4}
   \       0x3C   0x4770             BX       LR               ;; return
    328          
    329          /**
    330            * @brief  Initializes the SPIx peripheral according to the specified 
    331            *         parameters in the I2S_InitStruct.
    332            * @param  SPIx: where x can be  2 or 3 to select the SPI peripheral (configured in I2S mode).
    333            * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    334            *         contains the configuration information for the specified SPI peripheral
    335            *         configured in I2S mode.
    336            *           
    337            * @note   The function calculates the optimal prescaler needed to obtain the most 
    338            *         accurate audio frequency (depending on the I2S clock source, the PLL values 
    339            *         and the product configuration). But in case the prescaler value is greater 
    340            *         than 511, the default value (0x02) will be configured instead.    
    341            * 
    342            * @note   if an external clock is used as source clock for the I2S, then the define
    343            *         I2S_EXTERNAL_CLOCK_VAL in file stm32f4xx_conf.h should be enabled and set
    344            *         to the value of the source clock frequency (in Hz).
    345            *  
    346            * @retval None
    347            */

   \                                 In section .text, align 2, keep-with-next
    348          void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
    349          {
   \                     I2S_Init: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
    350            uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2202             MOVS     R2,#+2
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x2201             MOVS     R2,#+1
    351            uint32_t tmp = 0, i2sclk = 0;
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2200             MOVS     R2,#+0
    352          #ifndef I2S_EXTERNAL_CLOCK_VAL
    353            uint32_t pllm = 0, plln = 0, pllr = 0;
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0x2200             MOVS     R2,#+0
    354          #endif /* I2S_EXTERNAL_CLOCK_VAL */
    355            
    356            /* Check the I2S parameters */
    357            assert_param(IS_SPI_23_PERIPH(SPIx));
    358            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
    359            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
    360            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
    361            assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
    362            assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
    363            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
    364          
    365          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    366            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    367            SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
   \       0x14   0x8B83             LDRH     R3,[R0, #+28]
   \       0x16   0xF24F 0x0240      MOVW     R2,#+61504
   \       0x1A   0x4013             ANDS     R3,R2,R3
   \       0x1C   0x8383             STRH     R3,[R0, #+28]
    368            SPIx->I2SPR = 0x0002;
   \       0x1E   0x2202             MOVS     R2,#+2
   \       0x20   0x8402             STRH     R2,[R0, #+32]
    369            
    370            /* Get the I2SCFGR register value */
    371            tmpreg = SPIx->I2SCFGR;
   \       0x22   0x8B83             LDRH     R3,[R0, #+28]
    372            
    373            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    374            if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
   \       0x24   0x688A             LDR      R2,[R1, #+8]
   \       0x26   0x2A02             CMP      R2,#+2
   \       0x28   0xD102             BNE.N    ??I2S_Init_0
    375            {
    376              i2sodd = (uint16_t)0;
   \       0x2A   0x2500             MOVS     R5,#+0
    377              i2sdiv = (uint16_t)2;   
   \       0x2C   0x2402             MOVS     R4,#+2
   \       0x2E   0xE04C             B.N      ??I2S_Init_1
    378            }
    379            /* If the requested audio frequency is not the default, compute the prescaler */
    380            else
    381            {
    382              /* Check the frame length (For the Prescaler computing) *******************/
    383              if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
   \                     ??I2S_Init_0: (+1)
   \       0x30   0x888A             LDRH     R2,[R1, #+4]
   \       0x32   0x2A00             CMP      R2,#+0
   \       0x34   0xD101             BNE.N    ??I2S_Init_2
    384              {
    385                /* Packet length is 16 bits */
    386                packetlength = 1;
   \       0x36   0x2201             MOVS     R2,#+1
   \       0x38   0xE000             B.N      ??I2S_Init_3
    387              }
    388              else
    389              {
    390                /* Packet length is 32 bits */
    391                packetlength = 2;
   \                     ??I2S_Init_2: (+1)
   \       0x3A   0x2202             MOVS     R2,#+2
    392              }
    393          
    394              /* Get I2S source Clock frequency  ****************************************/
    395                
    396              /* If an external I2S clock has to be used, this define should be set  
    397                 in the project configuration or in the stm32f4xx_conf.h file */
    398            #ifdef I2S_EXTERNAL_CLOCK_VAL     
    399              /* Set external clock as I2S clock source */
    400              if ((RCC->CFGR & RCC_CFGR_I2SSRC) == 0)
    401              {
    402                RCC->CFGR |= (uint32_t)RCC_CFGR_I2SSRC;
    403              }
    404              
    405              /* Set the I2S clock to the external clock  value */
    406              i2sclk = I2S_EXTERNAL_CLOCK_VAL;
    407          
    408            #else /* There is no define for External I2S clock source */
    409              /* Set PLLI2S as I2S clock source */
    410              if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
   \                     ??I2S_Init_3: (+1)
   \       0x3C   0x....             LDR.N    R4,??DataTable1_6  ;; 0x40023808
   \       0x3E   0x6825             LDR      R5,[R4, #+0]
   \       0x40   0x022D             LSLS     R5,R5,#+8
   \       0x42   0xD503             BPL.N    ??I2S_Init_4
    411              {
    412                RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
   \       0x44   0x6825             LDR      R5,[R4, #+0]
   \       0x46   0xF435 0x0500      BICS     R5,R5,#0x800000
   \       0x4A   0x6025             STR      R5,[R4, #+0]
    413              }    
    414              
    415              /* Get the PLLI2SN value */
    416              plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
    417                                (RCC_PLLI2SCFGR_PLLI2SN >> 6));
   \                     ??I2S_Init_4: (+1)
   \       0x4C   0x....             LDR.N    R5,??DataTable1_7  ;; 0x40023884
   \       0x4E   0x682C             LDR      R4,[R5, #+0]
   \       0x50   0xF3C4 0x1488      UBFX     R4,R4,#+6,#+9
    418              
    419              /* Get the PLLI2SR value */
    420              pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
    421                                (RCC_PLLI2SCFGR_PLLI2SR >> 28));
   \       0x54   0x682D             LDR      R5,[R5, #+0]
   \       0x56   0xF3C5 0x7602      UBFX     R6,R5,#+28,#+3
    422              
    423              /* Get the PLLM value */
    424              pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);
   \       0x5A   0x....             LDR.N    R7,??DataTable1_8  ;; 0x40023804
   \       0x5C   0x683D             LDR      R5,[R7, #+0]
   \       0x5E   0xF015 0x053F      ANDS     R5,R5,#0x3F
    425          
    426              if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)
   \       0x62   0x683F             LDR      R7,[R7, #+0]
   \       0x64   0x027F             LSLS     R7,R7,#+9
   \       0x66   0xD507             BPL.N    ??I2S_Init_5
    427              {
    428                /* Get the I2S source clock value */
    429                i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
   \       0x68   0x....             LDR.N    R7,??DataTable1_9  ;; 0x7a1200
   \       0x6A   0xFBB7 0xF5F5      UDIV     R5,R7,R5
   \       0x6E   0xFB04 0xF405      MUL      R4,R4,R5
   \       0x72   0xFBB4 0xF4F6      UDIV     R4,R4,R6
   \       0x76   0xE006             B.N      ??I2S_Init_6
    430              }
    431              else
    432              { /* Get the I2S source clock value */
    433                i2sclk = (uint32_t)(((HSI_VALUE / pllm) * plln) / pllr);
   \                     ??I2S_Init_5: (+1)
   \       0x78   0x....             LDR.N    R7,??DataTable1_10  ;; 0xf42400
   \       0x7A   0xFBB7 0xF5F5      UDIV     R5,R7,R5
   \       0x7E   0xFB04 0xF405      MUL      R4,R4,R5
   \       0x82   0xFBB4 0xF4F6      UDIV     R4,R4,R6
    434              }
    435            #endif /* I2S_EXTERNAL_CLOCK_VAL */
    436              
    437              /* Compute the Real divider depending on the MCLK output state, with a floating point */
    438              if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
   \                     ??I2S_Init_6: (+1)
   \       0x86   0x88CD             LDRH     R5,[R1, #+6]
   \       0x88   0xF5B5 0x7F00      CMP      R5,#+512
   \       0x8C   0xD108             BNE.N    ??I2S_Init_7
    439              {
    440                /* MCLK output is enabled */
    441                tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
   \       0x8E   0x0A24             LSRS     R4,R4,#+8
   \       0x90   0x220A             MOVS     R2,#+10
   \       0x92   0x4354             MULS     R4,R2,R4
   \       0x94   0x688A             LDR      R2,[R1, #+8]
   \       0x96   0xFBB4 0xF2F2      UDIV     R2,R4,R2
   \       0x9A   0x1D52             ADDS     R2,R2,#+5
   \       0x9C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \       0x9E   0xE00A             B.N      ??I2S_Init_8
    442              }
    443              else
    444              {
    445                /* MCLK output is disabled */
    446                tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
   \                     ??I2S_Init_7: (+1)
   \       0xA0   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \       0xA2   0x0152             LSLS     R2,R2,#+5
   \       0xA4   0xFBB4 0xF4F2      UDIV     R4,R4,R2
   \       0xA8   0x220A             MOVS     R2,#+10
   \       0xAA   0x4354             MULS     R4,R2,R4
   \       0xAC   0x688A             LDR      R2,[R1, #+8]
   \       0xAE   0xFBB4 0xF2F2      UDIV     R2,R4,R2
   \       0xB2   0x1D52             ADDS     R2,R2,#+5
   \       0xB4   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
    447              }
    448              
    449              /* Remove the flatting point */
    450              tmp = tmp / 10;  
   \                     ??I2S_Init_8: (+1)
   \       0xB6   0x240A             MOVS     R4,#+10
   \       0xB8   0xFBB2 0xF2F4      UDIV     R2,R2,R4
    451                
    452              /* Check the parity of the divider */
    453              i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   \       0xBC   0xF012 0x0501      ANDS     R5,R2,#0x1
    454             
    455              /* Compute the i2sdiv prescaler */
    456              i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
   \       0xC0   0x002C             MOVS     R4,R5
   \       0xC2   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \       0xC4   0x1B14             SUBS     R4,R2,R4
   \       0xC6   0x0864             LSRS     R4,R4,#+1
    457             
    458              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    459              i2sodd = (uint16_t) (i2sodd << 8);
   \       0xC8   0x022D             LSLS     R5,R5,#+8
    460            }
    461          
    462            /* Test if the divider is 1 or 0 or greater than 0xFF */
    463            if ((i2sdiv < 2) || (i2sdiv > 0xFF))
   \                     ??I2S_Init_1: (+1)
   \       0xCA   0x0022             MOVS     R2,R4
   \       0xCC   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \       0xCE   0x1E92             SUBS     R2,R2,#+2
   \       0xD0   0x2AFE             CMP      R2,#+254
   \       0xD2   0xD301             BCC.N    ??I2S_Init_9
    464            {
    465              /* Set the default values */
    466              i2sdiv = 2;
   \       0xD4   0x2402             MOVS     R4,#+2
    467              i2sodd = 0;
   \       0xD6   0x2500             MOVS     R5,#+0
    468            }
    469          
    470            /* Write to SPIx I2SPR register the computed value */
    471            SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
   \                     ??I2S_Init_9: (+1)
   \       0xD8   0x88CA             LDRH     R2,[R1, #+6]
   \       0xDA   0x4315             ORRS     R5,R2,R5
   \       0xDC   0x432C             ORRS     R4,R5,R4
   \       0xDE   0x8404             STRH     R4,[R0, #+32]
    472           
    473            /* Configure the I2S with the SPI_InitStruct values */
    474            tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
    475                            (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
    476                            (uint16_t)I2S_InitStruct->I2S_CPOL))));
   \       0xE0   0x880A             LDRH     R2,[R1, #+0]
   \       0xE2   0x884C             LDRH     R4,[R1, #+2]
   \       0xE4   0x888D             LDRH     R5,[R1, #+4]
   \       0xE6   0x8989             LDRH     R1,[R1, #+12]
   \       0xE8   0x430D             ORRS     R5,R1,R5
   \       0xEA   0x432C             ORRS     R4,R5,R4
   \       0xEC   0x4322             ORRS     R2,R4,R2
   \       0xEE   0xF452 0x6200      ORRS     R2,R2,#0x800
   \       0xF2   0x4313             ORRS     R3,R2,R3
    477           
    478          #if defined(SPI_I2SCFGR_ASTRTEN)
    479            if((I2S_InitStruct->I2S_Standard  == I2S_Standard_PCMShort) || (I2S_InitStruct->I2S_Standard  == I2S_Standard_PCMLong))
    480            {
    481              /* Write to SPIx I2SCFGR */  
    482              SPIx->I2SCFGR = tmpreg | SPI_I2SCFGR_ASTRTEN;
    483            }
    484          #else
    485            /* Write to SPIx I2SCFGR */  
    486            SPIx->I2SCFGR = tmpreg ;
   \       0xF4   0x8383             STRH     R3,[R0, #+28]
    487          #endif 
    488          }
   \       0xF6   0xBCF0             POP      {R4-R7}
   \       0xF8   0x4770             BX       LR               ;; return
    489          
    490          /**
    491            * @brief  Fills each SPI_InitStruct member with its default value.
    492            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure which will be initialized.
    493            * @retval None
    494            */

   \                                 In section .text, align 2, keep-with-next
    495          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    496          {
    497          /*--------------- Reset SPI init structure parameters values -----------------*/
    498            /* Initialize the SPI_Direction member */
    499            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \                     SPI_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x8001             STRH     R1,[R0, #+0]
    500            /* initialize the SPI_Mode member */
    501            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x8041             STRH     R1,[R0, #+2]
    502            /* initialize the SPI_DataSize member */
    503            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x8081             STRH     R1,[R0, #+4]
    504            /* Initialize the SPI_CPOL member */
    505            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x80C1             STRH     R1,[R0, #+6]
    506            /* Initialize the SPI_CPHA member */
    507            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x8101             STRH     R1,[R0, #+8]
    508            /* Initialize the SPI_NSS member */
    509            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x8141             STRH     R1,[R0, #+10]
    510            /* Initialize the SPI_BaudRatePrescaler member */
    511            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x8181             STRH     R1,[R0, #+12]
    512            /* Initialize the SPI_FirstBit member */
    513            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x81C1             STRH     R1,[R0, #+14]
    514            /* Initialize the SPI_CRCPolynomial member */
    515            SPI_InitStruct->SPI_CRCPolynomial = 7;
   \       0x20   0x2107             MOVS     R1,#+7
   \       0x22   0x8201             STRH     R1,[R0, #+16]
    516          }
   \       0x24   0x4770             BX       LR               ;; return
    517          
    518          /**
    519            * @brief  Fills each I2S_InitStruct member with its default value.
    520            * @param  I2S_InitStruct: pointer to a I2S_InitTypeDef structure which will be initialized.
    521            * @retval None
    522            */

   \                                 In section .text, align 2, keep-with-next
    523          void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
    524          {
    525          /*--------------- Reset I2S init structure parameters values -----------------*/
    526            /* Initialize the I2S_Mode member */
    527            I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
   \                     I2S_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x8001             STRH     R1,[R0, #+0]
    528            
    529            /* Initialize the I2S_Standard member */
    530            I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x8041             STRH     R1,[R0, #+2]
    531            
    532            /* Initialize the I2S_DataFormat member */
    533            I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x8081             STRH     R1,[R0, #+4]
    534            
    535            /* Initialize the I2S_MCLKOutput member */
    536            I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x80C1             STRH     R1,[R0, #+6]
    537            
    538            /* Initialize the I2S_AudioFreq member */
    539            I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
   \       0x10   0x2102             MOVS     R1,#+2
   \       0x12   0x6081             STR      R1,[R0, #+8]
    540            
    541            /* Initialize the I2S_CPOL member */
    542            I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x8181             STRH     R1,[R0, #+12]
    543          }
   \       0x18   0x4770             BX       LR               ;; return
    544          
    545          /**
    546            * @brief  Enables or disables the specified SPI peripheral.
    547            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    548            * @param  NewState: new state of the SPIx peripheral. 
    549            *          This parameter can be: ENABLE or DISABLE.
    550            * @retval None
    551            */

   \                                 In section .text, align 2, keep-with-next
    552          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    553          {
    554            /* Check the parameters */
    555            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    556            assert_param(IS_FUNCTIONAL_STATE(NewState));
    557            if (NewState != DISABLE)
   \                     SPI_Cmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??SPI_Cmd_0
    558            {
    559              /* Enable the selected SPI peripheral */
    560              SPIx->CR1 |= SPI_CR1_SPE;
   \        0x6   0x8801             LDRH     R1,[R0, #+0]
   \        0x8   0xF051 0x0140      ORRS     R1,R1,#0x40
   \        0xC   0x8001             STRH     R1,[R0, #+0]
   \        0xE   0xE004             B.N      ??SPI_Cmd_1
    561            }
    562            else
    563            {
    564              /* Disable the selected SPI peripheral */
    565              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
   \                     ??SPI_Cmd_0: (+1)
   \       0x10   0x8802             LDRH     R2,[R0, #+0]
   \       0x12   0xF64F 0x71BF      MOVW     R1,#+65471
   \       0x16   0x400A             ANDS     R2,R1,R2
   \       0x18   0x8002             STRH     R2,[R0, #+0]
    566            }
    567          }
   \                     ??SPI_Cmd_1: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
    568          
    569          /**
    570            * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
    571            * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral (or I2Sxext 
    572            *         for full duplex mode).
    573            * @param  NewState: new state of the SPIx peripheral. 
    574            *         This parameter can be: ENABLE or DISABLE.
    575            * @retval None
    576            */

   \                                 In section .text, align 2, keep-with-next
    577          void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    578          {
    579            /* Check the parameters */
    580            assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
    581            assert_param(IS_FUNCTIONAL_STATE(NewState));
    582            
    583            if (NewState != DISABLE)
   \                     I2S_Cmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??I2S_Cmd_0
    584            {
    585              /* Enable the selected SPI peripheral (in I2S mode) */
    586              SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
   \        0x6   0x8B81             LDRH     R1,[R0, #+28]
   \        0x8   0xF451 0x6180      ORRS     R1,R1,#0x400
   \        0xC   0x8381             STRH     R1,[R0, #+28]
   \        0xE   0xE004             B.N      ??I2S_Cmd_1
    587            }
    588            else
    589            {
    590              /* Disable the selected SPI peripheral in I2S mode */
    591              SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
   \                     ??I2S_Cmd_0: (+1)
   \       0x10   0x8B82             LDRH     R2,[R0, #+28]
   \       0x12   0xF64F 0x31FF      MOVW     R1,#+64511
   \       0x16   0x400A             ANDS     R2,R1,R2
   \       0x18   0x8382             STRH     R2,[R0, #+28]
    592            }
    593          }
   \                     ??I2S_Cmd_1: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
    594          
    595          /**
    596            * @brief  Configures the data size for the selected SPI.
    597            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    598            * @param  SPI_DataSize: specifies the SPI data size.
    599            *          This parameter can be one of the following values:
    600            *            @arg SPI_DataSize_16b: Set data frame format to 16bit
    601            *            @arg SPI_DataSize_8b: Set data frame format to 8bit
    602            * @retval None
    603            */

   \                                 In section .text, align 2, keep-with-next
    604          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
    605          {
    606            /* Check the parameters */
    607            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    608            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
    609            /* Clear DFF bit */
    610            SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
   \                     SPI_DataSizeConfig: (+1)
   \        0x0   0x8803             LDRH     R3,[R0, #+0]
   \        0x2   0xF24F 0x72FF      MOVW     R2,#+63487
   \        0x6   0x4013             ANDS     R3,R2,R3
   \        0x8   0x8003             STRH     R3,[R0, #+0]
    611            /* Set new DFF bit value */
    612            SPIx->CR1 |= SPI_DataSize;
   \        0xA   0x8802             LDRH     R2,[R0, #+0]
   \        0xC   0x4311             ORRS     R1,R1,R2
   \        0xE   0x8001             STRH     R1,[R0, #+0]
    613          }
   \       0x10   0x4770             BX       LR               ;; return
    614          
    615          /**
    616            * @brief  Selects the data transfer direction in bidirectional mode for the specified SPI.
    617            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    618            * @param  SPI_Direction: specifies the data transfer direction in bidirectional mode. 
    619            *          This parameter can be one of the following values:
    620            *            @arg SPI_Direction_Tx: Selects Tx transmission direction
    621            *            @arg SPI_Direction_Rx: Selects Rx receive direction
    622            * @retval None
    623            */

   \                                 In section .text, align 2, keep-with-next
    624          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
    625          {
    626            /* Check the parameters */
    627            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    628            assert_param(IS_SPI_DIRECTION(SPI_Direction));
    629            if (SPI_Direction == SPI_Direction_Tx)
   \                     SPI_BiDirectionalLineConfig: (+1)
   \        0x0   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \        0x2   0xF5B1 0x4F80      CMP      R1,#+16384
   \        0x6   0xD104             BNE.N    ??SPI_BiDirectionalLineConfig_0
    630            {
    631              /* Set the Tx only mode */
    632              SPIx->CR1 |= SPI_Direction_Tx;
   \        0x8   0x8801             LDRH     R1,[R0, #+0]
   \        0xA   0xF451 0x4180      ORRS     R1,R1,#0x4000
   \        0xE   0x8001             STRH     R1,[R0, #+0]
   \       0x10   0xE004             B.N      ??SPI_BiDirectionalLineConfig_1
    633            }
    634            else
    635            {
    636              /* Set the Rx only mode */
    637              SPIx->CR1 &= SPI_Direction_Rx;
   \                     ??SPI_BiDirectionalLineConfig_0: (+1)
   \       0x12   0x8802             LDRH     R2,[R0, #+0]
   \       0x14   0xF64B 0x71FF      MOVW     R1,#+49151
   \       0x18   0x400A             ANDS     R2,R1,R2
   \       0x1A   0x8002             STRH     R2,[R0, #+0]
    638            }
    639          }
   \                     ??SPI_BiDirectionalLineConfig_1: (+1)
   \       0x1C   0x4770             BX       LR               ;; return
    640          
    641          /**
    642            * @brief  Configures internally by software the NSS pin for the selected SPI.
    643            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    644            * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    645            *          This parameter can be one of the following values:
    646            *            @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
    647            *            @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    648            * @retval None
    649            */

   \                                 In section .text, align 2, keep-with-next
    650          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
    651          {
    652            /* Check the parameters */
    653            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    654            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
    655            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
   \                     SPI_NSSInternalSoftwareConfig: (+1)
   \        0x0   0xF64F 0x62FF      MOVW     R2,#+65279
   \        0x4   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \        0x6   0x4291             CMP      R1,R2
   \        0x8   0xD004             BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
    656            {
    657              /* Set NSS pin internally by software */
    658              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
   \        0xA   0x8801             LDRH     R1,[R0, #+0]
   \        0xC   0xF451 0x7180      ORRS     R1,R1,#0x100
   \       0x10   0x8001             STRH     R1,[R0, #+0]
   \       0x12   0xE002             B.N      ??SPI_NSSInternalSoftwareConfig_1
    659            }
    660            else
    661            {
    662              /* Reset NSS pin internally by software */
    663              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
   \                     ??SPI_NSSInternalSoftwareConfig_0: (+1)
   \       0x14   0x8801             LDRH     R1,[R0, #+0]
   \       0x16   0x400A             ANDS     R2,R2,R1
   \       0x18   0x8002             STRH     R2,[R0, #+0]
    664            }
    665          }
   \                     ??SPI_NSSInternalSoftwareConfig_1: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
    666          
    667          /**
    668            * @brief  Enables or disables the SS output for the selected SPI.
    669            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    670            * @param  NewState: new state of the SPIx SS output. 
    671            *          This parameter can be: ENABLE or DISABLE.
    672            * @retval None
    673            */

   \                                 In section .text, align 2, keep-with-next
    674          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    675          {
    676            /* Check the parameters */
    677            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    678            assert_param(IS_FUNCTIONAL_STATE(NewState));
    679            if (NewState != DISABLE)
   \                     SPI_SSOutputCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??SPI_SSOutputCmd_0
    680            {
    681              /* Enable the selected SPI SS output */
    682              SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
   \        0x6   0x8881             LDRH     R1,[R0, #+4]
   \        0x8   0xF051 0x0104      ORRS     R1,R1,#0x4
   \        0xC   0x8081             STRH     R1,[R0, #+4]
   \        0xE   0xE004             B.N      ??SPI_SSOutputCmd_1
    683            }
    684            else
    685            {
    686              /* Disable the selected SPI SS output */
    687              SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
   \                     ??SPI_SSOutputCmd_0: (+1)
   \       0x10   0x8882             LDRH     R2,[R0, #+4]
   \       0x12   0xF64F 0x71FB      MOVW     R1,#+65531
   \       0x16   0x400A             ANDS     R2,R1,R2
   \       0x18   0x8082             STRH     R2,[R0, #+4]
    688            }
    689          }
   \                     ??SPI_SSOutputCmd_1: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
    690          
    691          /**
    692            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
    693            *   
    694            * @note   This function can be called only after the SPI_Init() function has 
    695            *         been called. 
    696            * @note   When TI mode is selected, the control bits SSM, SSI, CPOL and CPHA 
    697            *         are not taken into consideration and are configured by hardware
    698            *         respectively to the TI mode requirements.  
    699            * 
    700            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 
    701            * @param  NewState: new state of the selected SPI TI communication mode.
    702            *          This parameter can be: ENABLE or DISABLE.
    703            * @retval None
    704            */

   \                                 In section .text, align 2, keep-with-next
    705          void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    706          {
    707            /* Check the parameters */
    708            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    709            assert_param(IS_FUNCTIONAL_STATE(NewState));
    710          
    711            if (NewState != DISABLE)
   \                     SPI_TIModeCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??SPI_TIModeCmd_0
    712            {
    713              /* Enable the TI mode for the selected SPI peripheral */
    714              SPIx->CR2 |= SPI_CR2_FRF;
   \        0x6   0x8881             LDRH     R1,[R0, #+4]
   \        0x8   0xF051 0x0110      ORRS     R1,R1,#0x10
   \        0xC   0x8081             STRH     R1,[R0, #+4]
   \        0xE   0xE004             B.N      ??SPI_TIModeCmd_1
    715            }
    716            else
    717            {
    718              /* Disable the TI mode for the selected SPI peripheral */
    719              SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
   \                     ??SPI_TIModeCmd_0: (+1)
   \       0x10   0x8882             LDRH     R2,[R0, #+4]
   \       0x12   0xF64F 0x71EF      MOVW     R1,#+65519
   \       0x16   0x400A             ANDS     R2,R1,R2
   \       0x18   0x8082             STRH     R2,[R0, #+4]
    720            }
    721          }
   \                     ??SPI_TIModeCmd_1: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
    722          
    723          /**
    724            * @brief  Configures the full duplex mode for the I2Sx peripheral using its
    725            *         extension I2Sxext according to the specified parameters in the 
    726            *         I2S_InitStruct.
    727            * @param  I2Sxext: where x can be  2 or 3 to select the I2S peripheral extension block.
    728            * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    729            *         contains the configuration information for the specified I2S peripheral
    730            *         extension.
    731            * 
    732            * @note   The structure pointed by I2S_InitStruct parameter should be the same
    733            *         used for the master I2S peripheral. In this case, if the master is 
    734            *         configured as transmitter, the slave will be receiver and vice versa.
    735            *         Or you can force a different mode by modifying the field I2S_Mode to the
    736            *         value I2S_SlaveRx or I2S_SlaveTx independently of the master configuration.    
    737            *         
    738            * @note   The I2S full duplex extension can be configured in slave mode only.    
    739            *  
    740            * @retval None
    741            */

   \                                 In section .text, align 2, keep-with-next
    742          void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
    743          {
   \                     I2S_FullDuplexConfig: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    744            uint16_t tmpreg = 0, tmp = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2400             MOVS     R4,#+0
    745            
    746            /* Check the I2S parameters */
    747            assert_param(IS_I2S_EXT_PERIPH(I2Sxext));
    748            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
    749            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
    750            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
    751            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
    752          
    753          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    754            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    755            I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
   \        0x6   0x8B83             LDRH     R3,[R0, #+28]
   \        0x8   0xF24F 0x0240      MOVW     R2,#+61504
   \        0xC   0x4013             ANDS     R3,R2,R3
   \        0xE   0x8383             STRH     R3,[R0, #+28]
    756            I2Sxext->I2SPR = 0x0002;
   \       0x10   0x2202             MOVS     R2,#+2
   \       0x12   0x8402             STRH     R2,[R0, #+32]
    757            
    758            /* Get the I2SCFGR register value */
    759            tmpreg = I2Sxext->I2SCFGR;
   \       0x14   0x8B83             LDRH     R3,[R0, #+28]
    760            
    761            /* Get the mode to be configured for the extended I2S */
    762            if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
   \       0x16   0x880A             LDRH     R2,[R1, #+0]
   \       0x18   0xF5B2 0x7F00      CMP      R2,#+512
   \       0x1C   0xD002             BEQ.N    ??I2S_FullDuplexConfig_0
   \       0x1E   0x880A             LDRH     R2,[R1, #+0]
   \       0x20   0x2A00             CMP      R2,#+0
   \       0x22   0xD102             BNE.N    ??I2S_FullDuplexConfig_1
    763            {
    764              tmp = I2S_Mode_SlaveRx;
   \                     ??I2S_FullDuplexConfig_0: (+1)
   \       0x24   0xF44F 0x7480      MOV      R4,#+256
   \       0x28   0xE008             B.N      ??I2S_FullDuplexConfig_2
    765            }
    766            else
    767            {
    768              if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
   \                     ??I2S_FullDuplexConfig_1: (+1)
   \       0x2A   0x880A             LDRH     R2,[R1, #+0]
   \       0x2C   0xF5B2 0x7F40      CMP      R2,#+768
   \       0x30   0xD003             BEQ.N    ??I2S_FullDuplexConfig_3
   \       0x32   0x880A             LDRH     R2,[R1, #+0]
   \       0x34   0xF5B2 0x7F80      CMP      R2,#+256
   \       0x38   0xD100             BNE.N    ??I2S_FullDuplexConfig_2
    769              {
    770                tmp = I2S_Mode_SlaveTx;
   \                     ??I2S_FullDuplexConfig_3: (+1)
   \       0x3A   0x2400             MOVS     R4,#+0
    771              }
    772            }
    773          
    774           
    775            /* Configure the I2S with the SPI_InitStruct values */
    776            tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
    777                            (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
    778                            (uint16_t)I2S_InitStruct->I2S_CPOL))));
   \                     ??I2S_FullDuplexConfig_2: (+1)
   \       0x3C   0x884A             LDRH     R2,[R1, #+2]
   \       0x3E   0x888D             LDRH     R5,[R1, #+4]
   \       0x40   0x8989             LDRH     R1,[R1, #+12]
   \       0x42   0x430D             ORRS     R5,R1,R5
   \       0x44   0x432A             ORRS     R2,R5,R2
   \       0x46   0x4314             ORRS     R4,R2,R4
   \       0x48   0xF454 0x6400      ORRS     R4,R4,#0x800
   \       0x4C   0x4323             ORRS     R3,R4,R3
    779           
    780            /* Write to SPIx I2SCFGR */  
    781            I2Sxext->I2SCFGR = tmpreg;
   \       0x4E   0x8383             STRH     R3,[R0, #+28]
    782          }
   \       0x50   0xBC30             POP      {R4,R5}
   \       0x52   0x4770             BX       LR               ;; return
    783          
    784          /**
    785            * @}
    786            */
    787          
    788          /** @defgroup SPI_Group2 Data transfers functions
    789           *  @brief   Data transfers functions
    790           *
    791          @verbatim   
    792           ===============================================================================
    793                                ##### Data transfers functions #####
    794           ===============================================================================  
    795          
    796           [..] This section provides a set of functions allowing to manage the SPI data 
    797                transfers. In reception, data are received and then stored into an internal 
    798                Rx buffer while. In transmission, data are first stored into an internal Tx 
    799                buffer before being transmitted.
    800          
    801           [..] The read access of the SPI_DR register can be done using the SPI_I2S_ReceiveData()
    802                function and returns the Rx buffered value. Whereas a write access to the SPI_DR 
    803                can be done using SPI_I2S_SendData() function and stores the written data into 
    804                Tx buffer.
    805          
    806          @endverbatim
    807            * @{
    808            */
    809          
    810          /**
    811            * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral. 
    812            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
    813            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
    814            * @retval The value of the received data.
    815            */

   \                                 In section .text, align 2, keep-with-next
    816          uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    817          {
    818            /* Check the parameters */
    819            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
    820            
    821            /* Return the data in the DR register */
    822            return SPIx->DR;
   \                     SPI_I2S_ReceiveData: (+1)
   \        0x0   0x8980             LDRH     R0,[R0, #+12]
   \        0x2   0x4770             BX       LR               ;; return
    823          }
    824          
    825          /**
    826            * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
    827            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
    828            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.     
    829            * @param  Data: Data to be transmitted.
    830            * @retval None
    831            */

   \                                 In section .text, align 2, keep-with-next
    832          void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
    833          {
    834            /* Check the parameters */
    835            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
    836            
    837            /* Write in the DR register the data to be sent */
    838            SPIx->DR = Data;
   \                     SPI_I2S_SendData: (+1)
   \        0x0   0x8181             STRH     R1,[R0, #+12]
    839          }
   \        0x2   0x4770             BX       LR               ;; return
    840          
    841          /**
    842            * @}
    843            */
    844          
    845          /** @defgroup SPI_Group3 Hardware CRC Calculation functions
    846           *  @brief   Hardware CRC Calculation functions
    847           *
    848          @verbatim   
    849           ===============================================================================
    850                           ##### Hardware CRC Calculation functions #####
    851           ===============================================================================  
    852          
    853           [..] This section provides a set of functions allowing to manage the SPI CRC hardware 
    854                calculation
    855          
    856           [..] SPI communication using CRC is possible through the following procedure:
    857             (#) Program the Data direction, Polarity, Phase, First Data, Baud Rate Prescaler, 
    858                 Slave Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
    859                 function.
    860             (#) Enable the CRC calculation using the SPI_CalculateCRC() function.
    861             (#) Enable the SPI using the SPI_Cmd() function
    862             (#) Before writing the last data to the TX buffer, set the CRCNext bit using the 
    863                 SPI_TransmitCRC() function to indicate that after transmission of the last 
    864                 data, the CRC should be transmitted.
    865             (#) After transmitting the last data, the SPI transmits the CRC. The SPI_CR1_CRCNEXT
    866                  bit is reset. The CRC is also received and compared against the SPI_RXCRCR 
    867                  value. 
    868                  If the value does not match, the SPI_FLAG_CRCERR flag is set and an interrupt
    869                  can be generated when the SPI_I2S_IT_ERR interrupt is enabled.
    870          
    871           [..]
    872             (@) It is advised not to read the calculated CRC values during the communication.
    873          
    874             (@) When the SPI is in slave mode, be careful to enable CRC calculation only 
    875                 when the clock is stable, that is, when the clock is in the steady state. 
    876                 If not, a wrong CRC calculation may be done. In fact, the CRC is sensitive 
    877                 to the SCK slave input clock as soon as CRCEN is set, and this, whatever 
    878                 the value of the SPE bit.
    879          
    880             (@) With high bitrate frequencies, be careful when transmitting the CRC.
    881                 As the number of used CPU cycles has to be as low as possible in the CRC 
    882                 transfer phase, it is forbidden to call software functions in the CRC 
    883                 transmission sequence to avoid errors in the last data and CRC reception. 
    884                 In fact, CRCNEXT bit has to be written before the end of the transmission/reception 
    885                 of the last data.
    886          
    887             (@) For high bit rate frequencies, it is advised to use the DMA mode to avoid the
    888                 degradation of the SPI speed performance due to CPU accesses impacting the 
    889                 SPI bandwidth.
    890          
    891             (@) When the STM32F4xx is configured as slave and the NSS hardware mode is 
    892                 used, the NSS pin needs to be kept low between the data phase and the CRC 
    893                 phase.
    894          
    895             (@) When the SPI is configured in slave mode with the CRC feature enabled, CRC
    896                 calculation takes place even if a high level is applied on the NSS pin. 
    897                 This may happen for example in case of a multi-slave environment where the 
    898                 communication master addresses slaves alternately.
    899          
    900             (@) Between a slave de-selection (high level on NSS) and a new slave selection 
    901                 (low level on NSS), the CRC value should be cleared on both master and slave
    902                 sides in order to resynchronize the master and slave for their respective 
    903                 CRC calculation.
    904          
    905             (@) To clear the CRC, follow the procedure below:
    906                 (#@) Disable SPI using the SPI_Cmd() function
    907                 (#@) Disable the CRC calculation using the SPI_CalculateCRC() function.
    908                 (#@) Enable the CRC calculation using the SPI_CalculateCRC() function.
    909                 (#@) Enable SPI using the SPI_Cmd() function.
    910          
    911          @endverbatim
    912            * @{
    913            */
    914          
    915          /**
    916            * @brief  Enables or disables the CRC value calculation of the transferred bytes.
    917            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    918            * @param  NewState: new state of the SPIx CRC value calculation.
    919            *          This parameter can be: ENABLE or DISABLE.
    920            * @retval None
    921            */

   \                                 In section .text, align 2, keep-with-next
    922          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    923          {
    924            /* Check the parameters */
    925            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    926            assert_param(IS_FUNCTIONAL_STATE(NewState));
    927            if (NewState != DISABLE)
   \                     SPI_CalculateCRC: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??SPI_CalculateCRC_0
    928            {
    929              /* Enable the selected SPI CRC calculation */
    930              SPIx->CR1 |= SPI_CR1_CRCEN;
   \        0x6   0x8801             LDRH     R1,[R0, #+0]
   \        0x8   0xF451 0x5100      ORRS     R1,R1,#0x2000
   \        0xC   0x8001             STRH     R1,[R0, #+0]
   \        0xE   0xE004             B.N      ??SPI_CalculateCRC_1
    931            }
    932            else
    933            {
    934              /* Disable the selected SPI CRC calculation */
    935              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
   \                     ??SPI_CalculateCRC_0: (+1)
   \       0x10   0x8802             LDRH     R2,[R0, #+0]
   \       0x12   0xF64D 0x71FF      MOVW     R1,#+57343
   \       0x16   0x400A             ANDS     R2,R1,R2
   \       0x18   0x8002             STRH     R2,[R0, #+0]
    936            }
    937          }
   \                     ??SPI_CalculateCRC_1: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
    938          
    939          /**
    940            * @brief  Transmit the SPIx CRC value.
    941            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    942            * @retval None
    943            */

   \                                 In section .text, align 2, keep-with-next
    944          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    945          {
    946            /* Check the parameters */
    947            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    948            
    949            /* Enable the selected SPI CRC transmission */
    950            SPIx->CR1 |= SPI_CR1_CRCNEXT;
   \                     SPI_TransmitCRC: (+1)
   \        0x0   0x8801             LDRH     R1,[R0, #+0]
   \        0x2   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \        0x6   0x8001             STRH     R1,[R0, #+0]
    951          }
   \        0x8   0x4770             BX       LR               ;; return
    952          
    953          /**
    954            * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
    955            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    956            * @param  SPI_CRC: specifies the CRC register to be read.
    957            *          This parameter can be one of the following values:
    958            *            @arg SPI_CRC_Tx: Selects Tx CRC register
    959            *            @arg SPI_CRC_Rx: Selects Rx CRC register
    960            * @retval The selected CRC register value..
    961            */

   \                                 In section .text, align 2, keep-with-next
    962          uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
    963          {
    964            uint16_t crcreg = 0;
   \                     SPI_GetCRC: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
    965            /* Check the parameters */
    966            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    967            assert_param(IS_SPI_CRC(SPI_CRC));
    968            if (SPI_CRC != SPI_CRC_Rx)
   \        0x2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD001             BEQ.N    ??SPI_GetCRC_0
    969            {
    970              /* Get the Tx CRC register */
    971              crcreg = SPIx->TXCRCR;
   \        0x8   0x8B00             LDRH     R0,[R0, #+24]
   \        0xA   0xE000             B.N      ??SPI_GetCRC_1
    972            }
    973            else
    974            {
    975              /* Get the Rx CRC register */
    976              crcreg = SPIx->RXCRCR;
   \                     ??SPI_GetCRC_0: (+1)
   \        0xC   0x8A80             LDRH     R0,[R0, #+20]
    977            }
    978            /* Return the selected CRC register */
    979            return crcreg;
   \                     ??SPI_GetCRC_1: (+1)
   \        0xE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x10   0x4770             BX       LR               ;; return
    980          }
    981          
    982          /**
    983            * @brief  Returns the CRC Polynomial register value for the specified SPI.
    984            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    985            * @retval The CRC Polynomial register value.
    986            */

   \                                 In section .text, align 2, keep-with-next
    987          uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    988          {
    989            /* Check the parameters */
    990            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    991            
    992            /* Return the CRC polynomial register */
    993            return SPIx->CRCPR;
   \                     SPI_GetCRCPolynomial: (+1)
   \        0x0   0x8A00             LDRH     R0,[R0, #+16]
   \        0x2   0x4770             BX       LR               ;; return
    994          }
    995          
    996          /**
    997            * @}
    998            */
    999          
   1000          /** @defgroup SPI_Group4 DMA transfers management functions
   1001           *  @brief   DMA transfers management functions
   1002            *
   1003          @verbatim   
   1004           ===============================================================================
   1005                             ##### DMA transfers management functions #####
   1006           ===============================================================================  
   1007          
   1008          @endverbatim
   1009            * @{
   1010            */
   1011          
   1012          /**
   1013            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
   1014            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
   1015            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1016            * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
   1017            *          This parameter can be any combination of the following values:
   1018            *            @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
   1019            *            @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
   1020            * @param  NewState: new state of the selected SPI DMA transfer request.
   1021            *          This parameter can be: ENABLE or DISABLE.
   1022            * @retval None
   1023            */

   \                                 In section .text, align 2, keep-with-next
   1024          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
   1025          {
   1026            /* Check the parameters */
   1027            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1028            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1029            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
   1030          
   1031            if (NewState != DISABLE)
   \                     SPI_I2S_DMACmd: (+1)
   \        0x0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD003             BEQ.N    ??SPI_I2S_DMACmd_0
   1032            {
   1033              /* Enable the selected SPI DMA requests */
   1034              SPIx->CR2 |= SPI_I2S_DMAReq;
   \        0x6   0x8882             LDRH     R2,[R0, #+4]
   \        0x8   0x4311             ORRS     R1,R1,R2
   \        0xA   0x8081             STRH     R1,[R0, #+4]
   \        0xC   0xE003             B.N      ??SPI_I2S_DMACmd_1
   1035            }
   1036            else
   1037            {
   1038              /* Disable the selected SPI DMA requests */
   1039              SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
   \                     ??SPI_I2S_DMACmd_0: (+1)
   \        0xE   0x8882             LDRH     R2,[R0, #+4]
   \       0x10   0xEA32 0x0101      BICS     R1,R2,R1
   \       0x14   0x8081             STRH     R1,[R0, #+4]
   1040            }
   1041          }
   \                     ??SPI_I2S_DMACmd_1: (+1)
   \       0x16   0x4770             BX       LR               ;; return
   1042          
   1043          /**
   1044            * @}
   1045            */
   1046          
   1047          /** @defgroup SPI_Group5 Interrupts and flags management functions
   1048           *  @brief   Interrupts and flags management functions
   1049            *
   1050          @verbatim   
   1051           ===============================================================================
   1052                      ##### Interrupts and flags management functions #####
   1053           ===============================================================================  
   1054           
   1055           [..] This section provides a set of functions allowing to configure the SPI Interrupts 
   1056                sources and check or clear the flags or pending bits status.
   1057                The user should identify which mode will be used in his application to manage 
   1058                the communication: Polling mode, Interrupt mode or DMA mode. 
   1059              
   1060           *** Polling Mode ***
   1061           ====================
   1062          [..] In Polling Mode, the SPI/I2S communication can be managed by 9 flags:
   1063            (#) SPI_I2S_FLAG_TXE : to indicate the status of the transmit buffer register
   1064            (#) SPI_I2S_FLAG_RXNE : to indicate the status of the receive buffer register
   1065            (#) SPI_I2S_FLAG_BSY : to indicate the state of the communication layer of the SPI.
   1066            (#) SPI_FLAG_CRCERR : to indicate if a CRC Calculation error occur              
   1067            (#) SPI_FLAG_MODF : to indicate if a Mode Fault error occur
   1068            (#) SPI_I2S_FLAG_OVR : to indicate if an Overrun error occur
   1069            (#) I2S_FLAG_TIFRFE: to indicate a Frame Format error occurs.
   1070            (#) I2S_FLAG_UDR: to indicate an Underrun error occurs.
   1071            (#) I2S_FLAG_CHSIDE: to indicate Channel Side.
   1072          
   1073            (@) Do not use the BSY flag to handle each data transmission or reception. It is
   1074                better to use the TXE and RXNE flags instead.
   1075          
   1076           [..] In this Mode it is advised to use the following functions:
   1077             (+) FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
   1078             (+) void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
   1079          
   1080           *** Interrupt Mode ***
   1081           ======================
   1082           [..] In Interrupt Mode, the SPI communication can be managed by 3 interrupt sources
   1083                and 7 pending bits: 
   1084             (+) Pending Bits:
   1085                 (##) SPI_I2S_IT_TXE : to indicate the status of the transmit buffer register
   1086                 (##) SPI_I2S_IT_RXNE : to indicate the status of the receive buffer register
   1087                 (##) SPI_IT_CRCERR : to indicate if a CRC Calculation error occur (available in SPI mode only)            
   1088                 (##) SPI_IT_MODF : to indicate if a Mode Fault error occur (available in SPI mode only)
   1089                 (##) SPI_I2S_IT_OVR : to indicate if an Overrun error occur
   1090                 (##) I2S_IT_UDR : to indicate an Underrun Error occurs (available in I2S mode only).
   1091                 (##) I2S_FLAG_TIFRFE : to indicate a Frame Format error occurs (available in TI mode only).
   1092          
   1093             (+) Interrupt Source:
   1094                 (##) SPI_I2S_IT_TXE: specifies the interrupt source for the Tx buffer empty 
   1095                      interrupt.  
   1096                 (##) SPI_I2S_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1097                      empty interrupt.
   1098                 (##) SPI_I2S_IT_ERR : specifies the interrupt source for the errors interrupt.
   1099          
   1100           [..] In this Mode it is advised to use the following functions:
   1101             (+) void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
   1102             (+) ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
   1103             (+) void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
   1104          
   1105           *** DMA Mode ***
   1106           ================
   1107           [..] In DMA Mode, the SPI communication can be managed by 2 DMA Channel requests:
   1108             (#) SPI_I2S_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   1109             (#) SPI_I2S_DMAReq_Rx: specifies the Rx buffer DMA transfer request
   1110          
   1111           [..] In this Mode it is advised to use the following function:
   1112             (+) void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState 
   1113                 NewState);
   1114          
   1115          @endverbatim
   1116            * @{
   1117            */
   1118          
   1119          /**
   1120            * @brief  Enables or disables the specified SPI/I2S interrupts.
   1121            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
   1122            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1123            * @param  SPI_I2S_IT: specifies the SPI interrupt source to be enabled or disabled. 
   1124            *          This parameter can be one of the following values:
   1125            *            @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
   1126            *            @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
   1127            *            @arg SPI_I2S_IT_ERR: Error interrupt mask
   1128            * @param  NewState: new state of the specified SPI interrupt.
   1129            *          This parameter can be: ENABLE or DISABLE.
   1130            * @retval None
   1131            */

   \                                 In section .text, align 2, keep-with-next
   1132          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
   1133          {
   1134            uint16_t itpos = 0, itmask = 0 ;
   \                     SPI_I2S_ITConfig: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x2300             MOVS     R3,#+0
   1135            
   1136            /* Check the parameters */
   1137            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1138            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1139            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
   1140          
   1141            /* Get the SPI IT index */
   1142            itpos = SPI_I2S_IT >> 4;
   \        0x4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x6   0x0909             LSRS     R1,R1,#+4
   \        0x8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   1143          
   1144            /* Set the IT mask */
   1145            itmask = (uint16_t)1 << (uint16_t)itpos;
   \        0xA   0x2301             MOVS     R3,#+1
   \        0xC   0xFA13 0xF101      LSLS     R1,R3,R1
   1146          
   1147            if (NewState != DISABLE)
   \       0x10   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x12   0x2A00             CMP      R2,#+0
   \       0x14   0xD003             BEQ.N    ??SPI_I2S_ITConfig_0
   1148            {
   1149              /* Enable the selected SPI interrupt */
   1150              SPIx->CR2 |= itmask;
   \       0x16   0x8882             LDRH     R2,[R0, #+4]
   \       0x18   0x4311             ORRS     R1,R1,R2
   \       0x1A   0x8081             STRH     R1,[R0, #+4]
   \       0x1C   0xE003             B.N      ??SPI_I2S_ITConfig_1
   1151            }
   1152            else
   1153            {
   1154              /* Disable the selected SPI interrupt */
   1155              SPIx->CR2 &= (uint16_t)~itmask;
   \                     ??SPI_I2S_ITConfig_0: (+1)
   \       0x1E   0x8882             LDRH     R2,[R0, #+4]
   \       0x20   0xEA32 0x0101      BICS     R1,R2,R1
   \       0x24   0x8081             STRH     R1,[R0, #+4]
   1156            }
   1157          }
   \                     ??SPI_I2S_ITConfig_1: (+1)
   \       0x26   0x4770             BX       LR               ;; return
   1158          
   1159          /**
   1160            * @brief  Checks whether the specified SPIx/I2Sx flag is set or not.
   1161            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
   1162            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1163            * @param  SPI_I2S_FLAG: specifies the SPI flag to check. 
   1164            *          This parameter can be one of the following values:
   1165            *            @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
   1166            *            @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
   1167            *            @arg SPI_I2S_FLAG_BSY: Busy flag.
   1168            *            @arg SPI_I2S_FLAG_OVR: Overrun flag.
   1169            *            @arg SPI_FLAG_MODF: Mode Fault flag.
   1170            *            @arg SPI_FLAG_CRCERR: CRC Error flag.
   1171            *            @arg SPI_I2S_FLAG_TIFRFE: Format Error.
   1172            *            @arg I2S_FLAG_UDR: Underrun Error flag.
   1173            *            @arg I2S_FLAG_CHSIDE: Channel Side flag.  
   1174            * @retval The new state of SPI_I2S_FLAG (SET or RESET).
   1175            */

   \                                 In section .text, align 2, keep-with-next
   1176          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1177          {
   1178            FlagStatus bitstatus = RESET;
   \                     SPI_I2S_GetFlagStatus: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1179            /* Check the parameters */
   1180            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1181            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
   1182            
   1183            /* Check the status of the specified SPI flag */
   1184            if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
   \        0x2   0x8900             LDRH     R0,[R0, #+8]
   \        0x4   0x4208             TST      R0,R1
   \        0x6   0xD001             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   1185            {
   1186              /* SPI_I2S_FLAG is set */
   1187              bitstatus = SET;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE000             B.N      ??SPI_I2S_GetFlagStatus_1
   1188            }
   1189            else
   1190            {
   1191              /* SPI_I2S_FLAG is reset */
   1192              bitstatus = RESET;
   \                     ??SPI_I2S_GetFlagStatus_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   1193            }
   1194            /* Return the SPI_I2S_FLAG status */
   1195            return  bitstatus;
   \                     ??SPI_I2S_GetFlagStatus_1: (+1)
   \        0xE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x10   0x4770             BX       LR               ;; return
   1196          }
   1197          
   1198          /**
   1199            * @brief  Clears the SPIx CRC Error (CRCERR) flag.
   1200            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
   1201            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1202            * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. 
   1203            *          This function clears only CRCERR flag.
   1204            *            @arg SPI_FLAG_CRCERR: CRC Error flag.  
   1205            *  
   1206            * @note   OVR (OverRun error) flag is cleared by software sequence: a read 
   1207            *          operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by a read 
   1208            *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
   1209            * @note   UDR (UnderRun error) flag is cleared by a read operation to 
   1210            *          SPI_SR register (SPI_I2S_GetFlagStatus()).   
   1211            * @note   MODF (Mode Fault) flag is cleared by software sequence: a read/write 
   1212            *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by a 
   1213            *          write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
   1214            *  
   1215            * @retval None
   1216            */

   \                                 In section .text, align 2, keep-with-next
   1217          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1218          {
   1219            /* Check the parameters */
   1220            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1221            assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
   1222              
   1223            /* Clear the selected SPI CRC Error (CRCERR) flag */
   1224            SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
   \                     SPI_I2S_ClearFlag: (+1)
   \        0x0   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \        0x2   0x43C9             MVNS     R1,R1
   \        0x4   0x8101             STRH     R1,[R0, #+8]
   1225          }
   \        0x6   0x4770             BX       LR               ;; return
   1226          
   1227          /**
   1228            * @brief  Checks whether the specified SPIx/I2Sx interrupt has occurred or not.
   1229            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
   1230            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.  
   1231            * @param  SPI_I2S_IT: specifies the SPI interrupt source to check. 
   1232            *          This parameter can be one of the following values:
   1233            *            @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
   1234            *            @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
   1235            *            @arg SPI_I2S_IT_OVR: Overrun interrupt.
   1236            *            @arg SPI_IT_MODF: Mode Fault interrupt.
   1237            *            @arg SPI_IT_CRCERR: CRC Error interrupt.
   1238            *            @arg I2S_IT_UDR: Underrun interrupt.  
   1239            *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
   1240            * @retval The new state of SPI_I2S_IT (SET or RESET).
   1241            */

   \                                 In section .text, align 2, keep-with-next
   1242          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
   1243          {
   \                     SPI_I2S_GetITStatus: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1244            ITStatus bitstatus = RESET;
   \        0x2   0x2200             MOVS     R2,#+0
   1245            uint16_t itpos = 0, itmask = 0, enablestatus = 0;
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x2200             MOVS     R2,#+0
   1246          
   1247            /* Check the parameters */
   1248            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1249            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
   1250          
   1251            /* Get the SPI_I2S_IT index */
   1252            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   \        0xA   0x2301             MOVS     R3,#+1
   \        0xC   0x001C             MOVS     R4,R3
   \        0xE   0xF011 0x020F      ANDS     R2,R1,#0xF
   \       0x12   0xFA14 0xF202      LSLS     R2,R4,R2
   1253          
   1254            /* Get the SPI_I2S_IT IT mask */
   1255            itmask = SPI_I2S_IT >> 4;
   \       0x16   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x18   0x0909             LSRS     R1,R1,#+4
   \       0x1A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   1256          
   1257            /* Set the IT mask */
   1258            itmask = 0x01 << itmask;
   \       0x1C   0xFA13 0xF101      LSLS     R1,R3,R1
   1259          
   1260            /* Get the SPI_I2S_IT enable bit status */
   1261            enablestatus = (SPIx->CR2 & itmask) ;
   \       0x20   0x8883             LDRH     R3,[R0, #+4]
   \       0x22   0x4019             ANDS     R1,R1,R3
   1262          
   1263            /* Check the status of the specified SPI interrupt */
   1264            if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
   \       0x24   0x8900             LDRH     R0,[R0, #+8]
   \       0x26   0x4210             TST      R0,R2
   \       0x28   0xD004             BEQ.N    ??SPI_I2S_GetITStatus_0
   \       0x2A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \       0x2C   0x2900             CMP      R1,#+0
   \       0x2E   0xD001             BEQ.N    ??SPI_I2S_GetITStatus_0
   1265            {
   1266              /* SPI_I2S_IT is set */
   1267              bitstatus = SET;
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0xE000             B.N      ??SPI_I2S_GetITStatus_1
   1268            }
   1269            else
   1270            {
   1271              /* SPI_I2S_IT is reset */
   1272              bitstatus = RESET;
   \                     ??SPI_I2S_GetITStatus_0: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   1273            }
   1274            /* Return the SPI_I2S_IT status */
   1275            return bitstatus;
   \                     ??SPI_I2S_GetITStatus_1: (+1)
   \       0x36   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x38   0xBC10             POP      {R4}
   \       0x3A   0x4770             BX       LR               ;; return
   1276          }
   1277          
   1278          /**
   1279            * @brief  Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
   1280            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
   1281            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.  
   1282            * @param  SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
   1283            *         This function clears only CRCERR interrupt pending bit.   
   1284            *            @arg SPI_IT_CRCERR: CRC Error interrupt.
   1285            *   
   1286            * @note   OVR (OverRun Error) interrupt pending bit is cleared by software 
   1287            *          sequence: a read operation to SPI_DR register (SPI_I2S_ReceiveData()) 
   1288            *          followed by a read operation to SPI_SR register (SPI_I2S_GetITStatus()).
   1289            * @note   UDR (UnderRun Error) interrupt pending bit is cleared by a read 
   1290            *          operation to SPI_SR register (SPI_I2S_GetITStatus()).   
   1291            * @note   MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
   1292            *          a read/write operation to SPI_SR register (SPI_I2S_GetITStatus()) 
   1293            *          followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable 
   1294            *          the SPI).
   1295            * @retval None
   1296            */

   \                                 In section .text, align 2, keep-with-next
   1297          void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
   1298          {
   1299            uint16_t itpos = 0;
   \                     SPI_I2S_ClearITPendingBit: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1300            /* Check the parameters */
   1301            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   1302            assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
   1303          
   1304            /* Get the SPI_I2S IT index */
   1305            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0xF011 0x010F      ANDS     R1,R1,#0xF
   \        0x8   0xFA12 0xF101      LSLS     R1,R2,R1
   1306          
   1307            /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
   1308            SPIx->SR = (uint16_t)~itpos;
   \        0xC   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \        0xE   0x43C9             MVNS     R1,R1
   \       0x10   0x8101             STRH     R1,[R0, #+8]
   1309          }
   \       0x12   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x4001'3000        DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x4000'3800        DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0x4000'3C00        DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x4001'3400        DC32     0x40013400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \        0x0   0x4001'5000        DC32     0x40015000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \        0x0   0x4001'5400        DC32     0x40015400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \        0x0   0x4002'3808        DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \        0x0   0x4002'3884        DC32     0x40023884

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_8:
   \        0x0   0x4002'3804        DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_9:
   \        0x0   0x007A'1200        DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_10:
   \        0x0   0x00F4'2400        DC32     0xf42400
   1310          
   1311          /**
   1312            * @}
   1313            */
   1314          
   1315          /**
   1316            * @}
   1317            */ 
   1318          
   1319          /**
   1320            * @}
   1321            */ 
   1322          
   1323          /**
   1324            * @}
   1325            */ 
   1326          
   1327          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   I2S_Cmd
       8   I2S_FullDuplexConfig
      16   I2S_Init
       0   I2S_StructInit
       0   SPI_BiDirectionalLineConfig
       0   SPI_CalculateCRC
       0   SPI_Cmd
       0   SPI_DataSizeConfig
       0   SPI_GetCRC
       0   SPI_GetCRCPolynomial
       0   SPI_I2S_ClearFlag
       0   SPI_I2S_ClearITPendingBit
       0   SPI_I2S_DMACmd
       8   SPI_I2S_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       0   SPI_I2S_GetFlagStatus
       4   SPI_I2S_GetITStatus
       0   SPI_I2S_ITConfig
       0   SPI_I2S_ReceiveData
       0   SPI_I2S_SendData
       4   SPI_Init
       0   SPI_NSSInternalSoftwareConfig
       0   SPI_SSOutputCmd
       0   SPI_StructInit
       0   SPI_TIModeCmd
       0   SPI_TransmitCRC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
      28  I2S_Cmd
      84  I2S_FullDuplexConfig
     250  I2S_Init
      26  I2S_StructInit
      30  SPI_BiDirectionalLineConfig
      28  SPI_CalculateCRC
      28  SPI_Cmd
      18  SPI_DataSizeConfig
      18  SPI_GetCRC
       4  SPI_GetCRCPolynomial
       8  SPI_I2S_ClearFlag
      20  SPI_I2S_ClearITPendingBit
      24  SPI_I2S_DMACmd
     170  SPI_I2S_DeInit
      18  SPI_I2S_GetFlagStatus
      60  SPI_I2S_GetITStatus
      40  SPI_I2S_ITConfig
       4  SPI_I2S_ReceiveData
       4  SPI_I2S_SendData
      62  SPI_Init
      28  SPI_NSSInternalSoftwareConfig
      28  SPI_SSOutputCmd
      38  SPI_StructInit
      28  SPI_TIModeCmd
      10  SPI_TransmitCRC

 
 1'100 bytes in section .text
 
 1'100 bytes of CODE memory

Errors: none
Warnings: none
