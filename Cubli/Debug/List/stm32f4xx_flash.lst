###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.2.214/W32 for ARM         10/Jul/2020  15:12:07
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c
#    Command line =
#        -f C:\Users\Evan\AppData\Local\Temp\EWE7E1.tmp
#        (E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c
#        -D USE_STDPERIPH_DRIVER -D STM32F429_439xx -lC
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List
#        -o
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "D:\IAR
#        Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\iar\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\User\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\User\src\
#        -Ol --use_c++_inline -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List\stm32f4xx_flash.lst
#    Object file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj\stm32f4xx_flash.o
#
###############################################################################

E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.8.0
      6            * @date    04-November-2016
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the FLASH peripheral:
      9            *            + FLASH Interface configuration
     10            *            + FLASH Memory Programming
     11            *            + Option Bytes Programming
     12            *            + Interrupts and flags management
     13            *  
     14           @verbatim    
     15           ===============================================================================
     16                                  ##### How to use this driver #####
     17           ===============================================================================
     18              [..]                             
     19                This driver provides functions to configure and program the FLASH memory 
     20                of all STM32F4xx devices. These functions are split in 4 groups:
     21             
     22                (#) FLASH Interface configuration functions: this group includes the
     23                    management of the following features:
     24                  (++) Set the latency
     25                  (++) Enable/Disable the prefetch buffer
     26                  (++) Enable/Disable the Instruction cache and the Data cache
     27                  (++) Reset the Instruction cache and the Data cache
     28              
     29                (#) FLASH Memory Programming functions: this group includes all needed
     30                    functions to erase and program the main memory:
     31                  (++) Lock and Unlock the FLASH interface
     32                  (++) Erase function: Erase sector, erase all sectors
     33                  (++) Program functions: byte, half word, word and double word
     34              
     35                (#) Option Bytes Programming functions: this group includes all needed
     36                    functions to manage the Option Bytes:
     37                  (++) Set/Reset the write protection
     38                  (++) Set the Read protection Level
     39                  (++) Set the BOR level
     40                  (++) Program the user Option Bytes
     41                  (++) Launch the Option Bytes loader
     42              
     43                (#) Interrupts and flags management functions: this group 
     44                    includes all needed functions to:
     45                  (++) Enable/Disable the FLASH interrupt sources
     46                  (++) Get flags status
     47                  (++) Clear flags
     48                  (++) Get FLASH operation status
     49                  (++) Wait for last FLASH operation   
     50           @endverbatim
     51            ******************************************************************************
     52            * @attention
     53            *
     54            * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
     55            *
     56            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     57            * You may not use this file except in compliance with the License.
     58            * You may obtain a copy of the License at:
     59            *
     60            *        http://www.st.com/software_license_agreement_liberty_v2
     61            *
     62            * Unless required by applicable law or agreed to in writing, software 
     63            * distributed under the License is distributed on an "AS IS" BASIS, 
     64            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     65            * See the License for the specific language governing permissions and
     66            * limitations under the License.
     67            *
     68            ******************************************************************************
     69            */
     70          
     71          /* Includes ------------------------------------------------------------------*/
     72          #include "stm32f4xx_flash.h"
     73          
     74          /** @addtogroup STM32F4xx_StdPeriph_Driver
     75            * @{
     76            */
     77          
     78          /** @defgroup FLASH 
     79            * @brief FLASH driver modules
     80            * @{
     81            */ 
     82          
     83          /* Private typedef -----------------------------------------------------------*/
     84          /* Private define ------------------------------------------------------------*/ 
     85          #define SECTOR_MASK               ((uint32_t)0xFFFFFF07)
     86          
     87          /* Private macro -------------------------------------------------------------*/
     88          /* Private variables ---------------------------------------------------------*/
     89          /* Private function prototypes -----------------------------------------------*/
     90          /* Private functions ---------------------------------------------------------*/
     91          
     92          /** @defgroup FLASH_Private_Functions
     93            * @{
     94            */ 
     95          
     96          /** @defgroup FLASH_Group1 FLASH Interface configuration functions
     97            *  @brief   FLASH Interface configuration functions 
     98           *
     99          
    100          @verbatim   
    101           ===============================================================================
    102                        ##### FLASH Interface configuration functions #####
    103           ===============================================================================
    104              [..]
    105                This group includes the following functions:
    106                (+) void FLASH_SetLatency(uint32_t FLASH_Latency)
    107                    To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    108                    must be correctly programmed according to the frequency of the CPU clock 
    109                    (HCLK) and the supply voltage of the device.
    110              [..]      
    111                For STM32F405xx/07xx and STM32F415xx/17xx devices
    112           +-------------------------------------------------------------------------------------+
    113           | Latency       |                HCLK clock frequency (MHz)                           |
    114           |               |---------------------------------------------------------------------|
    115           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    116           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    117           |---------------|----------------|----------------|-----------------|-----------------|
    118           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    119           |---------------|----------------|----------------|-----------------|-----------------|
    120           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  |
    121           |---------------|----------------|----------------|-----------------|-----------------|
    122           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    123           |---------------|----------------|----------------|-----------------|-----------------|
    124           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
    125           |---------------|----------------|----------------|-----------------|-----------------|
    126           |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
    127           |---------------|----------------|----------------|-----------------|-----------------|
    128           |5WS(6CPU cycle)|150< HCLK <= 168|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120|
    129           |---------------|----------------|----------------|-----------------|-----------------|
    130           |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140|
    131           |---------------|----------------|----------------|-----------------|-----------------|
    132           |7WS(8CPU cycle)|      NA        |      NA        |154 < HCLK <= 168|140 < HCLK <= 160|
    133           +---------------|----------------|----------------|-----------------|-----------------+
    134          
    135              [..]      
    136                For STM32F42xxx/43xxx devices
    137           +-------------------------------------------------------------------------------------+
    138           | Latency       |                HCLK clock frequency (MHz)                           |
    139           |               |---------------------------------------------------------------------|
    140           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    141           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    142           |---------------|----------------|----------------|-----------------|-----------------|
    143           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    144           |---------------|----------------|----------------|-----------------|-----------------|
    145           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  |
    146           |---------------|----------------|----------------|-----------------|-----------------|
    147           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    148           |---------------|----------------|----------------|-----------------|-----------------|
    149           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
    150           |---------------|----------------|----------------|-----------------|-----------------|
    151           |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
    152           |---------------|----------------|----------------|-----------------|-----------------|
    153           |5WS(6CPU cycle)|120< HCLK <= 180|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120|
    154           |---------------|----------------|----------------|-----------------|-----------------|
    155           |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140|
    156           |---------------|----------------|----------------|-----------------|-----------------|
    157           |7WS(8CPU cycle)|      NA        |168< HCLK <= 180|154 < HCLK <= 176|140 < HCLK <= 160|
    158           |---------------|----------------|----------------|-----------------|-----------------|
    159           |8WS(9CPU cycle)|      NA        |      NA        |176 < HCLK <= 180|160 < HCLK <= 168|
    160           +-------------------------------------------------------------------------------------+
    161             
    162              [..]
    163              For STM32F401x devices
    164           +-------------------------------------------------------------------------------------+
    165           | Latency       |                HCLK clock frequency (MHz)                           |
    166           |               |---------------------------------------------------------------------|
    167           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    168           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    169           |---------------|----------------|----------------|-----------------|-----------------|
    170           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    171           |---------------|----------------|----------------|-----------------|-----------------|
    172           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  |
    173           |---------------|----------------|----------------|-----------------|-----------------|
    174           |2WS(3CPU cycle)|60 < HCLK <= 84 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    175           |---------------|----------------|----------------|-----------------|-----------------|
    176           |3WS(4CPU cycle)|      NA        |72 < HCLK <= 84 |66 < HCLK <= 84  |60 < HCLK <= 80  |
    177           |---------------|----------------|----------------|-----------------|-----------------|
    178           |4WS(5CPU cycle)|      NA        |      NA        |      NA         |80 < HCLK <= 84  |
    179           +-------------------------------------------------------------------------------------+
    180          
    181              [..]
    182              For STM32F410xx/STM32F411xE devices
    183           +-------------------------------------------------------------------------------------+
    184           | Latency       |                HCLK clock frequency (MHz)                           |
    185           |               |---------------------------------------------------------------------|
    186           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    187           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    188           |---------------|----------------|----------------|-----------------|-----------------|
    189           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 18   |0 < HCLK <= 16   |
    190           |---------------|----------------|----------------|-----------------|-----------------|
    191           |1WS(2CPU cycle)|30 < HCLK <= 64 |24 < HCLK <= 48 |18 < HCLK <= 36  |16 < HCLK <= 32  |
    192           |---------------|----------------|----------------|-----------------|-----------------|
    193           |2WS(3CPU cycle)|64 < HCLK <= 90 |48 < HCLK <= 72 |36 < HCLK <= 54  |32 < HCLK <= 48  |
    194           |---------------|----------------|----------------|-----------------|-----------------|
    195           |3WS(4CPU cycle)|90 < HCLK <= 100|72 < HCLK <= 96 |54 < HCLK <= 72  |48 < HCLK <= 64  |
    196           |---------------|----------------|----------------|-----------------|-----------------|
    197           |4WS(5CPU cycle)|      NA        |96 < HCLK <= 100|72 < HCLK <= 90  |64 < HCLK <= 80  |
    198           |---------------|----------------|----------------|-----------------|-----------------|
    199           |5WS(6CPU cycle)|      NA        |       NA       |90 < HCLK <= 100 |80 < HCLK <= 96  |
    200           |---------------|----------------|----------------|-----------------|-----------------|
    201           |6WS(7CPU cycle)|      NA        |       NA       |        NA       |96 < HCLK <= 100 |
    202           +-------------------------------------------------------------------------------------+
    203           
    204           [..]
    205           +-------------------------------------------------------------------------------------------------------------------+
    206           |               | voltage range  | voltage range  | voltage range   | voltage range   | voltage range 2.7 V - 3.6 V |
    207           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   | with External Vpp = 9V      |
    208           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------|
    209           |Max Parallelism|      x32       |               x16                |       x8        |          x64                |
    210           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------|
    211           |PSIZE[1:0]     |      10        |               01                 |       00        |           11                |
    212           +-------------------------------------------------------------------------------------------------------------------+
    213          
    214                -@- On STM32F405xx/407xx and STM32F415xx/417xx devices: 
    215                     (++) when VOS = '0' Scale 2 mode, the maximum value of fHCLK = 144MHz. 
    216                     (++) when VOS = '1' Scale 1 mode, the maximum value of fHCLK = 168MHz. 
    217                    [..] 
    218                    On STM32F42xxx/43xxx devices:
    219                     (++) when VOS[1:0] = '0x01' Scale 3 mode, the maximum value of fHCLK is 120MHz.
    220                     (++) when VOS[1:0] = '0x10' Scale 2 mode, the maximum value of fHCLK is 144MHz if OverDrive OFF and 168MHz if OverDrive ON.
    221                     (++) when VOS[1:0] = '0x11' Scale 1 mode, the maximum value of fHCLK is 168MHz if OverDrive OFF and 180MHz if OverDrive ON. 
    222                    [..]
    223                    On STM32F401x devices:
    224                     (++) when VOS[1:0] = '0x01' Scale 3 mode, the maximum value of fHCLK is 60MHz.
    225                     (++) when VOS[1:0] = '0x10' Scale 2 mode, the maximum value of fHCLK is 84MHz.
    226                    [..]  
    227                    On STM32F410xx/STM32F411xE devices:
    228                     (++) when VOS[1:0] = '0x01' Scale 3 mode, the maximum value of fHCLK is 64MHz.
    229                     (++) when VOS[1:0] = '0x10' Scale 2 mode, the maximum value of fHCLK is 84MHz.
    230                     (++) when VOS[1:0] = '0x11' Scale 1 mode, the maximum value of fHCLK is 100MHz.
    231          
    232                  For more details please refer product DataSheet 
    233                     You can use PWR_MainRegulatorModeConfig() function to control VOS bits.
    234          
    235                (+) void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    236                (+) void FLASH_InstructionCacheCmd(FunctionalState NewState)
    237                (+) void FLASH_DataCacheCmd(FunctionalState NewState)
    238                (+) void FLASH_InstructionCacheReset(void)
    239                (+) void FLASH_DataCacheReset(void)
    240                
    241              [..]   
    242                The unlock sequence is not needed for these functions.
    243           
    244          @endverbatim
    245            * @{
    246            */
    247           
    248          /**
    249            * @brief  Sets the code latency value.  
    250            * @param  FLASH_Latency: specifies the FLASH Latency value.
    251            *          This parameter can be one of the following values:
    252            *            @arg FLASH_Latency_0: FLASH Zero Latency cycle
    253            *            @arg FLASH_Latency_1: FLASH One Latency cycle
    254            *            @arg FLASH_Latency_2: FLASH Two Latency cycles
    255            *            @arg FLASH_Latency_3: FLASH Three Latency cycles
    256            *            @arg FLASH_Latency_4: FLASH Four Latency cycles 
    257            *            @arg FLASH_Latency_5: FLASH Five Latency cycles 
    258            *            @arg FLASH_Latency_6: FLASH Six Latency cycles
    259            *            @arg FLASH_Latency_7: FLASH Seven Latency cycles 
    260            *            @arg FLASH_Latency_8: FLASH Eight Latency cycles
    261            *            @arg FLASH_Latency_9: FLASH Nine Latency cycles
    262            *            @arg FLASH_Latency_10: FLASH Teen Latency cycles 
    263            *            @arg FLASH_Latency_11: FLASH Eleven Latency cycles 
    264            *            @arg FLASH_Latency_12: FLASH Twelve Latency cycles
    265            *            @arg FLASH_Latency_13: FLASH Thirteen Latency cycles
    266            *            @arg FLASH_Latency_14: FLASH Fourteen Latency cycles
    267            *            @arg FLASH_Latency_15: FLASH Fifteen Latency cycles 
    268            *              
    269            * @note For STM32F405xx/407xx, STM32F415xx/417xx, STM32F401xx/411xE/STM32F412xG and STM32F413_423xx devices
    270            *       this parameter can be a value between FLASH_Latency_0 and FLASH_Latency_7.
    271            *
    272            * @note For STM32F42xxx/43xxx devices this parameter can be a value between 
    273            *       FLASH_Latency_0 and FLASH_Latency_15. 
    274            *         
    275            * @retval None
    276            */

   \                                 In section .text, align 2, keep-with-next
    277          void FLASH_SetLatency(uint32_t FLASH_Latency)
    278          {
    279            /* Check the parameters */
    280            assert_param(IS_FLASH_LATENCY(FLASH_Latency));
    281            
    282            /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
    283            *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
   \                     FLASH_SetLatency: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable38  ;; 0x40023c00
   \        0x4   0x7008             STRB     R0,[R1, #+0]
    284          }
   \        0x6   0x4770             BX       LR               ;; return
    285          
    286          /**
    287            * @brief  Enables or disables the Prefetch Buffer.
    288            * @param  NewState: new state of the Prefetch Buffer.
    289            *          This parameter  can be: ENABLE or DISABLE.
    290            * @retval None
    291            */

   \                                 In section .text, align 2, keep-with-next
    292          void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    293          {
    294            /* Check the parameters */
    295            assert_param(IS_FUNCTIONAL_STATE(NewState));
    296            
    297            /* Enable or disable the Prefetch Buffer */
    298            if(NewState != DISABLE)
   \                     FLASH_PrefetchBufferCmd: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD006             BEQ.N    ??FLASH_PrefetchBufferCmd_0
    299            {
    300              FLASH->ACR |= FLASH_ACR_PRFTEN;
   \        0x6   0x....'....        LDR.W    R0,??DataTable38  ;; 0x40023c00
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF451 0x7180      ORRS     R1,R1,#0x100
   \       0x10   0x6001             STR      R1,[R0, #+0]
   \       0x12   0xE005             B.N      ??FLASH_PrefetchBufferCmd_1
    301            }
    302            else
    303            {
    304              FLASH->ACR &= (~FLASH_ACR_PRFTEN);
   \                     ??FLASH_PrefetchBufferCmd_0: (+1)
   \       0x14   0x....'....        LDR.W    R0,??DataTable38  ;; 0x40023c00
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xF431 0x7180      BICS     R1,R1,#0x100
   \       0x1E   0x6001             STR      R1,[R0, #+0]
    305            }
    306          }
   \                     ??FLASH_PrefetchBufferCmd_1: (+1)
   \       0x20   0x4770             BX       LR               ;; return
    307          
    308          /**
    309            * @brief  Enables or disables the Instruction Cache feature.
    310            * @param  NewState: new state of the Instruction Cache.
    311            *          This parameter  can be: ENABLE or DISABLE.
    312            * @retval None
    313            */

   \                                 In section .text, align 2, keep-with-next
    314          void FLASH_InstructionCacheCmd(FunctionalState NewState)
    315          {
    316            /* Check the parameters */
    317            assert_param(IS_FUNCTIONAL_STATE(NewState));
    318            
    319            if(NewState != DISABLE)
   \                     FLASH_InstructionCacheCmd: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD006             BEQ.N    ??FLASH_InstructionCacheCmd_0
    320            {
    321              FLASH->ACR |= FLASH_ACR_ICEN;
   \        0x6   0x....'....        LDR.W    R0,??DataTable38  ;; 0x40023c00
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF451 0x7100      ORRS     R1,R1,#0x200
   \       0x10   0x6001             STR      R1,[R0, #+0]
   \       0x12   0xE005             B.N      ??FLASH_InstructionCacheCmd_1
    322            }
    323            else
    324            {
    325              FLASH->ACR &= (~FLASH_ACR_ICEN);
   \                     ??FLASH_InstructionCacheCmd_0: (+1)
   \       0x14   0x....'....        LDR.W    R0,??DataTable38  ;; 0x40023c00
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xF431 0x7100      BICS     R1,R1,#0x200
   \       0x1E   0x6001             STR      R1,[R0, #+0]
    326            }
    327          }
   \                     ??FLASH_InstructionCacheCmd_1: (+1)
   \       0x20   0x4770             BX       LR               ;; return
    328          
    329          /**
    330            * @brief  Enables or disables the Data Cache feature.
    331            * @param  NewState: new state of the Data Cache.
    332            *          This parameter  can be: ENABLE or DISABLE.
    333            * @retval None
    334            */

   \                                 In section .text, align 2, keep-with-next
    335          void FLASH_DataCacheCmd(FunctionalState NewState)
    336          {
    337            /* Check the parameters */
    338            assert_param(IS_FUNCTIONAL_STATE(NewState));
    339            
    340            if(NewState != DISABLE)
   \                     FLASH_DataCacheCmd: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD006             BEQ.N    ??FLASH_DataCacheCmd_0
    341            {
    342              FLASH->ACR |= FLASH_ACR_DCEN;
   \        0x6   0x....'....        LDR.W    R0,??DataTable38  ;; 0x40023c00
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF451 0x6180      ORRS     R1,R1,#0x400
   \       0x10   0x6001             STR      R1,[R0, #+0]
   \       0x12   0xE005             B.N      ??FLASH_DataCacheCmd_1
    343            }
    344            else
    345            {
    346              FLASH->ACR &= (~FLASH_ACR_DCEN);
   \                     ??FLASH_DataCacheCmd_0: (+1)
   \       0x14   0x....'....        LDR.W    R0,??DataTable38  ;; 0x40023c00
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xF431 0x6180      BICS     R1,R1,#0x400
   \       0x1E   0x6001             STR      R1,[R0, #+0]
    347            }
    348          }
   \                     ??FLASH_DataCacheCmd_1: (+1)
   \       0x20   0x4770             BX       LR               ;; return
    349          
    350          /**
    351            * @brief  Resets the Instruction Cache.
    352            * @note   This function must be used only when the Instruction Cache is disabled.  
    353            * @param  None
    354            * @retval None
    355            */

   \                                 In section .text, align 2, keep-with-next
    356          void FLASH_InstructionCacheReset(void)
    357          {
    358            FLASH->ACR |= FLASH_ACR_ICRST;
   \                     FLASH_InstructionCacheReset: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable38  ;; 0x40023c00
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF451 0x6100      ORRS     R1,R1,#0x800
   \        0xA   0x6001             STR      R1,[R0, #+0]
    359          }
   \        0xC   0x4770             BX       LR               ;; return
    360          
    361          /**
    362            * @brief  Resets the Data Cache.
    363            * @note   This function must be used only when the Data Cache is disabled.  
    364            * @param  None
    365            * @retval None
    366            */

   \                                 In section .text, align 2, keep-with-next
    367          void FLASH_DataCacheReset(void)
    368          {
    369            FLASH->ACR |= FLASH_ACR_DCRST;
   \                     FLASH_DataCacheReset: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable38  ;; 0x40023c00
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \        0xA   0x6001             STR      R1,[R0, #+0]
    370          }
   \        0xC   0x4770             BX       LR               ;; return
    371          
    372          /**
    373            * @}
    374            */
    375          
    376          /** @defgroup FLASH_Group2 FLASH Memory Programming functions
    377           *  @brief   FLASH Memory Programming functions
    378           *
    379          @verbatim   
    380           ===============================================================================
    381                          ##### FLASH Memory Programming functions #####
    382           ===============================================================================   
    383              [..]
    384                This group includes the following functions:
    385                (+) void FLASH_Unlock(void)
    386                (+) void FLASH_Lock(void)
    387                (+) FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
    388                (+) FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)       
    389                (+) FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    390                (+) FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    391                (+) FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    392                (+) FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    393                    The following functions can be used only for STM32F42xxx/43xxx devices. 
    394                (+) FLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange)
    395                (+) FLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange)    
    396              [..]   
    397                Any operation of erase or program should follow these steps:
    398                (#) Call the FLASH_Unlock() function to enable the FLASH control register access
    399          
    400                (#) Call the desired function to erase sector(s) or program data
    401          
    402                (#) Call the FLASH_Lock() function to disable the FLASH control register access
    403                    (recommended to protect the FLASH memory against possible unwanted operation)
    404              
    405          @endverbatim
    406            * @{
    407            */
    408          
    409          /**
    410            * @brief  Unlocks the FLASH control register access
    411            * @param  None
    412            * @retval None
    413            */

   \                                 In section .text, align 2, keep-with-next
    414          void FLASH_Unlock(void)
    415          {
    416            if((FLASH->CR & FLASH_CR_LOCK) != RESET)
   \                     FLASH_Unlock: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable38_1  ;; 0x40023c10
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD507             BPL.N    ??FLASH_Unlock_0
    417            {
    418              /* Authorize the FLASH Registers access */
    419              FLASH->KEYR = FLASH_KEY1;
   \        0xA   0x....'....        LDR.W    R0,??DataTable38_2  ;; 0x40023c04
   \        0xE   0x....'....        LDR.W    R1,??DataTable38_3  ;; 0x45670123
   \       0x12   0x6001             STR      R1,[R0, #+0]
    420              FLASH->KEYR = FLASH_KEY2;
   \       0x14   0x....'....        LDR.W    R1,??DataTable38_4  ;; 0xcdef89ab
   \       0x18   0x6001             STR      R1,[R0, #+0]
    421            }  
    422          }
   \                     ??FLASH_Unlock_0: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
    423          
    424          /**
    425            * @brief  Locks the FLASH control register access
    426            * @param  None
    427            * @retval None
    428            */

   \                                 In section .text, align 2, keep-with-next
    429          void FLASH_Lock(void)
    430          {
    431            /* Set the LOCK Bit to lock the FLASH Registers access */
    432            FLASH->CR |= FLASH_CR_LOCK;
   \                     FLASH_Lock: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable38_1  ;; 0x40023c10
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF051 0x4100      ORRS     R1,R1,#0x80000000
   \        0xA   0x6001             STR      R1,[R0, #+0]
    433          }
   \        0xC   0x4770             BX       LR               ;; return
    434          
    435          /**
    436            * @brief  Erases a specified FLASH Sector.
    437            *
    438            * @note   If an erase and a program operations are requested simultaneously,    
    439            *         the erase operation is performed before the program one.
    440            *
    441            * @param  FLASH_Sector: The Sector number to be erased.
    442            *
    443            *  @note  For STM32F405xx/407xx and STM32F415xx/417xx devices this parameter can 
    444            *         be a value between FLASH_Sector_0 and FLASH_Sector_11.
    445            *
    446            *         For STM32F42xxx/43xxx devices this parameter can be a value between 
    447            *         FLASH_Sector_0 and FLASH_Sector_23.
    448            *
    449            *         For STM32F401xx devices this parameter can be a value between 
    450            *         FLASH_Sector_0 and FLASH_Sector_5.
    451            *
    452            *         For STM32F411xE and STM32F412xG devices this parameter can be a value between 
    453            *         FLASH_Sector_0 and FLASH_Sector_7.
    454            *
    455            *         For STM32F410xx devices this parameter can be a value between 
    456            *         FLASH_Sector_0 and FLASH_Sector_4.
    457            *
    458            *         For STM32F413_423xx devices this parameter can be a value between 
    459            *         FLASH_Sector_0 and FLASH_Sector_15.
    460            *
    461            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    462            *          This parameter can be one of the following values:
    463            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    464            *                                  the operation will be done by byte (8-bit) 
    465            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    466            *                                  the operation will be done by half word (16-bit)
    467            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    468            *                                  the operation will be done by word (32-bit)
    469            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    470            *                                  the operation will be done by double word (64-bit)
    471            *       
    472            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    473            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    474            */

   \                                 In section .text, align 2, keep-with-next
    475          FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
    476          {
   \                     FLASH_EraseSector: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    477            uint32_t tmp_psize = 0x0;
   \        0x4   0x2000             MOVS     R0,#+0
    478            FLASH_Status status = FLASH_COMPLETE;
   \        0x6   0x2009             MOVS     R0,#+9
    479          
    480            /* Check the parameters */
    481            assert_param(IS_FLASH_SECTOR(FLASH_Sector));
    482            assert_param(IS_VOLTAGERANGE(VoltageRange));
    483            
    484            if(VoltageRange == VoltageRange_1)
   \        0x8   0x0008             MOVS     R0,R1
   \        0xA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD101             BNE.N    ??FLASH_EraseSector_0
    485            {
    486               tmp_psize = FLASH_PSIZE_BYTE;
   \       0x10   0x2600             MOVS     R6,#+0
   \       0x12   0xE00E             B.N      ??FLASH_EraseSector_1
    487            }
    488            else if(VoltageRange == VoltageRange_2)
   \                     ??FLASH_EraseSector_0: (+1)
   \       0x14   0x0008             MOVS     R0,R1
   \       0x16   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD102             BNE.N    ??FLASH_EraseSector_2
    489            {
    490              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \       0x1C   0xF44F 0x7680      MOV      R6,#+256
   \       0x20   0xE007             B.N      ??FLASH_EraseSector_1
    491            }
    492            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseSector_2: (+1)
   \       0x22   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x24   0x2902             CMP      R1,#+2
   \       0x26   0xD102             BNE.N    ??FLASH_EraseSector_3
    493            {
    494              tmp_psize = FLASH_PSIZE_WORD;
   \       0x28   0xF44F 0x7600      MOV      R6,#+512
   \       0x2C   0xE001             B.N      ??FLASH_EraseSector_1
    495            }
    496            else
    497            {
    498              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseSector_3: (+1)
   \       0x2E   0xF44F 0x7640      MOV      R6,#+768
    499            }
    500            /* Wait for last operation to be completed */
    501            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_EraseSector_1: (+1)
   \       0x32   0x....'....        BL       FLASH_WaitForLastOperation
    502            
    503            if(status == FLASH_COMPLETE)
   \       0x36   0x0001             MOVS     R1,R0
   \       0x38   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x3A   0x2909             CMP      R1,#+9
   \       0x3C   0xD11F             BNE.N    ??FLASH_EraseSector_4
    504            { 
    505              /* if the previous operation is completed, proceed to erase the sector */
    506              FLASH->CR &= CR_PSIZE_MASK;
   \       0x3E   0x....'....        LDR.W    R5,??DataTable38_1  ;; 0x40023c10
   \       0x42   0x6828             LDR      R0,[R5, #+0]
   \       0x44   0xF430 0x7040      BICS     R0,R0,#0x300
   \       0x48   0x6028             STR      R0,[R5, #+0]
    507              FLASH->CR |= tmp_psize;
   \       0x4A   0x6828             LDR      R0,[R5, #+0]
   \       0x4C   0x4306             ORRS     R6,R6,R0
   \       0x4E   0x602E             STR      R6,[R5, #+0]
    508              FLASH->CR &= SECTOR_MASK;
   \       0x50   0x6828             LDR      R0,[R5, #+0]
   \       0x52   0xF030 0x00F8      BICS     R0,R0,#0xF8
   \       0x56   0x6028             STR      R0,[R5, #+0]
    509              FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
   \       0x58   0x6828             LDR      R0,[R5, #+0]
   \       0x5A   0xF054 0x0402      ORRS     R4,R4,#0x2
   \       0x5E   0x4304             ORRS     R4,R4,R0
   \       0x60   0x602C             STR      R4,[R5, #+0]
    510              FLASH->CR |= FLASH_CR_STRT;
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \       0x68   0x6028             STR      R0,[R5, #+0]
    511              
    512              /* Wait for last operation to be completed */
    513              status = FLASH_WaitForLastOperation();
   \       0x6A   0x....'....        BL       FLASH_WaitForLastOperation
    514              
    515              /* if the erase operation is completed, disable the SER Bit */
    516              FLASH->CR &= (~FLASH_CR_SER);
   \       0x6E   0x6829             LDR      R1,[R5, #+0]
   \       0x70   0xF031 0x0102      BICS     R1,R1,#0x2
   \       0x74   0x6029             STR      R1,[R5, #+0]
    517              FLASH->CR &= SECTOR_MASK; 
   \       0x76   0x6829             LDR      R1,[R5, #+0]
   \       0x78   0xF031 0x01F8      BICS     R1,R1,#0xF8
   \       0x7C   0x6029             STR      R1,[R5, #+0]
    518            }
    519            /* Return the Erase Status */
    520            return status;
   \                     ??FLASH_EraseSector_4: (+1)
   \       0x7E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x80   0xBD70             POP      {R4-R6,PC}       ;; return
    521          }
    522          
    523          /**
    524            * @brief  Erases all FLASH Sectors.
    525            *
    526            * @note   If an erase and a program operations are requested simultaneously,    
    527            *         the erase operation is performed before the program one.
    528            *  
    529            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    530            *          This parameter can be one of the following values:
    531            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    532            *                                  the operation will be done by byte (8-bit) 
    533            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    534            *                                  the operation will be done by half word (16-bit)
    535            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    536            *                                  the operation will be done by word (32-bit)
    537            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    538            *                                  the operation will be done by double word (64-bit)
    539            *       
    540            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    541            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    542            */

   \                                 In section .text, align 2, keep-with-next
    543          FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
    544          {
   \                     FLASH_EraseAllSectors: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    545            uint32_t tmp_psize = 0x0;
   \        0x4   0x2000             MOVS     R0,#+0
    546            FLASH_Status status = FLASH_COMPLETE;
   \        0x6   0x2009             MOVS     R0,#+9
    547            
    548            /* Wait for last operation to be completed */
    549            status = FLASH_WaitForLastOperation();
   \        0x8   0x....'....        BL       FLASH_WaitForLastOperation
    550            assert_param(IS_VOLTAGERANGE(VoltageRange));
    551            
    552            if(VoltageRange == VoltageRange_1)
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x10   0x2900             CMP      R1,#+0
   \       0x12   0xD101             BNE.N    ??FLASH_EraseAllSectors_0
    553            {
    554               tmp_psize = FLASH_PSIZE_BYTE;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0xE00E             B.N      ??FLASH_EraseAllSectors_1
    555            }
    556            else if(VoltageRange == VoltageRange_2)
   \                     ??FLASH_EraseAllSectors_0: (+1)
   \       0x18   0x0021             MOVS     R1,R4
   \       0x1A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x1C   0x2901             CMP      R1,#+1
   \       0x1E   0xD102             BNE.N    ??FLASH_EraseAllSectors_2
    557            {
    558              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \       0x20   0xF44F 0x7180      MOV      R1,#+256
   \       0x24   0xE007             B.N      ??FLASH_EraseAllSectors_1
    559            }
    560            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseAllSectors_2: (+1)
   \       0x26   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x28   0x2C02             CMP      R4,#+2
   \       0x2A   0xD102             BNE.N    ??FLASH_EraseAllSectors_3
    561            {
    562              tmp_psize = FLASH_PSIZE_WORD;
   \       0x2C   0xF44F 0x7100      MOV      R1,#+512
   \       0x30   0xE001             B.N      ??FLASH_EraseAllSectors_1
    563            }
    564            else
    565            {
    566              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseAllSectors_3: (+1)
   \       0x32   0xF44F 0x7140      MOV      R1,#+768
    567            }  
    568            if(status == FLASH_COMPLETE)
   \                     ??FLASH_EraseAllSectors_1: (+1)
   \       0x36   0x0002             MOVS     R2,R0
   \       0x38   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x3A   0x2A09             CMP      R2,#+9
   \       0x3C   0xD119             BNE.N    ??FLASH_EraseAllSectors_4
    569            {
    570              /* if the previous operation is completed, proceed to erase all sectors */
    571          #if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F469_479xx)
    572              FLASH->CR &= CR_PSIZE_MASK;
   \       0x3E   0x....'....        LDR.W    R4,??DataTable38_1  ;; 0x40023c10
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0xF430 0x7040      BICS     R0,R0,#0x300
   \       0x48   0x6020             STR      R0,[R4, #+0]
    573              FLASH->CR |= tmp_psize;
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x4301             ORRS     R1,R1,R0
   \       0x4E   0x6021             STR      R1,[R4, #+0]
    574              FLASH->CR |= (FLASH_CR_MER1 | FLASH_CR_MER2);
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0xF440 0x4000      ORR      R0,R0,#0x8000
   \       0x56   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x5A   0x6020             STR      R0,[R4, #+0]
    575              FLASH->CR |= FLASH_CR_STRT;
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \       0x62   0x6020             STR      R0,[R4, #+0]
    576              
    577              /* Wait for last operation to be completed */
    578              status = FLASH_WaitForLastOperation();
   \       0x64   0x....'....        BL       FLASH_WaitForLastOperation
    579          
    580              /* if the erase operation is completed, disable the MER Bit */
    581              FLASH->CR &= ~(FLASH_CR_MER1 | FLASH_CR_MER2);
   \       0x68   0x6822             LDR      R2,[R4, #+0]
   \       0x6A   0x....'....        LDR.W    R1,??DataTable38_5  ;; 0xffff7ffb
   \       0x6E   0x400A             ANDS     R2,R1,R2
   \       0x70   0x6022             STR      R2,[R4, #+0]
    582          #endif /* STM32F427_437xx ||  STM32F429_439xx ||  STM32F469_479xx */
    583          
    584          #if defined(STM32F40_41xxx) || defined(STM32F401xx) || defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
    585              FLASH->CR &= CR_PSIZE_MASK;
    586              FLASH->CR |= tmp_psize;
    587              FLASH->CR |= FLASH_CR_MER;
    588              FLASH->CR |= FLASH_CR_STRT;
    589              
    590              /* Wait for last operation to be completed */
    591              status = FLASH_WaitForLastOperation();
    592          
    593              /* if the erase operation is completed, disable the MER Bit */
    594              FLASH->CR &= (~FLASH_CR_MER);
    595          #endif /* STM32F40_41xxx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F412xG || STM32F413_423xx || STM32F446xx */
    596          
    597            }   
    598            /* Return the Erase Status */
    599            return status;
   \                     ??FLASH_EraseAllSectors_4: (+1)
   \       0x72   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x74   0xBD10             POP      {R4,PC}          ;; return
    600          }
    601          
    602          /**
    603            * @brief  Erases all FLASH Sectors in Bank 1.
    604            *
    605            * @note   This function can be used only for STM32F42xxx/43xxx devices.
    606            *      
    607            * @note   If an erase and a program operations are requested simultaneously,    
    608            *         the erase operation is performed before the program one. 
    609            *  
    610            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    611            *          This parameter can be one of the following values:
    612            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    613            *                                  the operation will be done by byte (8-bit) 
    614            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    615            *                                  the operation will be done by half word (16-bit)
    616            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    617            *                                  the operation will be done by word (32-bit)
    618            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    619            *                                  the operation will be done by double word (64-bit)
    620            *       
    621            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    622            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    623            */

   \                                 In section .text, align 2, keep-with-next
    624          FLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange)
    625          {
   \                     FLASH_EraseAllBank1Sectors: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    626            uint32_t tmp_psize = 0x0;
   \        0x4   0x2000             MOVS     R0,#+0
    627            FLASH_Status status = FLASH_COMPLETE;
   \        0x6   0x2009             MOVS     R0,#+9
    628            
    629            /* Wait for last operation to be completed */
    630            status = FLASH_WaitForLastOperation();
   \        0x8   0x....'....        BL       FLASH_WaitForLastOperation
    631            assert_param(IS_VOLTAGERANGE(VoltageRange));
    632            
    633            if(VoltageRange == VoltageRange_1)
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x10   0x2900             CMP      R1,#+0
   \       0x12   0xD101             BNE.N    ??FLASH_EraseAllBank1Sectors_0
    634            {
    635               tmp_psize = FLASH_PSIZE_BYTE;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0xE00E             B.N      ??FLASH_EraseAllBank1Sectors_1
    636            }
    637            else if(VoltageRange == VoltageRange_2)
   \                     ??FLASH_EraseAllBank1Sectors_0: (+1)
   \       0x18   0x0021             MOVS     R1,R4
   \       0x1A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x1C   0x2901             CMP      R1,#+1
   \       0x1E   0xD102             BNE.N    ??FLASH_EraseAllBank1Sectors_2
    638            {
    639              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \       0x20   0xF44F 0x7180      MOV      R1,#+256
   \       0x24   0xE007             B.N      ??FLASH_EraseAllBank1Sectors_1
    640            }
    641            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseAllBank1Sectors_2: (+1)
   \       0x26   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x28   0x2C02             CMP      R4,#+2
   \       0x2A   0xD102             BNE.N    ??FLASH_EraseAllBank1Sectors_3
    642            {
    643              tmp_psize = FLASH_PSIZE_WORD;
   \       0x2C   0xF44F 0x7100      MOV      R1,#+512
   \       0x30   0xE001             B.N      ??FLASH_EraseAllBank1Sectors_1
    644            }
    645            else
    646            {
    647              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseAllBank1Sectors_3: (+1)
   \       0x32   0xF44F 0x7140      MOV      R1,#+768
    648            }  
    649            if(status == FLASH_COMPLETE)
   \                     ??FLASH_EraseAllBank1Sectors_1: (+1)
   \       0x36   0x0002             MOVS     R2,R0
   \       0x38   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x3A   0x2A09             CMP      R2,#+9
   \       0x3C   0xD116             BNE.N    ??FLASH_EraseAllBank1Sectors_4
    650            {
    651              /* if the previous operation is completed, proceed to erase all sectors */
    652               FLASH->CR &= CR_PSIZE_MASK;
   \       0x3E   0x....'....        LDR.W    R4,??DataTable38_1  ;; 0x40023c10
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0xF430 0x7040      BICS     R0,R0,#0x300
   \       0x48   0x6020             STR      R0,[R4, #+0]
    653               FLASH->CR |= tmp_psize;
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x4301             ORRS     R1,R1,R0
   \       0x4E   0x6021             STR      R1,[R4, #+0]
    654               FLASH->CR |= FLASH_CR_MER1;
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x56   0x6020             STR      R0,[R4, #+0]
    655               FLASH->CR |= FLASH_CR_STRT;
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \       0x5E   0x6020             STR      R0,[R4, #+0]
    656              
    657              /* Wait for last operation to be completed */
    658              status = FLASH_WaitForLastOperation();
   \       0x60   0x....'....        BL       FLASH_WaitForLastOperation
    659          
    660              /* if the erase operation is completed, disable the MER Bit */
    661              FLASH->CR &= (~FLASH_CR_MER1);
   \       0x64   0x6821             LDR      R1,[R4, #+0]
   \       0x66   0xF031 0x0104      BICS     R1,R1,#0x4
   \       0x6A   0x6021             STR      R1,[R4, #+0]
    662          
    663            }   
    664            /* Return the Erase Status */
    665            return status;
   \                     ??FLASH_EraseAllBank1Sectors_4: (+1)
   \       0x6C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x6E   0xBD10             POP      {R4,PC}          ;; return
    666          }
    667          
    668          
    669          /**
    670            * @brief  Erases all FLASH Sectors in Bank 2.
    671            *
    672            * @note   This function can be used only for STM32F42xxx/43xxx devices.
    673            *     
    674            * @note   If an erase and a program operations are requested simultaneously,    
    675            *         the erase operation is performed before the program one.
    676            *     
    677            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    678            *          This parameter can be one of the following values:
    679            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    680            *                                  the operation will be done by byte (8-bit) 
    681            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    682            *                                  the operation will be done by half word (16-bit)
    683            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    684            *                                  the operation will be done by word (32-bit)
    685            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    686            *                                  the operation will be done by double word (64-bit)
    687            *       
    688            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    689            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    690            */

   \                                 In section .text, align 2, keep-with-next
    691          FLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange)
    692          {
   \                     FLASH_EraseAllBank2Sectors: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    693            uint32_t tmp_psize = 0x0;
   \        0x4   0x2000             MOVS     R0,#+0
    694            FLASH_Status status = FLASH_COMPLETE;
   \        0x6   0x2009             MOVS     R0,#+9
    695            
    696            /* Wait for last operation to be completed */
    697            status = FLASH_WaitForLastOperation();
   \        0x8   0x....'....        BL       FLASH_WaitForLastOperation
    698            assert_param(IS_VOLTAGERANGE(VoltageRange));
    699            
    700            if(VoltageRange == VoltageRange_1)
   \        0xC   0x0021             MOVS     R1,R4
   \        0xE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x10   0x2900             CMP      R1,#+0
   \       0x12   0xD101             BNE.N    ??FLASH_EraseAllBank2Sectors_0
    701            {
    702               tmp_psize = FLASH_PSIZE_BYTE;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0xE00E             B.N      ??FLASH_EraseAllBank2Sectors_1
    703            }
    704            else if(VoltageRange == VoltageRange_2)
   \                     ??FLASH_EraseAllBank2Sectors_0: (+1)
   \       0x18   0x0021             MOVS     R1,R4
   \       0x1A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x1C   0x2901             CMP      R1,#+1
   \       0x1E   0xD102             BNE.N    ??FLASH_EraseAllBank2Sectors_2
    705            {
    706              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \       0x20   0xF44F 0x7180      MOV      R1,#+256
   \       0x24   0xE007             B.N      ??FLASH_EraseAllBank2Sectors_1
    707            }
    708            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseAllBank2Sectors_2: (+1)
   \       0x26   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x28   0x2C02             CMP      R4,#+2
   \       0x2A   0xD102             BNE.N    ??FLASH_EraseAllBank2Sectors_3
    709            {
    710              tmp_psize = FLASH_PSIZE_WORD;
   \       0x2C   0xF44F 0x7100      MOV      R1,#+512
   \       0x30   0xE001             B.N      ??FLASH_EraseAllBank2Sectors_1
    711            }
    712            else
    713            {
    714              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseAllBank2Sectors_3: (+1)
   \       0x32   0xF44F 0x7140      MOV      R1,#+768
    715            }  
    716            if(status == FLASH_COMPLETE)
   \                     ??FLASH_EraseAllBank2Sectors_1: (+1)
   \       0x36   0x0002             MOVS     R2,R0
   \       0x38   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x3A   0x2A09             CMP      R2,#+9
   \       0x3C   0xD116             BNE.N    ??FLASH_EraseAllBank2Sectors_4
    717            {
    718              /* if the previous operation is completed, proceed to erase all sectors */
    719               FLASH->CR &= CR_PSIZE_MASK;
   \       0x3E   0x....'....        LDR.W    R4,??DataTable38_1  ;; 0x40023c10
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0xF430 0x7040      BICS     R0,R0,#0x300
   \       0x48   0x6020             STR      R0,[R4, #+0]
    720               FLASH->CR |= tmp_psize;
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x4301             ORRS     R1,R1,R0
   \       0x4E   0x6021             STR      R1,[R4, #+0]
    721               FLASH->CR |= FLASH_CR_MER2;
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x56   0x6020             STR      R0,[R4, #+0]
    722               FLASH->CR |= FLASH_CR_STRT;
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \       0x5E   0x6020             STR      R0,[R4, #+0]
    723              
    724              /* Wait for last operation to be completed */
    725              status = FLASH_WaitForLastOperation();
   \       0x60   0x....'....        BL       FLASH_WaitForLastOperation
    726          
    727              /* if the erase operation is completed, disable the MER Bit */
    728              FLASH->CR &= (~FLASH_CR_MER2);
   \       0x64   0x6821             LDR      R1,[R4, #+0]
   \       0x66   0xF431 0x4100      BICS     R1,R1,#0x8000
   \       0x6A   0x6021             STR      R1,[R4, #+0]
    729          
    730            }   
    731            /* Return the Erase Status */
    732            return status;
   \                     ??FLASH_EraseAllBank2Sectors_4: (+1)
   \       0x6C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x6E   0xBD10             POP      {R4,PC}          ;; return
    733          }
    734          
    735          /**
    736            * @brief  Programs a double word (64-bit) at a specified address.
    737            * @note   This function must be used when the device voltage range is from
    738            *         2.7V to 3.6V and an External Vpp is present.
    739            *
    740            * @note   If an erase and a program operations are requested simultaneously,    
    741            *         the erase operation is performed before the program one.
    742            *  
    743            * @param  Address: specifies the address to be programmed.
    744            * @param  Data: specifies the data to be programmed.
    745            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    746            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    747            */

   \                                 In section .text, align 2, keep-with-next
    748          FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    749          {
   \                     FLASH_ProgramDoubleWord: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x0014             MOVS     R4,R2
   \        0x6   0x001D             MOVS     R5,R3
    750            FLASH_Status status = FLASH_COMPLETE;
   \        0x8   0x2009             MOVS     R0,#+9
    751          
    752            /* Check the parameters */
    753            assert_param(IS_FLASH_ADDRESS(Address));
    754          
    755            /* Wait for last operation to be completed */
    756            status = FLASH_WaitForLastOperation();
   \        0xA   0x....'....        BL       FLASH_WaitForLastOperation
    757            
    758            if(status == FLASH_COMPLETE)
   \        0xE   0x0001             MOVS     R1,R0
   \       0x10   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x12   0x2909             CMP      R1,#+9
   \       0x14   0xD114             BNE.N    ??FLASH_ProgramDoubleWord_0
    759            {
    760              /* if the previous operation is completed, proceed to program the new data */
    761              FLASH->CR &= CR_PSIZE_MASK;
   \       0x16   0x....             LDR.N    R7,??DataTable38_1  ;; 0x40023c10
   \       0x18   0x6838             LDR      R0,[R7, #+0]
   \       0x1A   0xF430 0x7040      BICS     R0,R0,#0x300
   \       0x1E   0x6038             STR      R0,[R7, #+0]
    762              FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
   \       0x20   0x6838             LDR      R0,[R7, #+0]
   \       0x22   0xF450 0x7040      ORRS     R0,R0,#0x300
   \       0x26   0x6038             STR      R0,[R7, #+0]
    763              FLASH->CR |= FLASH_CR_PG;
   \       0x28   0x6838             LDR      R0,[R7, #+0]
   \       0x2A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x2E   0x6038             STR      R0,[R7, #+0]
    764            
    765              *(__IO uint64_t*)Address = Data;
   \       0x30   0xE9C6 0x4500      STRD     R4,R5,[R6, #+0]
    766                  
    767              /* Wait for last operation to be completed */
    768              status = FLASH_WaitForLastOperation();
   \       0x34   0x....'....        BL       FLASH_WaitForLastOperation
    769          
    770              /* if the program operation is completed, disable the PG Bit */
    771              FLASH->CR &= (~FLASH_CR_PG);
   \       0x38   0x6839             LDR      R1,[R7, #+0]
   \       0x3A   0x0849             LSRS     R1,R1,#+1
   \       0x3C   0x0049             LSLS     R1,R1,#+1
   \       0x3E   0x6039             STR      R1,[R7, #+0]
    772            } 
    773            /* Return the Program Status */
    774            return status;
   \                     ??FLASH_ProgramDoubleWord_0: (+1)
   \       0x40   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x42   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    775          }
    776          
    777          /**
    778            * @brief  Programs a word (32-bit) at a specified address.
    779            *
    780            * @note   This function must be used when the device voltage range is from 2.7V to 3.6V. 
    781            *
    782            * @note   If an erase and a program operations are requested simultaneously,    
    783            *         the erase operation is performed before the program one.
    784            *  
    785            * @param  Address: specifies the address to be programmed.
    786            *         This parameter can be any address in Program memory zone or in OTP zone.  
    787            * @param  Data: specifies the data to be programmed.
    788            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    789            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    790            */

   \                                 In section .text, align 2, keep-with-next
    791          FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    792          {
   \                     FLASH_ProgramWord: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    793            FLASH_Status status = FLASH_COMPLETE;
   \        0x6   0x2009             MOVS     R0,#+9
    794          
    795            /* Check the parameters */
    796            assert_param(IS_FLASH_ADDRESS(Address));
    797          
    798            /* Wait for last operation to be completed */
    799            status = FLASH_WaitForLastOperation();
   \        0x8   0x....'....        BL       FLASH_WaitForLastOperation
    800            
    801            if(status == FLASH_COMPLETE)
   \        0xC   0x0001             MOVS     R1,R0
   \        0xE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x10   0x2909             CMP      R1,#+9
   \       0x12   0xD113             BNE.N    ??FLASH_ProgramWord_0
    802            {
    803              /* if the previous operation is completed, proceed to program the new data */
    804              FLASH->CR &= CR_PSIZE_MASK;
   \       0x14   0x....             LDR.N    R6,??DataTable38_1  ;; 0x40023c10
   \       0x16   0x6830             LDR      R0,[R6, #+0]
   \       0x18   0xF430 0x7040      BICS     R0,R0,#0x300
   \       0x1C   0x6030             STR      R0,[R6, #+0]
    805              FLASH->CR |= FLASH_PSIZE_WORD;
   \       0x1E   0x6830             LDR      R0,[R6, #+0]
   \       0x20   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x24   0x6030             STR      R0,[R6, #+0]
    806              FLASH->CR |= FLASH_CR_PG;
   \       0x26   0x6830             LDR      R0,[R6, #+0]
   \       0x28   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x2C   0x6030             STR      R0,[R6, #+0]
    807            
    808              *(__IO uint32_t*)Address = Data;
   \       0x2E   0x6025             STR      R5,[R4, #+0]
    809                  
    810              /* Wait for last operation to be completed */
    811              status = FLASH_WaitForLastOperation();
   \       0x30   0x....'....        BL       FLASH_WaitForLastOperation
    812          
    813              /* if the program operation is completed, disable the PG Bit */
    814              FLASH->CR &= (~FLASH_CR_PG);
   \       0x34   0x6831             LDR      R1,[R6, #+0]
   \       0x36   0x0849             LSRS     R1,R1,#+1
   \       0x38   0x0049             LSLS     R1,R1,#+1
   \       0x3A   0x6031             STR      R1,[R6, #+0]
    815            } 
    816            /* Return the Program Status */
    817            return status;
   \                     ??FLASH_ProgramWord_0: (+1)
   \       0x3C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x3E   0xBD70             POP      {R4-R6,PC}       ;; return
    818          }
    819          
    820          /**
    821            * @brief  Programs a half word (16-bit) at a specified address. 
    822            * @note   This function must be used when the device voltage range is from 2.1V to 3.6V. 
    823            *
    824            * @note   If an erase and a program operations are requested simultaneously,    
    825            *         the erase operation is performed before the program one.
    826            * 
    827            * @param  Address: specifies the address to be programmed.
    828            *         This parameter can be any address in Program memory zone or in OTP zone.  
    829            * @param  Data: specifies the data to be programmed.
    830            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    831            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    832            */

   \                                 In section .text, align 2, keep-with-next
    833          FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    834          {
   \                     FLASH_ProgramHalfWord: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    835            FLASH_Status status = FLASH_COMPLETE;
   \        0x6   0x2009             MOVS     R0,#+9
    836          
    837            /* Check the parameters */
    838            assert_param(IS_FLASH_ADDRESS(Address));
    839          
    840            /* Wait for last operation to be completed */
    841            status = FLASH_WaitForLastOperation();
   \        0x8   0x....'....        BL       FLASH_WaitForLastOperation
    842            
    843            if(status == FLASH_COMPLETE)
   \        0xC   0x0001             MOVS     R1,R0
   \        0xE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x10   0x2909             CMP      R1,#+9
   \       0x12   0xD113             BNE.N    ??FLASH_ProgramHalfWord_0
    844            {
    845              /* if the previous operation is completed, proceed to program the new data */
    846              FLASH->CR &= CR_PSIZE_MASK;
   \       0x14   0x....             LDR.N    R6,??DataTable38_1  ;; 0x40023c10
   \       0x16   0x6830             LDR      R0,[R6, #+0]
   \       0x18   0xF430 0x7040      BICS     R0,R0,#0x300
   \       0x1C   0x6030             STR      R0,[R6, #+0]
    847              FLASH->CR |= FLASH_PSIZE_HALF_WORD;
   \       0x1E   0x6830             LDR      R0,[R6, #+0]
   \       0x20   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x24   0x6030             STR      R0,[R6, #+0]
    848              FLASH->CR |= FLASH_CR_PG;
   \       0x26   0x6830             LDR      R0,[R6, #+0]
   \       0x28   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x2C   0x6030             STR      R0,[R6, #+0]
    849            
    850              *(__IO uint16_t*)Address = Data;
   \       0x2E   0x8025             STRH     R5,[R4, #+0]
    851                  
    852              /* Wait for last operation to be completed */
    853              status = FLASH_WaitForLastOperation();
   \       0x30   0x....'....        BL       FLASH_WaitForLastOperation
    854          
    855              /* if the program operation is completed, disable the PG Bit */
    856              FLASH->CR &= (~FLASH_CR_PG);
   \       0x34   0x6831             LDR      R1,[R6, #+0]
   \       0x36   0x0849             LSRS     R1,R1,#+1
   \       0x38   0x0049             LSLS     R1,R1,#+1
   \       0x3A   0x6031             STR      R1,[R6, #+0]
    857            } 
    858            /* Return the Program Status */
    859            return status;
   \                     ??FLASH_ProgramHalfWord_0: (+1)
   \       0x3C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x3E   0xBD70             POP      {R4-R6,PC}       ;; return
    860          }
    861          
    862          /**
    863            * @brief  Programs a byte (8-bit) at a specified address.
    864            * @note   This function can be used within all the device supply voltage ranges.  
    865            *
    866            * @note   If an erase and a program operations are requested simultaneously,    
    867            *         the erase operation is performed before the program one.
    868            * 
    869            * @param  Address: specifies the address to be programmed.
    870            *         This parameter can be any address in Program memory zone or in OTP zone.  
    871            * @param  Data: specifies the data to be programmed.
    872            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    873            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    874            */

   \                                 In section .text, align 2, keep-with-next
    875          FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    876          {
   \                     FLASH_ProgramByte: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    877            FLASH_Status status = FLASH_COMPLETE;
   \        0x6   0x2009             MOVS     R0,#+9
    878          
    879            /* Check the parameters */
    880            assert_param(IS_FLASH_ADDRESS(Address));
    881          
    882            /* Wait for last operation to be completed */
    883            status = FLASH_WaitForLastOperation();
   \        0x8   0x....'....        BL       FLASH_WaitForLastOperation
    884            
    885            if(status == FLASH_COMPLETE)
   \        0xC   0x0001             MOVS     R1,R0
   \        0xE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x10   0x2909             CMP      R1,#+9
   \       0x12   0xD111             BNE.N    ??FLASH_ProgramByte_0
    886            {
    887              /* if the previous operation is completed, proceed to program the new data */
    888              FLASH->CR &= CR_PSIZE_MASK;
   \       0x14   0x....             LDR.N    R6,??DataTable38_1  ;; 0x40023c10
   \       0x16   0x6830             LDR      R0,[R6, #+0]
   \       0x18   0xF430 0x7040      BICS     R0,R0,#0x300
   \       0x1C   0x6030             STR      R0,[R6, #+0]
    889              FLASH->CR |= FLASH_PSIZE_BYTE;
   \       0x1E   0x6830             LDR      R0,[R6, #+0]
   \       0x20   0x6030             STR      R0,[R6, #+0]
    890              FLASH->CR |= FLASH_CR_PG;
   \       0x22   0x6830             LDR      R0,[R6, #+0]
   \       0x24   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x28   0x6030             STR      R0,[R6, #+0]
    891            
    892              *(__IO uint8_t*)Address = Data;
   \       0x2A   0x7025             STRB     R5,[R4, #+0]
    893                  
    894              /* Wait for last operation to be completed */
    895              status = FLASH_WaitForLastOperation();
   \       0x2C   0x....'....        BL       FLASH_WaitForLastOperation
    896          
    897              /* if the program operation is completed, disable the PG Bit */
    898              FLASH->CR &= (~FLASH_CR_PG);
   \       0x30   0x6831             LDR      R1,[R6, #+0]
   \       0x32   0x0849             LSRS     R1,R1,#+1
   \       0x34   0x0049             LSLS     R1,R1,#+1
   \       0x36   0x6031             STR      R1,[R6, #+0]
    899            } 
    900          
    901            /* Return the Program Status */
    902            return status;
   \                     ??FLASH_ProgramByte_0: (+1)
   \       0x38   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x3A   0xBD70             POP      {R4-R6,PC}       ;; return
    903          }
    904          
    905          /**
    906            * @}
    907            */
    908          
    909          /** @defgroup FLASH_Group3 Option Bytes Programming functions
    910           *  @brief   Option Bytes Programming functions 
    911           *
    912          @verbatim   
    913           ===============================================================================
    914                          ##### Option Bytes Programming functions #####
    915           ===============================================================================  
    916              [..]
    917                This group includes the following functions:
    918                (+) void FLASH_OB_Unlock(void)
    919                (+) void FLASH_OB_Lock(void)
    920                (+) void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    921                (+) void FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState)  
    922                (+) void FLASH_OB_PCROPSelectionConfig(uint8_t OB_PCROPSelect)
    923                (+) void FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState)
    924                (+) void FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState) 
    925                (+) void FLASH_OB_RDPConfig(uint8_t OB_RDP)
    926                (+) void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
    927                (+) void FLASH_OB_BORConfig(uint8_t OB_BOR)
    928                (+) FLASH_Status FLASH_ProgramOTP(uint32_t Address, uint32_t Data)
    929                (+) FLASH_Status FLASH_OB_Launch(void)
    930                (+) uint32_t FLASH_OB_GetUser(void)
    931                (+) uint8_t FLASH_OB_GetWRP(void)
    932                (+) uint8_t FLASH_OB_GetWRP1(void)
    933                (+) uint8_t FLASH_OB_GetPCROP(void)
    934                (+) uint8_t FLASH_OB_GetPCROP1(void)
    935                (+) uint8_t FLASH_OB_GetRDP(void)
    936                (+) uint8_t FLASH_OB_GetBOR(void)
    937              [..]  
    938                The following function can be used only for STM32F42xxx/43xxx devices. 
    939                (+) void FLASH_OB_BootConfig(uint8_t OB_BOOT)
    940              [..]   
    941               Any operation of erase or program should follow these steps:
    942                (#) Call the FLASH_OB_Unlock() function to enable the FLASH option control 
    943                    register access
    944          
    945                (#) Call one or several functions to program the desired Option Bytes:
    946                  (++) void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState) 
    947                       => to Enable/Disable the desired sector write protection
    948                  (++) void FLASH_OB_RDPConfig(uint8_t OB_RDP) => to set the desired read 
    949                       Protection Level
    950                  (++) void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY) 
    951                       => to configure the user Option Bytes.
    952                  (++) void FLASH_OB_BORConfig(uint8_t OB_BOR) => to set the BOR Level 			 
    953          
    954                (#) Once all needed Option Bytes to be programmed are correctly written, 
    955                    call the FLASH_OB_Launch() function to launch the Option Bytes 
    956                    programming process.
    957               
    958                -@- When changing the IWDG mode from HW to SW or from SW to HW, a system 
    959                    reset is needed to make the change effective.  
    960          
    961                (#) Call the FLASH_OB_Lock() function to disable the FLASH option control 
    962                    register access (recommended to protect the Option Bytes against 
    963                    possible unwanted operations)
    964              
    965          @endverbatim
    966            * @{
    967            */
    968          
    969          /**
    970            * @brief  Unlocks the FLASH Option Control Registers access.
    971            * @param  None
    972            * @retval None
    973            */

   \                                 In section .text, align 2, keep-with-next
    974          void FLASH_OB_Unlock(void)
    975          {
    976            if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
   \                     FLASH_OB_Unlock: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable38_6  ;; 0x40023c14
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x07C0             LSLS     R0,R0,#+31
   \        0x6   0xD504             BPL.N    ??FLASH_OB_Unlock_0
    977            {
    978              /* Authorizes the Option Byte register programming */
    979              FLASH->OPTKEYR = FLASH_OPT_KEY1;
   \        0x8   0x....             LDR.N    R0,??DataTable38_7  ;; 0x40023c08
   \        0xA   0x....             LDR.N    R1,??DataTable38_8  ;; 0x8192a3b
   \        0xC   0x6001             STR      R1,[R0, #+0]
    980              FLASH->OPTKEYR = FLASH_OPT_KEY2;
   \        0xE   0x....             LDR.N    R1,??DataTable38_9  ;; 0x4c5d6e7f
   \       0x10   0x6001             STR      R1,[R0, #+0]
    981            }  
    982          }
   \                     ??FLASH_OB_Unlock_0: (+1)
   \       0x12   0x4770             BX       LR               ;; return
    983          
    984          /**
    985            * @brief  Locks the FLASH Option Control Registers access.
    986            * @param  None
    987            * @retval None
    988            */

   \                                 In section .text, align 2, keep-with-next
    989          void FLASH_OB_Lock(void)
    990          {
    991            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    992            FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
   \                     FLASH_OB_Lock: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable38_6  ;; 0x40023c14
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0101      ORRS     R1,R1,#0x1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    993          }
   \        0xA   0x4770             BX       LR               ;; return
    994          
    995          /**
    996            * @brief  Enables or disables the write protection of the desired sectors, for the first
    997            *         1 Mb of the Flash  
    998            *
    999            * @note   When the memory read protection level is selected (RDP level = 1), 
   1000            *         it is not possible to program or erase the flash sector i if CortexM4  
   1001            *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
   1002            * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).   
   1003            * 
   1004            * @param  OB_WRP: specifies the sector(s) to be write protected or unprotected.
   1005            *          This parameter can be one of the following values:
   1006            *            @arg OB_WRP: A value between OB_WRP_Sector0 and OB_WRP_Sector11                      
   1007            *            @arg OB_WRP_Sector_All
   1008            * @param  Newstate: new state of the Write Protection.
   1009            *          This parameter can be: ENABLE or DISABLE.
   1010            * @retval None  
   1011            */

   \                                 In section .text, align 2, keep-with-next
   1012          void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
   1013          { 
   \                     FLASH_OB_WRPConfig: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1014            FLASH_Status status = FLASH_COMPLETE;
   \        0x6   0x2009             MOVS     R0,#+9
   1015            
   1016            /* Check the parameters */
   1017            assert_param(IS_OB_WRP(OB_WRP));
   1018            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1019              
   1020            status = FLASH_WaitForLastOperation();
   \        0x8   0x....'....        BL       FLASH_WaitForLastOperation
   1021          
   1022            if(status == FLASH_COMPLETE)
   \        0xC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0xE   0x2809             CMP      R0,#+9
   \       0x10   0xD10C             BNE.N    ??FLASH_OB_WRPConfig_0
   1023            { 
   1024              if(NewState != DISABLE)
   \       0x12   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD005             BEQ.N    ??FLASH_OB_WRPConfig_1
   1025              {
   1026                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
   \       0x18   0x....             LDR.N    R0,??DataTable38_10  ;; 0x40023c16
   \       0x1A   0x8801             LDRH     R1,[R0, #+0]
   \       0x1C   0xEA31 0x0505      BICS     R5,R1,R5
   \       0x20   0x8005             STRH     R5,[R0, #+0]
   \       0x22   0xE003             B.N      ??FLASH_OB_WRPConfig_0
   1027              }
   1028              else
   1029              {
   1030                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
   \                     ??FLASH_OB_WRPConfig_1: (+1)
   \       0x24   0x....             LDR.N    R0,??DataTable38_10  ;; 0x40023c16
   \       0x26   0x8801             LDRH     R1,[R0, #+0]
   \       0x28   0x430D             ORRS     R5,R5,R1
   \       0x2A   0x8005             STRH     R5,[R0, #+0]
   1031              }
   1032            }
   1033          }
   \                     ??FLASH_OB_WRPConfig_0: (+1)
   \       0x2C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1034          
   1035          /**
   1036            * @brief  Enables or disables the write protection of the desired sectors, for the second
   1037            *         1 Mb of the Flash  
   1038            *           
   1039            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1040            *   
   1041            * @note   When the memory read out protection is selected (RDP level = 1), 
   1042            *         it is not possible to program or erase the flash sector i if CortexM4  
   1043            *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
   1044            * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).      
   1045            * 
   1046            * @param  OB_WRP: specifies the sector(s) to be write protected or unprotected.
   1047            *          This parameter can be one of the following values:
   1048            *            @arg OB_WRP: A value between OB_WRP_Sector12 and OB_WRP_Sector23
   1049            *            @arg OB_WRP_Sector_All                        
   1050            * @param  Newstate: new state of the Write Protection.
   1051            *          This parameter can be: ENABLE or DISABLE.
   1052            * @retval None  
   1053            */

   \                                 In section .text, align 2, keep-with-next
   1054          void FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState)
   1055          { 
   \                     FLASH_OB_WRP1Config: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1056            FLASH_Status status = FLASH_COMPLETE;
   \        0x6   0x2009             MOVS     R0,#+9
   1057            
   1058            /* Check the parameters */
   1059            assert_param(IS_OB_WRP(OB_WRP));
   1060            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1061              
   1062            status = FLASH_WaitForLastOperation();
   \        0x8   0x....'....        BL       FLASH_WaitForLastOperation
   1063          
   1064            if(status == FLASH_COMPLETE)
   \        0xC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0xE   0x2809             CMP      R0,#+9
   \       0x10   0xD10C             BNE.N    ??FLASH_OB_WRP1Config_0
   1065            { 
   1066              if(NewState != DISABLE)
   \       0x12   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD005             BEQ.N    ??FLASH_OB_WRP1Config_1
   1067              {
   1068                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_WRP);
   \       0x18   0x....             LDR.N    R0,??DataTable38_11  ;; 0x40023c1a
   \       0x1A   0x8801             LDRH     R1,[R0, #+0]
   \       0x1C   0xEA31 0x0505      BICS     R5,R1,R5
   \       0x20   0x8005             STRH     R5,[R0, #+0]
   \       0x22   0xE003             B.N      ??FLASH_OB_WRP1Config_0
   1069              }
   1070              else
   1071              {
   1072                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
   \                     ??FLASH_OB_WRP1Config_1: (+1)
   \       0x24   0x....             LDR.N    R0,??DataTable38_11  ;; 0x40023c1a
   \       0x26   0x8801             LDRH     R1,[R0, #+0]
   \       0x28   0x430D             ORRS     R5,R5,R1
   \       0x2A   0x8005             STRH     R5,[R0, #+0]
   1073              }
   1074            }
   1075          }
   \                     ??FLASH_OB_WRP1Config_0: (+1)
   \       0x2C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1076          
   1077          /**
   1078            * @brief  Select the Protection Mode (SPRMOD). 
   1079            * 
   1080            * @note   This function can be used only for STM32F42xxx/43xxx and STM32F401xx/411xE devices.       
   1081            * 
   1082            * @note   After PCROP activation, Option Byte modification is not possible. 
   1083            *         Exception made for the global Read Out Protection modification level (level1 to level0) 
   1084            * @note   Once SPRMOD bit is active unprotection of a protected sector is not possible 
   1085            *   
   1086            * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag
   1087            *   
   1088            * @note   Some Precautions should be taken when activating the PCROP feature :
   1089            *         The active value of nWRPi bits is inverted when PCROP mode is active, this means if SPRMOD = 1
   1090            *         and WRPi = 1 (default value), then the user sector i is read/write protected.
   1091            *         In order to avoid activation of PCROP Mode for undesired sectors, please follow the
   1092            *         below safety sequence :       
   1093            *         - Disable PCROP for all Sectors using FLASH_OB_PCROPConfig(OB_PCROP_Sector_All, DISABLE) function 
   1094            *           for Bank1 or FLASH_OB_PCROP1Config(OB_PCROP_Sector_All, DISABLE) function for Bank2   
   1095            *         - Enable PCROP for the desired Sector i using FLASH_OB_PCROPConfig(Sector i, ENABLE) function
   1096            *         - Activate the PCROP Mode FLASH_OB_PCROPSelectionConfig() function. 
   1097            * 
   1098            * @param  OB_PCROP:  Select the Protection Mode of nWPRi bits 
   1099            *          This parameter can be one of the following values:
   1100            *            @arg OB_PcROP_Disable: nWRPi control the write protection of respective user sectors.
   1101            *            @arg OB_PcROP_Enable: nWRPi control the  read&write protection (PCROP) of respective user sectors.
   1102            * @retval None
   1103            */

   \                                 In section .text, align 2, keep-with-next
   1104          void FLASH_OB_PCROPSelectionConfig(uint8_t OB_PcROP)
   1105          {  
   1106            uint8_t optiontmp = 0xFF;
   \                     FLASH_OB_PCROPSelectionConfig: (+1)
   \        0x0   0x21FF             MOVS     R1,#+255
   1107                
   1108            /* Check the parameters */
   1109            assert_param(IS_OB_PCROP_SELECT(OB_PcROP));
   1110            
   1111            /* Mask SPRMOD bit */
   1112            optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F); 
   \        0x2   0x....             LDR.N    R2,??DataTable38_12  ;; 0x40023c17
   \        0x4   0x7811             LDRB     R1,[R2, #+0]
   \        0x6   0xF011 0x017F      ANDS     R1,R1,#0x7F
   1113            /* Update Option Byte */
   1114            *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PcROP | optiontmp); 
   \        0xA   0x4308             ORRS     R0,R1,R0
   \        0xC   0x7010             STRB     R0,[R2, #+0]
   1115              
   1116          }
   \        0xE   0x4770             BX       LR               ;; return
   1117          
   1118          /**
   1119            * @brief  Enables or disables the read/write protection (PCROP) of the desired 
   1120            *         sectors, for the first 1 MB of the Flash.
   1121            *           
   1122            * @note   This function can be used only for STM32F42xxx/43xxx , STM32F401xx/411xE 
   1123            *         STM32F412xG and STM32F413_423xx devices.
   1124            *   
   1125            * @param  OB_PCROP: specifies the sector(s) to be read/write protected or unprotected.
   1126            *          This parameter can be one of the following values:
   1127            *            @arg OB_PCROP: A value between OB_PCROP_Sector0 and OB_PCROP_Sector11 for 
   1128            *                           STM32F42xxx/43xxx devices and between OB_PCROP_Sector0 and 
   1129            *                           OB_PCROP_Sector5 for STM32F401xx/411xE devices.
   1130            *            @arg OB_PCROP_Sector_All
   1131            * @param  Newstate: new state of the Write Protection.
   1132            *          This parameter can be: ENABLE or DISABLE.
   1133            * @retval None  
   1134            */

   \                                 In section .text, align 2, keep-with-next
   1135          void FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState)
   1136          { 
   \                     FLASH_OB_PCROPConfig: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1137            FLASH_Status status = FLASH_COMPLETE;
   \        0x6   0x2009             MOVS     R0,#+9
   1138            
   1139            /* Check the parameters */
   1140            assert_param(IS_OB_PCROP(OB_PCROP));
   1141            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1142              
   1143            status = FLASH_WaitForLastOperation();
   \        0x8   0x....'....        BL       FLASH_WaitForLastOperation
   1144          
   1145            if(status == FLASH_COMPLETE)
   \        0xC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0xE   0x2809             CMP      R0,#+9
   \       0x10   0xD10C             BNE.N    ??FLASH_OB_PCROPConfig_0
   1146            { 
   1147              if(NewState != DISABLE)
   \       0x12   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD004             BEQ.N    ??FLASH_OB_PCROPConfig_1
   1148              {
   1149                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;    
   \       0x18   0x....             LDR.N    R0,??DataTable38_10  ;; 0x40023c16
   \       0x1A   0x8801             LDRH     R1,[R0, #+0]
   \       0x1C   0x430D             ORRS     R5,R5,R1
   \       0x1E   0x8005             STRH     R5,[R0, #+0]
   \       0x20   0xE004             B.N      ??FLASH_OB_PCROPConfig_0
   1150              }
   1151              else
   1152              {
   1153                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_PCROP);
   \                     ??FLASH_OB_PCROPConfig_1: (+1)
   \       0x22   0x....             LDR.N    R0,??DataTable38_10  ;; 0x40023c16
   \       0x24   0x8801             LDRH     R1,[R0, #+0]
   \       0x26   0xEA31 0x0505      BICS     R5,R1,R5
   \       0x2A   0x8005             STRH     R5,[R0, #+0]
   1154              }
   1155            }
   1156          }
   \                     ??FLASH_OB_PCROPConfig_0: (+1)
   \       0x2C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1157          
   1158          /**
   1159             * @brief Enables or disables the read/write protection (PCROP) of the desired 
   1160            *         sectors
   1161            *           
   1162            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1163            *   
   1164            * @param  OB_PCROP: specifies the sector(s) to be read/write protected or unprotected.
   1165            *          This parameter can be one of the following values:
   1166            *            @arg OB_PCROP: A value between OB_PCROP_Sector12 and OB_PCROP_Sector23 
   1167            *            @arg OB_PCROP_Sector_All
   1168            * @param  Newstate: new state of the Write Protection.
   1169            *          This parameter can be: ENABLE or DISABLE.
   1170            * @retval None  
   1171            */

   \                                 In section .text, align 2, keep-with-next
   1172          void FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState)
   1173          { 
   \                     FLASH_OB_PCROP1Config: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1174            FLASH_Status status = FLASH_COMPLETE;
   \        0x6   0x2009             MOVS     R0,#+9
   1175            
   1176            /* Check the parameters */
   1177            assert_param(IS_OB_PCROP(OB_PCROP));
   1178            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1179              
   1180            status = FLASH_WaitForLastOperation();
   \        0x8   0x....'....        BL       FLASH_WaitForLastOperation
   1181          
   1182            if(status == FLASH_COMPLETE)
   \        0xC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0xE   0x2809             CMP      R0,#+9
   \       0x10   0xD10C             BNE.N    ??FLASH_OB_PCROP1Config_0
   1183            { 
   1184              if(NewState != DISABLE)
   \       0x12   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD004             BEQ.N    ??FLASH_OB_PCROP1Config_1
   1185              {
   1186                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;
   \       0x18   0x....             LDR.N    R0,??DataTable38_11  ;; 0x40023c1a
   \       0x1A   0x8801             LDRH     R1,[R0, #+0]
   \       0x1C   0x430D             ORRS     R5,R5,R1
   \       0x1E   0x8005             STRH     R5,[R0, #+0]
   \       0x20   0xE004             B.N      ??FLASH_OB_PCROP1Config_0
   1187              }
   1188              else
   1189              {
   1190                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_PCROP);
   \                     ??FLASH_OB_PCROP1Config_1: (+1)
   \       0x22   0x....             LDR.N    R0,??DataTable38_11  ;; 0x40023c1a
   \       0x24   0x8801             LDRH     R1,[R0, #+0]
   \       0x26   0xEA31 0x0505      BICS     R5,R1,R5
   \       0x2A   0x8005             STRH     R5,[R0, #+0]
   1191              }
   1192            }
   1193          }
   \                     ??FLASH_OB_PCROP1Config_0: (+1)
   \       0x2C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1194          
   1195          
   1196          /**
   1197            * @brief  Sets the read protection level.
   1198            * @param  OB_RDP: specifies the read protection level.
   1199            *          This parameter can be one of the following values:
   1200            *            @arg OB_RDP_Level_0: No protection
   1201            *            @arg OB_RDP_Level_1: Read protection of the memory
   1202            *            @arg OB_RDP_Level_2: Full chip protection
   1203            *   
   1204            * /!\ Warning /!\ When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
   1205            *    
   1206            * @retval None
   1207            */

   \                                 In section .text, align 2, keep-with-next
   1208          void FLASH_OB_RDPConfig(uint8_t OB_RDP)
   1209          {
   \                     FLASH_OB_RDPConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1210            FLASH_Status status = FLASH_COMPLETE;
   \        0x4   0x2009             MOVS     R0,#+9
   1211          
   1212            /* Check the parameters */
   1213            assert_param(IS_OB_RDP(OB_RDP));
   1214          
   1215            status = FLASH_WaitForLastOperation();
   \        0x6   0x....'....        BL       FLASH_WaitForLastOperation
   1216          
   1217            if(status == FLASH_COMPLETE)
   \        0xA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0xC   0x2809             CMP      R0,#+9
   \        0xE   0xD101             BNE.N    ??FLASH_OB_RDPConfig_0
   1218            {
   1219              *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
   \       0x10   0x....             LDR.N    R0,??DataTable38_13  ;; 0x40023c15
   \       0x12   0x7004             STRB     R4,[R0, #+0]
   1220          
   1221            }
   1222          }
   \                     ??FLASH_OB_RDPConfig_0: (+1)
   \       0x14   0xBD10             POP      {R4,PC}          ;; return
   1223          
   1224          /**
   1225            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    
   1226            * @param  OB_IWDG: Selects the IWDG mode
   1227            *          This parameter can be one of the following values:
   1228            *            @arg OB_IWDG_SW: Software IWDG selected
   1229            *            @arg OB_IWDG_HW: Hardware IWDG selected
   1230            * @param  OB_STOP: Reset event when entering STOP mode.
   1231            *          This parameter  can be one of the following values:
   1232            *            @arg OB_STOP_NoRST: No reset generated when entering in STOP
   1233            *            @arg OB_STOP_RST: Reset generated when entering in STOP
   1234            * @param  OB_STDBY: Reset event when entering Standby mode.
   1235            *          This parameter  can be one of the following values:
   1236            *            @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
   1237            *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
   1238            * @retval None
   1239            */

   \                                 In section .text, align 2, keep-with-next
   1240          void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
   1241          {
   \                     FLASH_OB_UserConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1242            uint8_t optiontmp = 0xFF;
   \        0x8   0x20FF             MOVS     R0,#+255
   1243            FLASH_Status status = FLASH_COMPLETE; 
   \        0xA   0x2009             MOVS     R0,#+9
   1244          
   1245            /* Check the parameters */
   1246            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
   1247            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
   1248            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
   1249          
   1250            /* Wait for last operation to be completed */
   1251            status = FLASH_WaitForLastOperation();
   \        0xC   0x....'....        BL       FLASH_WaitForLastOperation
   1252            
   1253            if(status == FLASH_COMPLETE)
   \       0x10   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x12   0x2809             CMP      R0,#+9
   \       0x14   0xD107             BNE.N    ??FLASH_OB_UserConfig_0
   1254            { 
   1255          #if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F469_479xx)
   1256              /* Mask OPTLOCK, OPTSTRT, BOR_LEV and BFB2 bits */
   1257              optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x1F);
   \       0x16   0x....             LDR.N    R1,??DataTable38_6  ;; 0x40023c14
   \       0x18   0x7808             LDRB     R0,[R1, #+0]
   \       0x1A   0xF010 0x001F      ANDS     R0,R0,#0x1F
   1258          #endif /* STM32F427_437xx ||  STM32F429_439xx ||  STM32F469_479xx */
   1259          
   1260          #if defined(STM32F40_41xxx) || defined(STM32F401xx) || defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F446xx)
   1261              /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
   1262              optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
   1263          #endif /* STM32F40_41xxx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F446xx */ 
   1264          
   1265              /* Update User Option Byte */
   1266              *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
   \       0x1E   0x4305             ORRS     R5,R0,R5
   \       0x20   0x4335             ORRS     R5,R5,R6
   \       0x22   0x432C             ORRS     R4,R5,R4
   \       0x24   0x700C             STRB     R4,[R1, #+0]
   1267            }  
   1268          }
   \                     ??FLASH_OB_UserConfig_0: (+1)
   \       0x26   0xBD70             POP      {R4-R6,PC}       ;; return
   1269          
   1270          /**
   1271            * @brief  Configure the Dual Bank Boot.
   1272            *   
   1273            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1274            *      
   1275            * @param  OB_BOOT: specifies the Dual Bank Boot Option byte.
   1276            *          This parameter can be one of the following values:
   1277            *            @arg OB_Dual_BootEnabled: Dual Bank Boot Enable
   1278            *            @arg OB_Dual_BootDisabled: Dual Bank Boot Disabled
   1279            * @retval None
   1280            */

   \                                 In section .text, align 2, keep-with-next
   1281          void FLASH_OB_BootConfig(uint8_t OB_BOOT)
   1282          {
   1283            /* Check the parameters */
   1284            assert_param(IS_OB_BOOT(OB_BOOT));
   1285          
   1286            /* Set Dual Bank Boot */
   1287            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BFB2);
   \                     FLASH_OB_BootConfig: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable38_6  ;; 0x40023c14
   \        0x2   0x780A             LDRB     R2,[R1, #+0]
   \        0x4   0xF012 0x02EF      ANDS     R2,R2,#0xEF
   \        0x8   0x700A             STRB     R2,[R1, #+0]
   1288            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOOT;
   \        0xA   0x780A             LDRB     R2,[R1, #+0]
   \        0xC   0x4310             ORRS     R0,R0,R2
   \        0xE   0x7008             STRB     R0,[R1, #+0]
   1289          
   1290          }
   \       0x10   0x4770             BX       LR               ;; return
   1291          
   1292          /**
   1293            * @brief  Sets the BOR Level. 
   1294            * @param  OB_BOR: specifies the Option Bytes BOR Reset Level.
   1295            *          This parameter can be one of the following values:
   1296            *            @arg OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
   1297            *            @arg OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
   1298            *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
   1299            *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
   1300            * @retval None
   1301            */

   \                                 In section .text, align 2, keep-with-next
   1302          void FLASH_OB_BORConfig(uint8_t OB_BOR)
   1303          {
   1304            /* Check the parameters */
   1305            assert_param(IS_OB_BOR(OB_BOR));
   1306          
   1307            /* Set the BOR Level */
   1308            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
   \                     FLASH_OB_BORConfig: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable38_6  ;; 0x40023c14
   \        0x2   0x780A             LDRB     R2,[R1, #+0]
   \        0x4   0xF012 0x02F3      ANDS     R2,R2,#0xF3
   \        0x8   0x700A             STRB     R2,[R1, #+0]
   1309            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
   \        0xA   0x780A             LDRB     R2,[R1, #+0]
   \        0xC   0x4310             ORRS     R0,R0,R2
   \        0xE   0x7008             STRB     R0,[R1, #+0]
   1310          
   1311          }
   \       0x10   0x4770             BX       LR               ;; return
   1312          
   1313          /**
   1314            * @brief  Launch the option byte loading.
   1315            * @param  None
   1316            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
   1317            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
   1318            */

   \                                 In section .text, align 2, keep-with-next
   1319          FLASH_Status FLASH_OB_Launch(void)
   1320          {
   \                     FLASH_OB_Launch: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1321            FLASH_Status status = FLASH_COMPLETE;
   \        0x2   0x2009             MOVS     R0,#+9
   1322          
   1323            /* Set the OPTSTRT bit in OPTCR register */
   1324            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
   \        0x4   0x....             LDR.N    R0,??DataTable38_6  ;; 0x40023c14
   \        0x6   0x7801             LDRB     R1,[R0, #+0]
   \        0x8   0xF051 0x0102      ORRS     R1,R1,#0x2
   \        0xC   0x7001             STRB     R1,[R0, #+0]
   1325          
   1326            /* Wait for last operation to be completed */
   1327            status = FLASH_WaitForLastOperation();
   \        0xE   0x....'....        BL       FLASH_WaitForLastOperation
   1328          
   1329            return status;
   \       0x12   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x14   0xBD02             POP      {R1,PC}          ;; return
   1330          }
   1331          
   1332          /**
   1333            * @brief  Returns the FLASH User Option Bytes values.
   1334            * @param  None
   1335            * @retval The FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1)
   1336            *         and RST_STDBY(Bit2).
   1337            */

   \                                 In section .text, align 2, keep-with-next
   1338          uint8_t FLASH_OB_GetUser(void)
   1339          {
   1340            /* Return the User Option Byte */
   1341            return (uint8_t)(FLASH->OPTCR >> 5);
   \                     FLASH_OB_GetUser: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable38_6  ;; 0x40023c14
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0940             LSRS     R0,R0,#+5
   \        0x6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x8   0x4770             BX       LR               ;; return
   1342          }
   1343          
   1344          /**
   1345            * @brief  Returns the FLASH Write Protection Option Bytes value.
   1346            * @param  None
   1347            * @retval The FLASH Write Protection  Option Bytes value
   1348            */

   \                                 In section .text, align 2, keep-with-next
   1349          uint16_t FLASH_OB_GetWRP(void)
   1350          {
   1351            /* Return the FLASH write protection Register value */
   1352            return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
   \                     FLASH_OB_GetWRP: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable38_10  ;; 0x40023c16
   \        0x2   0x8800             LDRH     R0,[R0, #+0]
   \        0x4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \        0x6   0x4770             BX       LR               ;; return
   1353          }
   1354          
   1355          /**
   1356            * @brief  Returns the FLASH Write Protection Option Bytes value.
   1357            *   
   1358            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1359            *   
   1360            * @param  None
   1361            * @retval The FLASH Write Protection  Option Bytes value
   1362            */

   \                                 In section .text, align 2, keep-with-next
   1363          uint16_t FLASH_OB_GetWRP1(void)
   1364          {
   1365            /* Return the FLASH write protection Register value */
   1366            return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
   \                     FLASH_OB_GetWRP1: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable38_11  ;; 0x40023c1a
   \        0x2   0x8800             LDRH     R0,[R0, #+0]
   \        0x4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \        0x6   0x4770             BX       LR               ;; return
   1367          }
   1368          
   1369          /**
   1370            * @brief  Returns the FLASH PC Read/Write Protection Option Bytes value.
   1371            *   
   1372            * @note   This function can be used only for STM32F42xxx/43xxx devices and STM32F401xx/411xE devices.
   1373            *   
   1374            * @param  None
   1375            * @retval The FLASH PC Read/Write Protection Option Bytes value
   1376            */

   \                                 In section .text, align 2, keep-with-next
   1377          uint16_t FLASH_OB_GetPCROP(void)
   1378          {
   1379            /* Return the FLASH PC Read/write protection Register value */
   1380            return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
   \                     FLASH_OB_GetPCROP: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable38_10  ;; 0x40023c16
   \        0x2   0x8800             LDRH     R0,[R0, #+0]
   \        0x4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \        0x6   0x4770             BX       LR               ;; return
   1381          }
   1382          
   1383          /**
   1384            * @brief  Returns the FLASH PC Read/Write Protection Option Bytes value.
   1385            *   
   1386            * @note   This function can be used only for STM32F42xxx/43xxx devices. 
   1387            *     
   1388            * @param  None
   1389            * @retval The FLASH PC Read/Write Protection Option Bytes value
   1390            */

   \                                 In section .text, align 2, keep-with-next
   1391          uint16_t FLASH_OB_GetPCROP1(void)
   1392          {
   1393            /* Return the FLASH write protection Register value */
   1394            return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
   \                     FLASH_OB_GetPCROP1: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable38_11  ;; 0x40023c1a
   \        0x2   0x8800             LDRH     R0,[R0, #+0]
   \        0x4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \        0x6   0x4770             BX       LR               ;; return
   1395          }
   1396          
   1397          /**
   1398            * @brief  Returns the FLASH Read Protection level.
   1399            * @param  None
   1400            * @retval FLASH ReadOut Protection Status:
   1401            *           - SET, when OB_RDP_Level_1 or OB_RDP_Level_2 is set
   1402            *           - RESET, when OB_RDP_Level_0 is set
   1403            */

   \                                 In section .text, align 2, keep-with-next
   1404          FlagStatus FLASH_OB_GetRDP(void)
   1405          {
   1406            FlagStatus readstatus = RESET;
   \                     FLASH_OB_GetRDP: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   1407          
   1408            if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
   \        0x2   0x....             LDR.N    R0,??DataTable38_13  ;; 0x40023c15
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x8   0x28AA             CMP      R0,#+170
   \        0xA   0xD001             BEQ.N    ??FLASH_OB_GetRDP_0
   1409            {
   1410              readstatus = SET;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE000             B.N      ??FLASH_OB_GetRDP_1
   1411            }
   1412            else
   1413            {
   1414              readstatus = RESET;
   \                     ??FLASH_OB_GetRDP_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   1415            }
   1416            return readstatus;
   \                     ??FLASH_OB_GetRDP_1: (+1)
   \       0x12   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x14   0x4770             BX       LR               ;; return
   1417          }
   1418          
   1419          /**
   1420            * @brief  Returns the FLASH BOR level.
   1421            * @param  None
   1422            * @retval The FLASH BOR level:
   1423            *           - OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
   1424            *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
   1425            *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
   1426            *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
   1427            */

   \                                 In section .text, align 2, keep-with-next
   1428          uint8_t FLASH_OB_GetBOR(void)
   1429          {
   1430            /* Return the FLASH BOR level */
   1431            return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
   \                     FLASH_OB_GetBOR: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable38_6  ;; 0x40023c14
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0xF010 0x000C      ANDS     R0,R0,#0xC
   \        0x8   0x4770             BX       LR               ;; return
   1432          }
   1433          
   1434          /**
   1435            * @}
   1436            */
   1437          
   1438          /** @defgroup FLASH_Group4 Interrupts and flags management functions
   1439           *  @brief   Interrupts and flags management functions
   1440           *
   1441          @verbatim   
   1442           ===============================================================================
   1443                        ##### Interrupts and flags management functions #####
   1444           ===============================================================================  
   1445          @endverbatim
   1446            * @{
   1447            */
   1448          
   1449          /**
   1450            * @brief  Enables or disables the specified FLASH interrupts.
   1451            * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
   1452            *          This parameter can be any combination of the following values:
   1453            *            @arg FLASH_IT_ERR: FLASH Error Interrupt
   1454            *            @arg FLASH_IT_EOP: FLASH end of operation Interrupt
   1455            * @retval None 
   1456            */

   \                                 In section .text, align 2, keep-with-next
   1457          void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
   1458          {
   1459            /* Check the parameters */
   1460            assert_param(IS_FLASH_IT(FLASH_IT)); 
   1461            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1462          
   1463            if(NewState != DISABLE)
   \                     FLASH_ITConfig: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??FLASH_ITConfig_0
   1464            {
   1465              /* Enable the interrupt sources */
   1466              FLASH->CR |= FLASH_IT;
   \        0x6   0x....             LDR.N    R1,??DataTable38_1  ;; 0x40023c10
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0x4310             ORRS     R0,R0,R2
   \        0xC   0x6008             STR      R0,[R1, #+0]
   \        0xE   0xE004             B.N      ??FLASH_ITConfig_1
   1467            }
   1468            else
   1469            {
   1470              /* Disable the interrupt sources */
   1471              FLASH->CR &= ~(uint32_t)FLASH_IT;
   \                     ??FLASH_ITConfig_0: (+1)
   \       0x10   0x....             LDR.N    R1,??DataTable38_1  ;; 0x40023c10
   \       0x12   0x680A             LDR      R2,[R1, #+0]
   \       0x14   0xEA32 0x0000      BICS     R0,R2,R0
   \       0x18   0x6008             STR      R0,[R1, #+0]
   1472            }
   1473          }
   \                     ??FLASH_ITConfig_1: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
   1474          
   1475          /**
   1476            * @brief  Checks whether the specified FLASH flag is set or not.
   1477            * @param  FLASH_FLAG: specifies the FLASH flag to check.
   1478            *          This parameter can be one of the following values:
   1479            *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
   1480            *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
   1481            *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
   1482            *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
   1483            *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
   1484            *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
   1485            *            @arg FLASH_FLAG_RDERR: FLASH (PCROP) Read Protection error flag (STM32F42xx/43xxx and STM32F401xx/411xE devices) 
   1486            *            @arg FLASH_FLAG_BSY: FLASH Busy flag
   1487            * @retval The new state of FLASH_FLAG (SET or RESET).
   1488            */

   \                                 In section .text, align 2, keep-with-next
   1489          FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
   1490          {
   1491            FlagStatus bitstatus = RESET;
   \                     FLASH_GetFlagStatus: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   1492            /* Check the parameters */
   1493            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
   1494          
   1495            if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
   \        0x2   0x....             LDR.N    R1,??DataTable38_14  ;; 0x40023c0c
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0x4201             TST      R1,R0
   \        0x8   0xD001             BEQ.N    ??FLASH_GetFlagStatus_0
   1496            {
   1497              bitstatus = SET;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??FLASH_GetFlagStatus_1
   1498            }
   1499            else
   1500            {
   1501              bitstatus = RESET;
   \                     ??FLASH_GetFlagStatus_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   1502            }
   1503            /* Return the new state of FLASH_FLAG (SET or RESET) */
   1504            return bitstatus; 
   \                     ??FLASH_GetFlagStatus_1: (+1)
   \       0x10   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x12   0x4770             BX       LR               ;; return
   1505          }
   1506          
   1507          /**
   1508            * @brief  Clears the FLASH's pending flags.
   1509            * @param  FLASH_FLAG: specifies the FLASH flags to clear.
   1510            *          This parameter can be any combination of the following values:
   1511            *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
   1512            *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
   1513            *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
   1514            *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag 
   1515            *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
   1516            *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
   1517            *            @arg FLASH_FLAG_RDERR: FLASH Read Protection error flag (STM32F42xx/43xxx and STM32F401xx/411xE devices)   
   1518            * @retval None
   1519            */

   \                                 In section .text, align 2, keep-with-next
   1520          void FLASH_ClearFlag(uint32_t FLASH_FLAG)
   1521          {
   1522            /* Check the parameters */
   1523            assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
   1524            
   1525            /* Clear the flags */
   1526            FLASH->SR = FLASH_FLAG;
   \                     FLASH_ClearFlag: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable38_14  ;; 0x40023c0c
   \        0x2   0x6008             STR      R0,[R1, #+0]
   1527          }
   \        0x4   0x4770             BX       LR               ;; return
   1528          
   1529          /**
   1530            * @brief  Returns the FLASH Status.
   1531            * @param  None
   1532            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
   1533            *                       FLASH_ERROR_WRP, FLASH_ERROR_RD, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
   1534            */

   \                                 In section .text, align 2, keep-with-next
   1535          FLASH_Status FLASH_GetStatus(void)
   1536          {
   1537            FLASH_Status flashstatus = FLASH_COMPLETE;
   \                     FLASH_GetStatus: (+1)
   \        0x0   0x2009             MOVS     R0,#+9
   1538            
   1539            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   \        0x2   0x....             LDR.N    R0,??DataTable38_14  ;; 0x40023c0c
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x03C9             LSLS     R1,R1,#+15
   \        0x8   0xD501             BPL.N    ??FLASH_GetStatus_0
   1540            {
   1541              flashstatus = FLASH_BUSY;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE015             B.N      ??FLASH_GetStatus_1
   1542            }
   1543            else 
   1544            {  
   1545              if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_0: (+1)
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x06C9             LSLS     R1,R1,#+27
   \       0x12   0xD501             BPL.N    ??FLASH_GetStatus_2
   1546              { 
   1547                flashstatus = FLASH_ERROR_WRP;
   \       0x14   0x2006             MOVS     R0,#+6
   \       0x16   0xE010             B.N      ??FLASH_GetStatus_1
   1548              }
   1549              else
   1550              {
   1551                if((FLASH->SR & FLASH_FLAG_RDERR) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_2: (+1)
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0x05C9             LSLS     R1,R1,#+23
   \       0x1C   0xD501             BPL.N    ??FLASH_GetStatus_3
   1552                { 
   1553                  flashstatus = FLASH_ERROR_RD;
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0xE00B             B.N      ??FLASH_GetStatus_1
   1554                } 
   1555                else 
   1556                {
   1557                  if((FLASH->SR & (uint32_t)0xE0) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_3: (+1)
   \       0x22   0x6801             LDR      R1,[R0, #+0]
   \       0x24   0xF011 0x0FE0      TST      R1,#0xE0
   \       0x28   0xD001             BEQ.N    ??FLASH_GetStatus_4
   1558                  {
   1559                    flashstatus = FLASH_ERROR_PROGRAM; 
   \       0x2A   0x2007             MOVS     R0,#+7
   \       0x2C   0xE005             B.N      ??FLASH_GetStatus_1
   1560                  }
   1561                  else
   1562                  {
   1563                    if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_4: (+1)
   \       0x2E   0x6800             LDR      R0,[R0, #+0]
   \       0x30   0x0780             LSLS     R0,R0,#+30
   \       0x32   0xD501             BPL.N    ??FLASH_GetStatus_5
   1564                    {
   1565                      flashstatus = FLASH_ERROR_OPERATION;
   \       0x34   0x2008             MOVS     R0,#+8
   \       0x36   0xE000             B.N      ??FLASH_GetStatus_1
   1566                    }
   1567                    else
   1568                    {
   1569                      flashstatus = FLASH_COMPLETE;
   \                     ??FLASH_GetStatus_5: (+1)
   \       0x38   0x2009             MOVS     R0,#+9
   1570                    }
   1571                  }
   1572                }
   1573              }
   1574            }
   1575            /* Return the FLASH Status */
   1576            return flashstatus;
   \                     ??FLASH_GetStatus_1: (+1)
   \       0x3A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x3C   0x4770             BX       LR               ;; return
   1577          }
   1578          
   1579          /**
   1580            * @brief  Waits for a FLASH operation to complete.
   1581            * @param  None
   1582            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
   1583            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
   1584            */

   \                                 In section .text, align 2, keep-with-next
   1585          FLASH_Status FLASH_WaitForLastOperation(void)
   1586          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1587            __IO FLASH_Status status = FLASH_COMPLETE;
   \        0x2   0x2009             MOVS     R0,#+9
   \        0x4   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1588             
   1589            /* Check for the FLASH Status */
   1590            status = FLASH_GetStatus();
   \        0x8   0x....'....        BL       FLASH_GetStatus
   \        0xC   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x10   0xE003             B.N      ??FLASH_WaitForLastOperation_0
   1591          
   1592            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
   1593               Even if the FLASH operation fails, the BUSY flag will be reset and an error
   1594               flag will be set */
   1595            while(status == FLASH_BUSY)
   1596            {
   1597              status = FLASH_GetStatus();
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \       0x12   0x....'....        BL       FLASH_GetStatus
   \       0x16   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1598            }
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \       0x1A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD0F7             BEQ.N    ??FLASH_WaitForLastOperation_1
   1599            /* Return the operation status */
   1600            return status;
   \       0x22   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x26   0xBD02             POP      {R1,PC}          ;; return
   1601          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \        0x0   0x4002'3C00        DC32     0x40023c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \        0x0   0x4002'3C10        DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_2:
   \        0x0   0x4002'3C04        DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_3:
   \        0x0   0x4567'0123        DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_4:
   \        0x0   0xCDEF'89AB        DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_5:
   \        0x0   0xFFFF'7FFB        DC32     0xffff7ffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_6:
   \        0x0   0x4002'3C14        DC32     0x40023c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_7:
   \        0x0   0x4002'3C08        DC32     0x40023c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_8:
   \        0x0   0x0819'2A3B        DC32     0x8192a3b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_9:
   \        0x0   0x4C5D'6E7F        DC32     0x4c5d6e7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_10:
   \        0x0   0x4002'3C16        DC32     0x40023c16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_11:
   \        0x0   0x4002'3C1A        DC32     0x40023c1a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_12:
   \        0x0   0x4002'3C17        DC32     0x40023c17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_13:
   \        0x0   0x4002'3C15        DC32     0x40023c15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_14:
   \        0x0   0x4002'3C0C        DC32     0x40023c0c
   1602          
   1603          /**
   1604            * @}
   1605            */ 
   1606          
   1607          /**
   1608            * @}
   1609            */ 
   1610          
   1611          /**
   1612            * @}
   1613            */ 
   1614          
   1615          /**
   1616            * @}
   1617            */
   1618          
   1619          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_ClearFlag
       0   FLASH_DataCacheCmd
       0   FLASH_DataCacheReset
       8   FLASH_EraseAllBank1Sectors
         8   -> FLASH_WaitForLastOperation
       8   FLASH_EraseAllBank2Sectors
         8   -> FLASH_WaitForLastOperation
       8   FLASH_EraseAllSectors
         8   -> FLASH_WaitForLastOperation
      16   FLASH_EraseSector
        16   -> FLASH_WaitForLastOperation
       0   FLASH_GetFlagStatus
       0   FLASH_GetStatus
       0   FLASH_ITConfig
       0   FLASH_InstructionCacheCmd
       0   FLASH_InstructionCacheReset
       0   FLASH_Lock
       0   FLASH_OB_BORConfig
       0   FLASH_OB_BootConfig
       0   FLASH_OB_GetBOR
       0   FLASH_OB_GetPCROP
       0   FLASH_OB_GetPCROP1
       0   FLASH_OB_GetRDP
       0   FLASH_OB_GetUser
       0   FLASH_OB_GetWRP
       0   FLASH_OB_GetWRP1
       8   FLASH_OB_Launch
         8   -> FLASH_WaitForLastOperation
       0   FLASH_OB_Lock
      16   FLASH_OB_PCROP1Config
        16   -> FLASH_WaitForLastOperation
      16   FLASH_OB_PCROPConfig
        16   -> FLASH_WaitForLastOperation
       0   FLASH_OB_PCROPSelectionConfig
       8   FLASH_OB_RDPConfig
         8   -> FLASH_WaitForLastOperation
       0   FLASH_OB_Unlock
      16   FLASH_OB_UserConfig
        16   -> FLASH_WaitForLastOperation
      16   FLASH_OB_WRP1Config
        16   -> FLASH_WaitForLastOperation
      16   FLASH_OB_WRPConfig
        16   -> FLASH_WaitForLastOperation
       0   FLASH_PrefetchBufferCmd
      16   FLASH_ProgramByte
        16   -> FLASH_WaitForLastOperation
      24   FLASH_ProgramDoubleWord
        24   -> FLASH_WaitForLastOperation
      16   FLASH_ProgramHalfWord
        16   -> FLASH_WaitForLastOperation
      16   FLASH_ProgramWord
        16   -> FLASH_WaitForLastOperation
       0   FLASH_SetLatency
       0   FLASH_Unlock
       8   FLASH_WaitForLastOperation
         8   -> FLASH_GetStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_10
       4  ??DataTable38_11
       4  ??DataTable38_12
       4  ??DataTable38_13
       4  ??DataTable38_14
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable38_4
       4  ??DataTable38_5
       4  ??DataTable38_6
       4  ??DataTable38_7
       4  ??DataTable38_8
       4  ??DataTable38_9
       6  FLASH_ClearFlag
      34  FLASH_DataCacheCmd
      14  FLASH_DataCacheReset
     112  FLASH_EraseAllBank1Sectors
     112  FLASH_EraseAllBank2Sectors
     118  FLASH_EraseAllSectors
     130  FLASH_EraseSector
      20  FLASH_GetFlagStatus
      62  FLASH_GetStatus
      28  FLASH_ITConfig
      34  FLASH_InstructionCacheCmd
      14  FLASH_InstructionCacheReset
      14  FLASH_Lock
      18  FLASH_OB_BORConfig
      18  FLASH_OB_BootConfig
      10  FLASH_OB_GetBOR
       8  FLASH_OB_GetPCROP
       8  FLASH_OB_GetPCROP1
      22  FLASH_OB_GetRDP
      10  FLASH_OB_GetUser
       8  FLASH_OB_GetWRP
       8  FLASH_OB_GetWRP1
      22  FLASH_OB_Launch
      12  FLASH_OB_Lock
      46  FLASH_OB_PCROP1Config
      46  FLASH_OB_PCROPConfig
      16  FLASH_OB_PCROPSelectionConfig
      22  FLASH_OB_RDPConfig
      20  FLASH_OB_Unlock
      40  FLASH_OB_UserConfig
      46  FLASH_OB_WRP1Config
      46  FLASH_OB_WRPConfig
      34  FLASH_PrefetchBufferCmd
      60  FLASH_ProgramByte
      68  FLASH_ProgramDoubleWord
      64  FLASH_ProgramHalfWord
      64  FLASH_ProgramWord
       8  FLASH_SetLatency
      28  FLASH_Unlock
      40  FLASH_WaitForLastOperation

 
 1'550 bytes in section .text
 
 1'550 bytes of CODE memory

Errors: none
Warnings: none
