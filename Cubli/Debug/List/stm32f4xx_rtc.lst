###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.2.214/W32 for ARM         10/Jul/2020  15:12:10
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rtc.c
#    Command line =
#        -f C:\Users\Evan\AppData\Local\Temp\EWF475.tmp
#        (E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rtc.c
#        -D USE_STDPERIPH_DRIVER -D STM32F429_439xx -lC
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List
#        -o
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "D:\IAR
#        Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\iar\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\User\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\User\src\
#        -Ol --use_c++_inline -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List\stm32f4xx_rtc.lst
#    Object file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj\stm32f4xx_rtc.o
#
###############################################################################

E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rtc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_rtc.c
      4            * @author  MCD Application Team
      5            * @version V1.8.0
      6            * @date    04-November-2016
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Real-Time Clock (RTC) peripheral:
      9            *           + Initialization
     10            *           + Calendar (Time and Date) configuration
     11            *           + Alarms (Alarm A and Alarm B) configuration
     12            *           + WakeUp Timer configuration
     13            *           + Daylight Saving configuration
     14            *           + Output pin Configuration
     15            *           + Coarse digital Calibration configuration
     16            *           + Smooth digital Calibration configuration
     17            *           + TimeStamp configuration
     18            *           + Tampers configuration
     19            *           + Backup Data Registers configuration
     20            *           + Shift control synchronisation    
     21            *           + RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration
     22            *           + Interrupts and flags management
     23            *
     24          @verbatim
     25          
     26           ===================================================================
     27                        ##### Backup Domain Operating Condition #####
     28           ===================================================================
     29           [..] The real-time clock (RTC), the RTC backup registers, and the backup 
     30                SRAM (BKP SRAM) can be powered from the VBAT voltage when the main 
     31                VDD supply is powered off.
     32                To retain the content of the RTC backup registers, backup SRAM, and supply 
     33                the RTC when VDD is turned off, VBAT pin can be connected to an optional 
     34                standby voltage supplied by a battery or by another source.
     35          
     36           [..] To allow the RTC to operate even when the main digital supply (VDD) is turned
     37                off, the VBAT pin powers the following blocks:
     38             (#) The RTC
     39             (#) The LSE oscillator
     40             (#) The backup SRAM when the low power backup regulator is enabled
     41             (#) PC13 to PC15 I/Os, plus PI8 I/O (when available)
     42            
     43           [..] When the backup domain is supplied by VDD (analog switch connected to VDD),
     44                the following functions are available:
     45             (#) PC14 and PC15 can be used as either GPIO or LSE pins
     46             (#) PC13 can be used as a GPIO or as the RTC_AF1 pin
     47             (#) PI8 can be used as a GPIO or as the RTC_AF2 pin
     48            
     49           [..] When the backup domain is supplied by VBAT (analog switch connected to VBAT 
     50                because VDD is not present), the following functions are available:
     51             (#) PC14 and PC15 can be used as LSE pins only
     52             (#) PC13 can be used as the RTC_AF1 pin 
     53             (#) PI8 can be used as the RTC_AF2 pin
     54            
     55                      
     56                             ##### Backup Domain Reset #####
     57           ===================================================================
     58           [..] The backup domain reset sets all RTC registers and the RCC_BDCR register 
     59                to their reset values. The BKPSRAM is not affected by this reset. The only
     60                way of resetting the BKPSRAM is through the Flash interface by requesting 
     61                a protection level change from 1 to 0.
     62           [..] A backup domain reset is generated when one of the following events occurs:
     63             (#) Software reset, triggered by setting the BDRST bit in the 
     64                 RCC Backup domain control register (RCC_BDCR). You can use the
     65                 RCC_BackupResetCmd().
     66             (#) VDD or VBAT power on, if both supplies have previously been powered off.
     67            
     68          
     69                             ##### Backup Domain Access #####
     70           ===================================================================
     71           [..] After reset, the backup domain (RTC registers, RTC backup data 
     72                registers and backup SRAM) is protected against possible unwanted write 
     73                accesses. 
     74           [..] To enable access to the RTC Domain and RTC registers, proceed as follows:
     75             (+) Enable the Power Controller (PWR) APB1 interface clock using the
     76                 RCC_APB1PeriphClockCmd() function.
     77             (+) Enable access to RTC domain using the PWR_BackupAccessCmd() function.
     78             (+) Select the RTC clock source using the RCC_RTCCLKConfig() function.
     79             (+) Enable RTC Clock using the RCC_RTCCLKCmd() function.
     80            
     81            
     82                            ##### How to use RTC Driver #####
     83           ===================================================================
     84           [..] 
     85             (+) Enable the RTC domain access (see description in the section above)
     86             (+) Configure the RTC Prescaler (Asynchronous and Synchronous) and RTC hour 
     87                 format using the RTC_Init() function.
     88            
     89           *** Time and Date configuration ***
     90           ===================================
     91           [..] 
     92             (+) To configure the RTC Calendar (Time and Date) use the RTC_SetTime()
     93                 and RTC_SetDate() functions.
     94             (+) To read the RTC Calendar, use the RTC_GetTime() and RTC_GetDate() functions.
     95             (+) Use the RTC_DayLightSavingConfig() function to add or sub one
     96                 hour to the RTC Calendar.    
     97            
     98           *** Alarm configuration ***
     99           ===========================
    100           [..]
    101             (+) To configure the RTC Alarm use the RTC_SetAlarm() function.
    102             (+) Enable the selected RTC Alarm using the RTC_AlarmCmd() function
    103             (+) To read the RTC Alarm, use the RTC_GetAlarm() function.
    104             (+) To read the RTC alarm SubSecond, use the RTC_GetAlarmSubSecond() function.
    105            
    106           *** RTC Wakeup configuration ***
    107           ================================
    108           [..] 
    109             (+) Configure the RTC Wakeup Clock source use the RTC_WakeUpClockConfig()
    110                 function.
    111             (+) Configure the RTC WakeUp Counter using the RTC_SetWakeUpCounter() function  
    112             (+) Enable the RTC WakeUp using the RTC_WakeUpCmd() function  
    113             (+) To read the RTC WakeUp Counter register, use the RTC_GetWakeUpCounter() 
    114                 function.
    115            
    116           *** Outputs configuration ***
    117           =============================
    118           [..] The RTC has 2 different outputs:
    119             (+) AFO_ALARM: this output is used to manage the RTC Alarm A, Alarm B
    120                 and WaKeUp signals. To output the selected RTC signal on RTC_AF1 pin, use the 
    121                 RTC_OutputConfig() function.                
    122             (+) AFO_CALIB: this output is 512Hz signal or 1Hz. To output the RTC Clock on 
    123                 RTC_AF1 pin, use the RTC_CalibOutputCmd() function.
    124            
    125           *** Smooth digital Calibration configuration ***
    126           ================================================    
    127           [..]
    128             (+) Configure the RTC Original Digital Calibration Value and the corresponding
    129                 calibration cycle period (32s,16s and 8s) using the RTC_SmoothCalibConfig() 
    130                 function.
    131            
    132           *** Coarse digital Calibration configuration ***
    133           ================================================
    134           [..]
    135             (+) Configure the RTC Coarse Calibration Value and the corresponding
    136                 sign using the RTC_CoarseCalibConfig() function.
    137             (+) Enable the RTC Coarse Calibration using the RTC_CoarseCalibCmd() function  
    138            
    139           *** TimeStamp configuration ***
    140           ===============================
    141           [..]
    142             (+) Configure the RTC_AF1 trigger and enables the RTC TimeStamp using the RTC
    143                _TimeStampCmd() function.
    144             (+) To read the RTC TimeStamp Time and Date register, use the RTC_GetTimeStamp()
    145                 function.
    146             (+) To read the RTC TimeStamp SubSecond register, use the 
    147                 RTC_GetTimeStampSubSecond() function.
    148             (+) The TAMPER1 alternate function can be mapped either to RTC_AF1(PC13)
    149                 or RTC_AF2 (PI8) depending on the value of TAMP1INSEL bit in 
    150                 RTC_TAFCR register. You can use the  RTC_TamperPinSelection() function to
    151                 select the corresponding pin.     
    152            
    153           *** Tamper configuration ***
    154           ============================
    155           [..]
    156             (+) Enable the RTC Tamper using the RTC_TamperCmd() function.
    157             (+) Configure the Tamper filter count using RTC_TamperFilterConfig()
    158                 function. 
    159             (+) Configure the RTC Tamper trigger Edge or Level according to the Tamper 
    160                 filter (if equal to 0 Edge else Level) value using the RTC_TamperConfig() 
    161                 function.
    162             (+) Configure the Tamper sampling frequency using RTC_TamperSamplingFreqConfig()
    163                 function.
    164             (+) Configure the Tamper precharge or discharge duration using 
    165                 RTC_TamperPinsPrechargeDuration() function.
    166             (+) Enable the Tamper Pull-UP using RTC_TamperPullUpDisableCmd() function.
    167             (+) Enable the Time stamp on Tamper detection event using  
    168                 TC_TSOnTamperDetecCmd() function.
    169             (+) The TIMESTAMP alternate function can be mapped to either RTC_AF1 
    170                 or RTC_AF2 depending on the value of the TSINSEL bit in the RTC_TAFCR 
    171                 register. You can use the  RTC_TimeStampPinSelection() function to select 
    172                 the corresponding pin. 
    173            
    174           *** Backup Data Registers configuration ***
    175           ===========================================
    176           [..]
    177             (+) To write to the RTC Backup Data registers, use the RTC_WriteBackupRegister()
    178                 function.  
    179             (+) To read the RTC Backup Data registers, use the RTC_ReadBackupRegister()
    180                 function.
    181             
    182          
    183                            ##### RTC and low power modes #####
    184           ===================================================================
    185           [..] The MCU can be woken up from a low power mode by an RTC alternate 
    186                function.
    187           [..] The RTC alternate functions are the RTC alarms (Alarm A and Alarm B), 
    188                RTC wakeup, RTC tamper event detection and RTC time stamp event detection.
    189                These RTC alternate functions can wake up the system from the Stop and 
    190                Standby lowpower modes.
    191           [..] The system can also wake up from low power modes without depending 
    192                on an external interrupt (Auto-wakeup mode), by using the RTC alarm 
    193                or the RTC wakeup events.
    194           [..] The RTC provides a programmable time base for waking up from the 
    195                Stop or Standby mode at regular intervals.
    196                Wakeup from STOP and Standby modes is possible only when the RTC clock source
    197                is LSE or LSI.
    198            
    199          
    200                    ##### Selection of RTC_AF1 alternate functions #####
    201           ===================================================================
    202           [..] The RTC_AF1 pin (PC13) can be used for the following purposes:
    203             (+) AFO_ALARM output
    204             (+) AFO_CALIB output
    205             (+) AFI_TAMPER
    206             (+) AFI_TIMESTAMP
    207           
    208           [..]   
    209             +-------------------------------------------------------------------------------------------------------------+
    210             |     Pin         |AFO_ALARM |AFO_CALIB |AFI_TAMPER |AFI_TIMESTAMP | TAMP1INSEL |   TSINSEL    |ALARMOUTTYPE  |
    211             |  configuration  | ENABLED  | ENABLED  |  ENABLED  |   ENABLED    |TAMPER1 pin |TIMESTAMP pin |  AFO_ALARM   |
    212             |  and function   |          |          |           |              | selection  |  selection   |Configuration |
    213             |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    214             |   Alarm out     |          |          |           |              |    Don't   |     Don't    |              |
    215             |   output OD     |     1    |Don't care|Don't care | Don't care   |    care    |     care     |      0       |
    216             |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    217             |   Alarm out     |          |          |           |              |    Don't   |     Don't    |              |
    218             |   output PP     |     1    |Don't care|Don't care | Don't care   |    care    |     care     |      1       |
    219             |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    220             | Calibration out |          |          |           |              |    Don't   |     Don't    |              |
    221             |   output PP     |     0    |    1     |Don't care | Don't care   |    care    |     care     |  Don't care  |
    222             |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    223             |  TAMPER input   |          |          |           |              |            |     Don't    |              |
    224             |   floating      |     0    |    0     |     1     |      0       |      0     |     care     |  Don't care  |
    225             |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    226             |  TIMESTAMP and  |          |          |           |              |            |              |              |
    227             |  TAMPER input   |     0    |    0     |     1     |      1       |      0     |      0       |  Don't care  |
    228             |   floating      |          |          |           |              |            |              |              |
    229             |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    230             | TIMESTAMP input |          |          |           |              |    Don't   |              |              |
    231             |    floating     |     0    |    0     |     0     |      1       |    care    |      0       |  Don't care  |
    232             |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    233             |  Standard GPIO  |     0    |    0     |     0     |      0       | Don't care |  Don't care  |  Don't care  |
    234             +-------------------------------------------------------------------------------------------------------------+
    235          
    236                      
    237                  #####  Selection of RTC_AF2 alternate functions #####
    238           ===================================================================
    239           [..] The RTC_AF2 pin (PI8) can be used for the following purposes:
    240             (+) AFI_TAMPER
    241             (+) AFI_TIMESTAMP
    242           [..]
    243             +---------------------------------------------------------------------------------------+
    244             |     Pin         |AFI_TAMPER |AFI_TIMESTAMP | TAMP1INSEL |   TSINSEL    |ALARMOUTTYPE  |
    245             |  configuration  |  ENABLED  |   ENABLED    |TAMPER1 pin |TIMESTAMP pin |  AFO_ALARM   |
    246             |  and function   |           |              | selection  |  selection   |Configuration |
    247             |-----------------|-----------|--------------|------------|--------------|--------------|
    248             |  TAMPER input   |           |              |            |     Don't    |              |
    249             |   floating      |     1     |      0       |      1     |     care     |  Don't care  |
    250             |-----------------|-----------|--------------|------------|--------------|--------------|
    251             |  TIMESTAMP and  |           |              |            |              |              |
    252             |  TAMPER input   |     1     |      1       |      1     |      1       |  Don't care  |
    253             |   floating      |           |              |            |              |              |
    254             |-----------------|-----------|--------------|------------|--------------|--------------|
    255             | TIMESTAMP input |           |              |    Don't   |              |              |
    256             |    floating     |     0     |      1       |    care    |      1       |  Don't care  |
    257             |-----------------|-----------|--------------|------------|--------------|--------------|
    258             |  Standard GPIO  |     0     |      0       | Don't care |  Don't care  |  Don't care  |
    259             +---------------------------------------------------------------------------------------+   
    260           
    261               
    262          @endverbatim
    263            
    264            ******************************************************************************
    265            * @attention
    266            *
    267            * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
    268            *
    269            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    270            * You may not use this file except in compliance with the License.
    271            * You may obtain a copy of the License at:
    272            *
    273            *        http://www.st.com/software_license_agreement_liberty_v2
    274            *
    275            * Unless required by applicable law or agreed to in writing, software 
    276            * distributed under the License is distributed on an "AS IS" BASIS, 
    277            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    278            * See the License for the specific language governing permissions and
    279            * limitations under the License.
    280            *
    281            ******************************************************************************
    282            */ 
    283          
    284          /* Includes ------------------------------------------------------------------*/
    285          #include "stm32f4xx_rtc.h"
    286          
    287          /** @addtogroup STM32F4xx_StdPeriph_Driver
    288            * @{
    289            */
    290          
    291          /** @defgroup RTC 
    292            * @brief RTC driver modules
    293            * @{
    294            */
    295          
    296          /* Private typedef -----------------------------------------------------------*/
    297          /* Private define ------------------------------------------------------------*/
    298          
    299          /* Masks Definition */
    300          #define RTC_TR_RESERVED_MASK    ((uint32_t)0x007F7F7F)
    301          #define RTC_DR_RESERVED_MASK    ((uint32_t)0x00FFFF3F) 
    302          #define RTC_INIT_MASK           ((uint32_t)0xFFFFFFFF)  
    303          #define RTC_RSF_MASK            ((uint32_t)0xFFFFFF5F)
    304          #define RTC_FLAGS_MASK          ((uint32_t)(RTC_FLAG_TSOVF | RTC_FLAG_TSF | RTC_FLAG_WUTF | \
    305                                                      RTC_FLAG_ALRBF | RTC_FLAG_ALRAF | RTC_FLAG_INITF | \
    306                                                      RTC_FLAG_RSF | RTC_FLAG_INITS | RTC_FLAG_WUTWF | \
    307                                                      RTC_FLAG_ALRBWF | RTC_FLAG_ALRAWF | RTC_FLAG_TAMP1F | \
    308                                                      RTC_FLAG_TAMP2F | RTC_FLAG_RECALPF | RTC_FLAG_SHPF))
    309          
    310          #define INITMODE_TIMEOUT         ((uint32_t) 0x00010000)
    311          #define SYNCHRO_TIMEOUT          ((uint32_t) 0x00020000)
    312          #define RECALPF_TIMEOUT          ((uint32_t) 0x00020000)
    313          #define SHPF_TIMEOUT             ((uint32_t) 0x00001000)
    314          
    315          /* Private macro -------------------------------------------------------------*/
    316          /* Private variables ---------------------------------------------------------*/
    317          /* Private function prototypes -----------------------------------------------*/
    318          static uint8_t RTC_ByteToBcd2(uint8_t Value);
    319          static uint8_t RTC_Bcd2ToByte(uint8_t Value);
    320          
    321          /* Private functions ---------------------------------------------------------*/
    322          
    323          /** @defgroup RTC_Private_Functions
    324            * @{
    325            */ 
    326          
    327          /** @defgroup RTC_Group1 Initialization and Configuration functions
    328           *  @brief   Initialization and Configuration functions 
    329           *
    330          @verbatim   
    331           ===============================================================================
    332                       ##### Initialization and Configuration functions #####
    333           ===============================================================================
    334           
    335           [..] This section provide functions allowing to initialize and configure the RTC
    336                Prescaler (Synchronous and Asynchronous), RTC Hour format, disable RTC registers
    337                Write protection, enter and exit the RTC initialization mode, RTC registers
    338                synchronization check and reference clock detection enable.
    339            
    340             (#) The RTC Prescaler is programmed to generate the RTC 1Hz time base. It is
    341                 split into 2 programmable prescalers to minimize power consumption.
    342                 (++) A 7-bit asynchronous prescaler and A 13-bit synchronous prescaler.
    343                 (++) When both prescalers are used, it is recommended to configure the 
    344                      asynchronous prescaler to a high value to minimize consumption.
    345          
    346             (#) All RTC registers are Write protected. Writing to the RTC registers
    347                 is enabled by writing a key into the Write Protection register, RTC_WPR.
    348          
    349             (#) To Configure the RTC Calendar, user application should enter initialization
    350                 mode. In this mode, the calendar counter is stopped and its value can be 
    351                 updated. When the initialization sequence is complete, the calendar restarts 
    352                 counting after 4 RTCCLK cycles.
    353          
    354             (#) To read the calendar through the shadow registers after Calendar initialization,
    355                 calendar update or after wakeup from low power modes the software must first 
    356                 clear the RSF flag. The software must then wait until it is set again before 
    357                 reading the calendar, which means that the calendar registers have been 
    358                 correctly copied into the RTC_TR and RTC_DR shadow registers.
    359                 The RTC_WaitForSynchro() function implements the above software sequence 
    360                 (RSF clear and RSF check).
    361          
    362          @endverbatim
    363            * @{
    364            */
    365          
    366          /**
    367            * @brief  Deinitializes the RTC registers to their default reset values.
    368            * @note   This function doesn't reset the RTC Clock source and RTC Backup Data
    369            *         registers.       
    370            * @param  None
    371            * @retval An ErrorStatus enumeration value:
    372            *          - SUCCESS: RTC registers are deinitialized
    373            *          - ERROR: RTC registers are not deinitialized
    374            */

   \                                 In section .text, align 2, keep-with-next
    375          ErrorStatus RTC_DeInit(void)
    376          {
   \                     RTC_DeInit: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    377            __IO uint32_t wutcounter = 0x00;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x9000             STR      R0,[SP, #+0]
    378            uint32_t wutwfstatus = 0x00;
   \        0x6   0x2000             MOVS     R0,#+0
    379            ErrorStatus status = ERROR;
   \        0x8   0x2000             MOVS     R0,#+0
    380            
    381            /* Disable the write protection for RTC registers */
    382            RTC->WPR = 0xCA;
   \        0xA   0x....'....        LDR.W    R4,??DataTable41  ;; 0x40002824
   \        0xE   0x20CA             MOVS     R0,#+202
   \       0x10   0x6020             STR      R0,[R4, #+0]
    383            RTC->WPR = 0x53;
   \       0x12   0x2053             MOVS     R0,#+83
   \       0x14   0x6020             STR      R0,[R4, #+0]
    384          
    385            /* Set Initialization mode */
    386            if (RTC_EnterInitMode() == ERROR)
   \       0x16   0x....'....        BL       RTC_EnterInitMode
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD101             BNE.N    ??RTC_DeInit_0
    387            {
    388              status = ERROR;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xE057             B.N      ??RTC_DeInit_1
    389            }  
    390            else
    391            {
    392              /* Reset TR, DR and CR registers */
    393              RTC->TR = (uint32_t)0x00000000;
   \                     ??RTC_DeInit_0: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x....'....        LDR.W    R1,??DataTable42  ;; 0x40002800
   \       0x28   0x6008             STR      R0,[R1, #+0]
    394              RTC->DR = (uint32_t)0x00002101;
   \       0x2A   0xF242 0x1001      MOVW     R0,#+8449
   \       0x2E   0x....'....        LDR.W    R1,??DataTable43  ;; 0x40002804
   \       0x32   0x6008             STR      R0,[R1, #+0]
    395              /* Reset All CR bits except CR[2:0] */
    396              RTC->CR &= (uint32_t)0x00000007;
   \       0x34   0x....'....        LDR.W    R2,??DataTable43_1  ;; 0x40002808
   \       0x38   0x6810             LDR      R0,[R2, #+0]
   \       0x3A   0xF010 0x0007      ANDS     R0,R0,#0x7
   \       0x3E   0x6010             STR      R0,[R2, #+0]
    397            
    398              /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    399              do
    400              {
    401                wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
   \                     ??RTC_DeInit_2: (+1)
   \       0x40   0x....'....        LDR.W    R1,??DataTable49  ;; 0x4000280c
   \       0x44   0x6808             LDR      R0,[R1, #+0]
   \       0x46   0xF010 0x0004      ANDS     R0,R0,#0x4
    402                wutcounter++;  
   \       0x4A   0x9B00             LDR      R3,[SP, #+0]
   \       0x4C   0x1C5B             ADDS     R3,R3,#+1
   \       0x4E   0x9300             STR      R3,[SP, #+0]
    403              } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
   \       0x50   0x9B00             LDR      R3,[SP, #+0]
   \       0x52   0xF5B3 0x3F80      CMP      R3,#+65536
   \       0x56   0xD001             BEQ.N    ??RTC_DeInit_3
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD0F1             BEQ.N    ??RTC_DeInit_2
    404              
    405              if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
   \                     ??RTC_DeInit_3: (+1)
   \       0x5C   0x6808             LDR      R0,[R1, #+0]
   \       0x5E   0x0740             LSLS     R0,R0,#+29
   \       0x60   0xD401             BMI.N    ??RTC_DeInit_4
    406              {
    407                status = ERROR;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xE035             B.N      ??RTC_DeInit_1
    408              }
    409              else
    410              {
    411                /* Reset all RTC CR register bits */
    412                RTC->CR &= (uint32_t)0x00000000;
   \                     ??RTC_DeInit_4: (+1)
   \       0x66   0x6810             LDR      R0,[R2, #+0]
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0x6010             STR      R0,[R2, #+0]
    413                RTC->WUTR = (uint32_t)0x0000FFFF;
   \       0x6C   0xF64F 0x70FF      MOVW     R0,#+65535
   \       0x70   0x....'....        LDR.W    R2,??DataTable44  ;; 0x40002814
   \       0x74   0x6010             STR      R0,[R2, #+0]
    414                RTC->PRER = (uint32_t)0x007F00FF;
   \       0x76   0x....'....        LDR.W    R0,??DataTable44_1  ;; 0x7f00ff
   \       0x7A   0x....'....        LDR.W    R2,??DataTable44_2  ;; 0x40002810
   \       0x7E   0x6010             STR      R0,[R2, #+0]
    415                RTC->CALIBR = (uint32_t)0x00000000;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x....'....        LDR.W    R2,??DataTable44_3  ;; 0x40002818
   \       0x86   0x6010             STR      R0,[R2, #+0]
    416                RTC->ALRMAR = (uint32_t)0x00000000;        
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0x....'....        LDR.W    R2,??DataTable44_4  ;; 0x4000281c
   \       0x8E   0x6010             STR      R0,[R2, #+0]
    417                RTC->ALRMBR = (uint32_t)0x00000000;
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0x....'....        LDR.W    R2,??DataTable44_5  ;; 0x40002820
   \       0x96   0x6010             STR      R0,[R2, #+0]
    418                RTC->SHIFTR = (uint32_t)0x00000000;
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0x....'....        LDR.W    R2,??DataTable44_6  ;; 0x4000282c
   \       0x9E   0x6010             STR      R0,[R2, #+0]
    419                RTC->CALR = (uint32_t)0x00000000;
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0x....'....        LDR.W    R2,??DataTable45  ;; 0x4000283c
   \       0xA6   0x6010             STR      R0,[R2, #+0]
    420                RTC->ALRMASSR = (uint32_t)0x00000000;
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0x....'....        LDR.W    R2,??DataTable45_1  ;; 0x40002844
   \       0xAE   0x6010             STR      R0,[R2, #+0]
    421                RTC->ALRMBSSR = (uint32_t)0x00000000;
   \       0xB0   0x2000             MOVS     R0,#+0
   \       0xB2   0x....'....        LDR.W    R2,??DataTable45_2  ;; 0x40002848
   \       0xB6   0x6010             STR      R0,[R2, #+0]
    422                
    423                /* Reset ISR register and exit initialization mode */
    424                RTC->ISR = (uint32_t)0x00000000;
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0x6008             STR      R0,[R1, #+0]
    425                
    426                /* Reset Tamper and alternate functions configuration register */
    427                RTC->TAFCR = 0x00000000;
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0x....'....        LDR.W    R1,??DataTable50  ;; 0x40002840
   \       0xC2   0x6008             STR      R0,[R1, #+0]
    428            
    429                if(RTC_WaitForSynchro() == ERROR)
   \       0xC4   0x....'....        BL       RTC_WaitForSynchro
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD101             BNE.N    ??RTC_DeInit_5
    430                {
    431                  status = ERROR;
   \       0xCC   0x2000             MOVS     R0,#+0
   \       0xCE   0xE000             B.N      ??RTC_DeInit_1
    432                }
    433                else
    434                {
    435                  status = SUCCESS;      
   \                     ??RTC_DeInit_5: (+1)
   \       0xD0   0x2001             MOVS     R0,#+1
    436                }
    437              }
    438            }
    439            
    440            /* Enable the write protection for RTC registers */
    441            RTC->WPR = 0xFF;  
   \                     ??RTC_DeInit_1: (+1)
   \       0xD2   0x21FF             MOVS     R1,#+255
   \       0xD4   0x6021             STR      R1,[R4, #+0]
    442            
    443            return status;
   \       0xD6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xD8   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    444          }
    445          
    446          /**
    447            * @brief  Initializes the RTC registers according to the specified parameters 
    448            *         in RTC_InitStruct.
    449            * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure that contains 
    450            *         the configuration information for the RTC peripheral.
    451            * @note   The RTC Prescaler register is write protected and can be written in 
    452            *         initialization mode only.  
    453            * @retval An ErrorStatus enumeration value:
    454            *          - SUCCESS: RTC registers are initialized
    455            *          - ERROR: RTC registers are not initialized  
    456            */

   \                                 In section .text, align 2, keep-with-next
    457          ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
    458          {
   \                     RTC_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
    459            ErrorStatus status = ERROR;
   \        0x4   0x2000             MOVS     R0,#+0
    460            
    461            /* Check the parameters */
    462            assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
    463            assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
    464            assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
    465          
    466            /* Disable the write protection for RTC registers */
    467            RTC->WPR = 0xCA;
   \        0x6   0x....'....        LDR.W    R4,??DataTable41  ;; 0x40002824
   \        0xA   0x20CA             MOVS     R0,#+202
   \        0xC   0x6020             STR      R0,[R4, #+0]
    468            RTC->WPR = 0x53;
   \        0xE   0x2053             MOVS     R0,#+83
   \       0x10   0x6020             STR      R0,[R4, #+0]
    469          
    470            /* Set Initialization mode */
    471            if (RTC_EnterInitMode() == ERROR)
   \       0x12   0x....'....        BL       RTC_EnterInitMode
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??RTC_Init_0
    472            {
    473              status = ERROR;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xE015             B.N      ??RTC_Init_1
    474            } 
    475            else
    476            {
    477              /* Clear RTC CR FMT Bit */
    478              RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
   \                     ??RTC_Init_0: (+1)
   \       0x1E   0x....'....        LDR.W    R1,??DataTable43_1  ;; 0x40002808
   \       0x22   0x6808             LDR      R0,[R1, #+0]
   \       0x24   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x28   0x6008             STR      R0,[R1, #+0]
    479              /* Set RTC_CR register */
    480              RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
   \       0x2A   0x680A             LDR      R2,[R1, #+0]
   \       0x2C   0x6828             LDR      R0,[R5, #+0]
   \       0x2E   0x4302             ORRS     R2,R0,R2
   \       0x30   0x600A             STR      R2,[R1, #+0]
    481            
    482              /* Configure the RTC PRER */
    483              RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
   \       0x32   0x....'....        LDR.W    R0,??DataTable44_2  ;; 0x40002810
   \       0x36   0x68A9             LDR      R1,[R5, #+8]
   \       0x38   0x6001             STR      R1,[R0, #+0]
    484              RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
   \       0x3A   0x6801             LDR      R1,[R0, #+0]
   \       0x3C   0x686A             LDR      R2,[R5, #+4]
   \       0x3E   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \       0x42   0x6001             STR      R1,[R0, #+0]
    485          
    486              /* Exit Initialization mode */
    487              RTC_ExitInitMode();
   \       0x44   0x....'....        BL       RTC_ExitInitMode
    488          
    489              status = SUCCESS;    
   \       0x48   0x2001             MOVS     R0,#+1
    490            }
    491            /* Enable the write protection for RTC registers */
    492            RTC->WPR = 0xFF; 
   \                     ??RTC_Init_1: (+1)
   \       0x4A   0x21FF             MOVS     R1,#+255
   \       0x4C   0x6021             STR      R1,[R4, #+0]
    493            
    494            return status;
   \       0x4E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x50   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    495          }
    496          
    497          /**
    498            * @brief  Fills each RTC_InitStruct member with its default value.
    499            * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
    500            *         initialized.
    501            * @retval None
    502            */

   \                                 In section .text, align 2, keep-with-next
    503          void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
    504          {
    505            /* Initialize the RTC_HourFormat member */
    506            RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
   \                     RTC_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    507              
    508            /* Initialize the RTC_AsynchPrediv member */
    509            RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
   \        0x4   0x217F             MOVS     R1,#+127
   \        0x6   0x6041             STR      R1,[R0, #+4]
    510          
    511            /* Initialize the RTC_SynchPrediv member */
    512            RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
   \        0x8   0x21FF             MOVS     R1,#+255
   \        0xA   0x6081             STR      R1,[R0, #+8]
    513          }
   \        0xC   0x4770             BX       LR               ;; return
    514          
    515          /**
    516            * @brief  Enables or disables the RTC registers write protection.
    517            * @note   All the RTC registers are write protected except for RTC_ISR[13:8], 
    518            *         RTC_TAFCR and RTC_BKPxR.
    519            * @note   Writing a wrong key reactivates the write protection.
    520            * @note   The protection mechanism is not affected by system reset.  
    521            * @param  NewState: new state of the write protection.
    522            *          This parameter can be: ENABLE or DISABLE.
    523            * @retval None
    524            */

   \                                 In section .text, align 2, keep-with-next
    525          void RTC_WriteProtectionCmd(FunctionalState NewState)
    526          {
    527            /* Check the parameters */
    528            assert_param(IS_FUNCTIONAL_STATE(NewState));
    529              
    530            if (NewState != DISABLE)
   \                     RTC_WriteProtectionCmd: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD004             BEQ.N    ??RTC_WriteProtectionCmd_0
    531            {
    532              /* Enable the write protection for RTC registers */
    533              RTC->WPR = 0xFF;   
   \        0x6   0x20FF             MOVS     R0,#+255
   \        0x8   0x....'....        LDR.W    R1,??DataTable50_1  ;; 0x40002824
   \        0xC   0x6008             STR      R0,[R1, #+0]
   \        0xE   0xE005             B.N      ??RTC_WriteProtectionCmd_1
    534            }
    535            else
    536            {
    537              /* Disable the write protection for RTC registers */
    538              RTC->WPR = 0xCA;
   \                     ??RTC_WriteProtectionCmd_0: (+1)
   \       0x10   0x....'....        LDR.W    R0,??DataTable50_1  ;; 0x40002824
   \       0x14   0x21CA             MOVS     R1,#+202
   \       0x16   0x6001             STR      R1,[R0, #+0]
    539              RTC->WPR = 0x53;    
   \       0x18   0x2153             MOVS     R1,#+83
   \       0x1A   0x6001             STR      R1,[R0, #+0]
    540            }
    541          }
   \                     ??RTC_WriteProtectionCmd_1: (+1)
   \       0x1C   0x4770             BX       LR               ;; return
    542          
    543          /**
    544            * @brief  Enters the RTC Initialization mode.
    545            * @note   The RTC Initialization mode is write protected, use the 
    546            *         RTC_WriteProtectionCmd(DISABLE) before calling this function.    
    547            * @param  None
    548            * @retval An ErrorStatus enumeration value:
    549            *          - SUCCESS: RTC is in Init mode
    550            *          - ERROR: RTC is not in Init mode  
    551            */

   \                                 In section .text, align 2, keep-with-next
    552          ErrorStatus RTC_EnterInitMode(void)
    553          {
   \                     RTC_EnterInitMode: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
    554            __IO uint32_t initcounter = 0x00;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x9000             STR      R0,[SP, #+0]
    555            ErrorStatus status = ERROR;
   \        0x6   0x2000             MOVS     R0,#+0
    556            uint32_t initstatus = 0x00;
   \        0x8   0x2000             MOVS     R0,#+0
    557               
    558            /* Check if the Initialization mode is set */
    559            if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
   \        0xA   0x....'....        LDR.W    R1,??DataTable49  ;; 0x4000280c
   \        0xE   0x6808             LDR      R0,[R1, #+0]
   \       0x10   0x0640             LSLS     R0,R0,#+25
   \       0x12   0xD415             BMI.N    ??RTC_EnterInitMode_0
    560            {
    561              /* Set the Initialization mode */
    562              RTC->ISR = (uint32_t)RTC_INIT_MASK;
   \       0x14   0xF05F 0x30FF      MOVS     R0,#-1
   \       0x18   0x6008             STR      R0,[R1, #+0]
    563              
    564              /* Wait till RTC is in INIT state and if Time out is reached exit */
    565              do
    566              {
    567                initstatus = RTC->ISR & RTC_ISR_INITF;
   \                     ??RTC_EnterInitMode_1: (+1)
   \       0x1A   0x6808             LDR      R0,[R1, #+0]
   \       0x1C   0xF010 0x0040      ANDS     R0,R0,#0x40
    568                initcounter++;  
   \       0x20   0x9A00             LDR      R2,[SP, #+0]
   \       0x22   0x1C52             ADDS     R2,R2,#+1
   \       0x24   0x9200             STR      R2,[SP, #+0]
    569              } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
   \       0x26   0x9A00             LDR      R2,[SP, #+0]
   \       0x28   0xF5B2 0x3F80      CMP      R2,#+65536
   \       0x2C   0xD001             BEQ.N    ??RTC_EnterInitMode_2
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD0F3             BEQ.N    ??RTC_EnterInitMode_1
    570              
    571              if ((RTC->ISR & RTC_ISR_INITF) != RESET)
   \                     ??RTC_EnterInitMode_2: (+1)
   \       0x32   0x6808             LDR      R0,[R1, #+0]
   \       0x34   0x0640             LSLS     R0,R0,#+25
   \       0x36   0xD501             BPL.N    ??RTC_EnterInitMode_3
    572              {
    573                status = SUCCESS;
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0xE002             B.N      ??RTC_EnterInitMode_4
    574              }
    575              else
    576              {
    577                status = ERROR;
   \                     ??RTC_EnterInitMode_3: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xE000             B.N      ??RTC_EnterInitMode_4
    578              }        
    579            }
    580            else
    581            {
    582              status = SUCCESS;  
   \                     ??RTC_EnterInitMode_0: (+1)
   \       0x40   0x2001             MOVS     R0,#+1
    583            } 
    584              
    585            return (status);  
   \                     ??RTC_EnterInitMode_4: (+1)
   \       0x42   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x44   0xB001             ADD      SP,SP,#+4
   \       0x46   0x4770             BX       LR               ;; return
    586          }
    587          
    588          /**
    589            * @brief  Exits the RTC Initialization mode.
    590            * @note   When the initialization sequence is complete, the calendar restarts 
    591            *         counting after 4 RTCCLK cycles.  
    592            * @note   The RTC Initialization mode is write protected, use the 
    593            *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
    594            * @param  None
    595            * @retval None
    596            */

   \                                 In section .text, align 2, keep-with-next
    597          void RTC_ExitInitMode(void)
    598          { 
    599            /* Exit Initialization mode */
    600            RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
   \                     RTC_ExitInitMode: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable49  ;; 0x4000280c
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF031 0x0180      BICS     R1,R1,#0x80
   \        0xA   0x6001             STR      R1,[R0, #+0]
    601          }
   \        0xC   0x4770             BX       LR               ;; return
    602          
    603          /**
    604            * @brief  Waits until the RTC Time and Date registers (RTC_TR and RTC_DR) are 
    605            *         synchronized with RTC APB clock.
    606            * @note   The RTC Resynchronization mode is write protected, use the 
    607            *         RTC_WriteProtectionCmd(DISABLE) before calling this function. 
    608            * @note   To read the calendar through the shadow registers after Calendar 
    609            *         initialization, calendar update or after wakeup from low power modes 
    610            *         the software must first clear the RSF flag. 
    611            *         The software must then wait until it is set again before reading 
    612            *         the calendar, which means that the calendar registers have been 
    613            *         correctly copied into the RTC_TR and RTC_DR shadow registers.   
    614            * @param  None
    615            * @retval An ErrorStatus enumeration value:
    616            *          - SUCCESS: RTC registers are synchronised
    617            *          - ERROR: RTC registers are not synchronised
    618            */

   \                                 In section .text, align 2, keep-with-next
    619          ErrorStatus RTC_WaitForSynchro(void)
    620          {
   \                     RTC_WaitForSynchro: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
    621            __IO uint32_t synchrocounter = 0;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x9000             STR      R0,[SP, #+0]
    622            ErrorStatus status = ERROR;
   \        0x6   0x2000             MOVS     R0,#+0
    623            uint32_t synchrostatus = 0x00;
   \        0x8   0x2000             MOVS     R0,#+0
    624          
    625            /* Disable the write protection for RTC registers */
    626            RTC->WPR = 0xCA;
   \        0xA   0x....'....        LDR.W    R1,??DataTable41  ;; 0x40002824
   \        0xE   0x20CA             MOVS     R0,#+202
   \       0x10   0x6008             STR      R0,[R1, #+0]
    627            RTC->WPR = 0x53;
   \       0x12   0x2053             MOVS     R0,#+83
   \       0x14   0x6008             STR      R0,[R1, #+0]
    628              
    629            /* Clear RSF flag */
    630            RTC->ISR &= (uint32_t)RTC_RSF_MASK;
   \       0x16   0x....'....        LDR.W    R2,??DataTable49  ;; 0x4000280c
   \       0x1A   0x6810             LDR      R0,[R2, #+0]
   \       0x1C   0xF030 0x00A0      BICS     R0,R0,#0xA0
   \       0x20   0x6010             STR      R0,[R2, #+0]
    631              
    632            /* Wait the registers to be synchronised */
    633            do
    634            {
    635              synchrostatus = RTC->ISR & RTC_ISR_RSF;
   \                     ??RTC_WaitForSynchro_0: (+1)
   \       0x22   0x6810             LDR      R0,[R2, #+0]
   \       0x24   0xF010 0x0020      ANDS     R0,R0,#0x20
    636              synchrocounter++;  
   \       0x28   0x9B00             LDR      R3,[SP, #+0]
   \       0x2A   0x1C5B             ADDS     R3,R3,#+1
   \       0x2C   0x9300             STR      R3,[SP, #+0]
    637            } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
   \       0x2E   0x9B00             LDR      R3,[SP, #+0]
   \       0x30   0xF5B3 0x3F00      CMP      R3,#+131072
   \       0x34   0xD001             BEQ.N    ??RTC_WaitForSynchro_1
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD0F3             BEQ.N    ??RTC_WaitForSynchro_0
    638              
    639            if ((RTC->ISR & RTC_ISR_RSF) != RESET)
   \                     ??RTC_WaitForSynchro_1: (+1)
   \       0x3A   0x6810             LDR      R0,[R2, #+0]
   \       0x3C   0x0680             LSLS     R0,R0,#+26
   \       0x3E   0xD501             BPL.N    ??RTC_WaitForSynchro_2
    640            {
    641              status = SUCCESS;
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0xE000             B.N      ??RTC_WaitForSynchro_3
    642            }
    643            else
    644            {
    645              status = ERROR;
   \                     ??RTC_WaitForSynchro_2: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
    646            }        
    647          
    648            /* Enable the write protection for RTC registers */
    649            RTC->WPR = 0xFF; 
   \                     ??RTC_WaitForSynchro_3: (+1)
   \       0x46   0x22FF             MOVS     R2,#+255
   \       0x48   0x600A             STR      R2,[R1, #+0]
    650              
    651            return (status); 
   \       0x4A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x4C   0xB001             ADD      SP,SP,#+4
   \       0x4E   0x4770             BX       LR               ;; return
    652          }
    653          
    654          /**
    655            * @brief  Enables or disables the RTC reference clock detection.
    656            * @param  NewState: new state of the RTC reference clock.
    657            *          This parameter can be: ENABLE or DISABLE.
    658            * @retval An ErrorStatus enumeration value:
    659            *          - SUCCESS: RTC reference clock detection is enabled
    660            *          - ERROR: RTC reference clock detection is disabled  
    661            */

   \                                 In section .text, align 2, keep-with-next
    662          ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
    663          { 
   \                     RTC_RefClockCmd: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    664            ErrorStatus status = ERROR;
   \        0x4   0x2000             MOVS     R0,#+0
    665            
    666            /* Check the parameters */
    667            assert_param(IS_FUNCTIONAL_STATE(NewState));
    668            
    669            /* Disable the write protection for RTC registers */
    670            RTC->WPR = 0xCA;
   \        0x6   0x....'....        LDR.W    R5,??DataTable41  ;; 0x40002824
   \        0xA   0x20CA             MOVS     R0,#+202
   \        0xC   0x6028             STR      R0,[R5, #+0]
    671            RTC->WPR = 0x53;
   \        0xE   0x2053             MOVS     R0,#+83
   \       0x10   0x6028             STR      R0,[R5, #+0]
    672              
    673            /* Set Initialization mode */
    674            if (RTC_EnterInitMode() == ERROR)
   \       0x12   0x....'....        BL       RTC_EnterInitMode
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??RTC_RefClockCmd_0
    675            {
    676              status = ERROR;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xE012             B.N      ??RTC_RefClockCmd_1
    677            } 
    678            else
    679            {  
    680              if (NewState != DISABLE)
   \                     ??RTC_RefClockCmd_0: (+1)
   \       0x1E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD006             BEQ.N    ??RTC_RefClockCmd_2
    681              {
    682                /* Enable the RTC reference clock detection */
    683                RTC->CR |= RTC_CR_REFCKON;   
   \       0x24   0x....'....        LDR.W    R0,??DataTable50_2  ;; 0x40002808
   \       0x28   0x6801             LDR      R1,[R0, #+0]
   \       0x2A   0xF051 0x0110      ORRS     R1,R1,#0x10
   \       0x2E   0x6001             STR      R1,[R0, #+0]
   \       0x30   0xE005             B.N      ??RTC_RefClockCmd_3
    684              }
    685              else
    686              {
    687                /* Disable the RTC reference clock detection */
    688                RTC->CR &= ~RTC_CR_REFCKON;    
   \                     ??RTC_RefClockCmd_2: (+1)
   \       0x32   0x....'....        LDR.W    R0,??DataTable50_2  ;; 0x40002808
   \       0x36   0x6801             LDR      R1,[R0, #+0]
   \       0x38   0xF031 0x0110      BICS     R1,R1,#0x10
   \       0x3C   0x6001             STR      R1,[R0, #+0]
    689              }
    690              /* Exit Initialization mode */
    691              RTC_ExitInitMode();
   \                     ??RTC_RefClockCmd_3: (+1)
   \       0x3E   0x....'....        BL       RTC_ExitInitMode
    692              
    693              status = SUCCESS;
   \       0x42   0x2001             MOVS     R0,#+1
    694            }
    695            
    696            /* Enable the write protection for RTC registers */
    697            RTC->WPR = 0xFF;  
   \                     ??RTC_RefClockCmd_1: (+1)
   \       0x44   0x21FF             MOVS     R1,#+255
   \       0x46   0x6029             STR      R1,[R5, #+0]
    698            
    699            return status; 
   \       0x48   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x4A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    700          }
    701          
    702          /**
    703            * @brief  Enables or Disables the Bypass Shadow feature.
    704            * @note   When the Bypass Shadow is enabled the calendar value are taken 
    705            *         directly from the Calendar counter.
    706            * @param  NewState: new state of the Bypass Shadow feature.
    707            *         This parameter can be: ENABLE or DISABLE.
    708            * @retval None
    709          */

   \                                 In section .text, align 2, keep-with-next
    710          void RTC_BypassShadowCmd(FunctionalState NewState)
    711          {
    712            /* Check the parameters */
    713            assert_param(IS_FUNCTIONAL_STATE(NewState));
    714          
    715            /* Disable the write protection for RTC registers */
    716            RTC->WPR = 0xCA;
   \                     RTC_BypassShadowCmd: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable41  ;; 0x40002824
   \        0x4   0x22CA             MOVS     R2,#+202
   \        0x6   0x600A             STR      R2,[R1, #+0]
    717            RTC->WPR = 0x53;
   \        0x8   0x2253             MOVS     R2,#+83
   \        0xA   0x600A             STR      R2,[R1, #+0]
    718            
    719            if (NewState != DISABLE)
   \        0xC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD006             BEQ.N    ??RTC_BypassShadowCmd_0
    720            {
    721              /* Set the BYPSHAD bit */
    722              RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
   \       0x12   0x....'....        LDR.W    R0,??DataTable50_2  ;; 0x40002808
   \       0x16   0x6802             LDR      R2,[R0, #+0]
   \       0x18   0xF052 0x0220      ORRS     R2,R2,#0x20
   \       0x1C   0x6002             STR      R2,[R0, #+0]
   \       0x1E   0xE005             B.N      ??RTC_BypassShadowCmd_1
    723            }
    724            else
    725            {
    726              /* Reset the BYPSHAD bit */
    727              RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
   \                     ??RTC_BypassShadowCmd_0: (+1)
   \       0x20   0x....'....        LDR.W    R0,??DataTable50_2  ;; 0x40002808
   \       0x24   0x6802             LDR      R2,[R0, #+0]
   \       0x26   0xF012 0x02DF      ANDS     R2,R2,#0xDF
   \       0x2A   0x6002             STR      R2,[R0, #+0]
    728            }
    729          
    730            /* Enable the write protection for RTC registers */
    731            RTC->WPR = 0xFF;
   \                     ??RTC_BypassShadowCmd_1: (+1)
   \       0x2C   0x20FF             MOVS     R0,#+255
   \       0x2E   0x6008             STR      R0,[R1, #+0]
    732          }
   \       0x30   0x4770             BX       LR               ;; return
    733          
    734          /**
    735            * @}
    736            */
    737          
    738          /** @defgroup RTC_Group2 Time and Date configuration functions
    739           *  @brief   Time and Date configuration functions 
    740           *
    741          @verbatim   
    742           ===============================================================================
    743                           ##### Time and Date configuration functions #####
    744           ===============================================================================  
    745           
    746           [..] This section provide functions allowing to program and read the RTC Calendar
    747                (Time and Date).
    748          
    749          @endverbatim
    750            * @{
    751            */
    752          
    753          /**
    754            * @brief  Set the RTC current time.
    755            * @param  RTC_Format: specifies the format of the entered parameters.
    756            *          This parameter can be  one of the following values:
    757            *            @arg RTC_Format_BIN:  Binary data format 
    758            *            @arg RTC_Format_BCD:  BCD data format
    759            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that contains 
    760            *                        the time configuration information for the RTC.     
    761            * @retval An ErrorStatus enumeration value:
    762            *          - SUCCESS: RTC Time register is configured
    763            *          - ERROR: RTC Time register is not configured
    764            */

   \                                 In section .text, align 2, keep-with-next
    765          ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
    766          {
   \                     RTC_SetTime: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    767            uint32_t tmpreg = 0;
   \        0x6   0x2000             MOVS     R0,#+0
    768            ErrorStatus status = ERROR;
   \        0x8   0x2000             MOVS     R0,#+0
    769              
    770            /* Check the parameters */
    771            assert_param(IS_RTC_FORMAT(RTC_Format));
    772            
    773            if (RTC_Format == RTC_Format_BIN)
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD107             BNE.N    ??RTC_SetTime_0
    774            {
    775              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \        0xE   0x....'....        LDR.W    R0,??DataTable50_2  ;; 0x40002808
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x0640             LSLS     R0,R0,#+25
   \       0x16   0xD401             BMI.N    ??RTC_SetTime_1
    776              {
    777                assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
    778                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
    779              } 
    780              else
    781              {
    782                RTC_TimeStruct->RTC_H12 = 0x00;
   \                     ??RTC_SetTime_2: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x70E8             STRB     R0,[R5, #+3]
    783                assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
    784              }
    785              assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
    786              assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
   \                     ??RTC_SetTime_1: (+1)
   \       0x1C   0xE00A             B.N      ??RTC_SetTime_3
    787            }
    788            else
    789            {
    790              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \                     ??RTC_SetTime_0: (+1)
   \       0x1E   0x....'....        LDR.W    R0,??DataTable50_2  ;; 0x40002808
   \       0x22   0x6800             LDR      R0,[R0, #+0]
   \       0x24   0x0640             LSLS     R0,R0,#+25
   \       0x26   0xD503             BPL.N    ??RTC_SetTime_4
    791              {
    792                tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
   \       0x28   0x7828             LDRB     R0,[R5, #+0]
   \       0x2A   0x....'....        BL       RTC_Bcd2ToByte
    793                assert_param(IS_RTC_HOUR12(tmpreg));
    794                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
   \       0x2E   0xE001             B.N      ??RTC_SetTime_5
    795              } 
    796              else
    797              {
    798                RTC_TimeStruct->RTC_H12 = 0x00;
   \                     ??RTC_SetTime_4: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x70E8             STRB     R0,[R5, #+3]
    799                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
    800              }
    801              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
    802              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
    803            }
    804            
    805            /* Check the input parameters format */
    806            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetTime_5: (+1)
   \                     ??RTC_SetTime_3: (+1)
   \       0x34   0x2C00             CMP      R4,#+0
   \       0x36   0xD00A             BEQ.N    ??RTC_SetTime_6
    807            {
    808              tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
    809                       ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
    810                       ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
    811                       ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
   \       0x38   0x7828             LDRB     R0,[R5, #+0]
   \       0x3A   0x786C             LDRB     R4,[R5, #+1]
   \       0x3C   0x0224             LSLS     R4,R4,#+8
   \       0x3E   0xEA54 0x4400      ORRS     R4,R4,R0, LSL #+16
   \       0x42   0x78A8             LDRB     R0,[R5, #+2]
   \       0x44   0x4304             ORRS     R4,R0,R4
   \       0x46   0x78E8             LDRB     R0,[R5, #+3]
   \       0x48   0xEA54 0x4400      ORRS     R4,R4,R0, LSL #+16
   \       0x4C   0xE014             B.N      ??RTC_SetTime_7
    812            }  
    813            else
    814            {
    815              tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
    816                             ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
    817                             ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
    818                             (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
   \                     ??RTC_SetTime_6: (+1)
   \       0x4E   0x7828             LDRB     R0,[R5, #+0]
   \       0x50   0x....'....        BL       RTC_ByteToBcd2
   \       0x54   0x0006             MOVS     R6,R0
   \       0x56   0x7868             LDRB     R0,[R5, #+1]
   \       0x58   0x....'....        BL       RTC_ByteToBcd2
   \       0x5C   0x0004             MOVS     R4,R0
   \       0x5E   0x78A8             LDRB     R0,[R5, #+2]
   \       0x60   0x....'....        BL       RTC_ByteToBcd2
   \       0x64   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x66   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x68   0x0224             LSLS     R4,R4,#+8
   \       0x6A   0xEA54 0x4406      ORRS     R4,R4,R6, LSL #+16
   \       0x6E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x70   0x4304             ORRS     R4,R0,R4
   \       0x72   0x78E8             LDRB     R0,[R5, #+3]
   \       0x74   0xEA54 0x4400      ORRS     R4,R4,R0, LSL #+16
    819            }  
    820          
    821            /* Disable the write protection for RTC registers */
    822            RTC->WPR = 0xCA;
   \                     ??RTC_SetTime_7: (+1)
   \       0x78   0x....'....        LDR.W    R5,??DataTable41  ;; 0x40002824
   \       0x7C   0x20CA             MOVS     R0,#+202
   \       0x7E   0x6028             STR      R0,[R5, #+0]
    823            RTC->WPR = 0x53;
   \       0x80   0x2053             MOVS     R0,#+83
   \       0x82   0x6028             STR      R0,[R5, #+0]
    824          
    825            /* Set Initialization mode */
    826            if (RTC_EnterInitMode() == ERROR)
   \       0x84   0x....'....        BL       RTC_EnterInitMode
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD101             BNE.N    ??RTC_SetTime_8
    827            {
    828              status = ERROR;
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xE015             B.N      ??RTC_SetTime_9
    829            } 
    830            else
    831            {
    832              /* Set the RTC_TR register */
    833              RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
   \                     ??RTC_SetTime_8: (+1)
   \       0x90   0x....'....        LDR.W    R0,??DataTable50_3  ;; 0x7f7f7f
   \       0x94   0x4004             ANDS     R4,R0,R4
   \       0x96   0x....'....        LDR.W    R0,??DataTable42  ;; 0x40002800
   \       0x9A   0x6004             STR      R4,[R0, #+0]
    834          
    835              /* Exit Initialization mode */
    836              RTC_ExitInitMode(); 
   \       0x9C   0x....'....        BL       RTC_ExitInitMode
    837          
    838              /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    839              if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
   \       0xA0   0x....'....        LDR.W    R0,??DataTable50_2  ;; 0x40002808
   \       0xA4   0x6800             LDR      R0,[R0, #+0]
   \       0xA6   0x0680             LSLS     R0,R0,#+26
   \       0xA8   0xD407             BMI.N    ??RTC_SetTime_10
    840              {
    841              if(RTC_WaitForSynchro() == ERROR)
   \       0xAA   0x....'....        BL       RTC_WaitForSynchro
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD101             BNE.N    ??RTC_SetTime_11
    842              {
    843                status = ERROR;
   \       0xB2   0x2000             MOVS     R0,#+0
   \       0xB4   0xE002             B.N      ??RTC_SetTime_9
    844              }
    845              else
    846              {
    847                status = SUCCESS;
   \                     ??RTC_SetTime_11: (+1)
   \       0xB6   0x2001             MOVS     R0,#+1
   \       0xB8   0xE000             B.N      ??RTC_SetTime_9
    848              }
    849            }
    850              else
    851              {
    852                status = SUCCESS;
   \                     ??RTC_SetTime_10: (+1)
   \       0xBA   0x2001             MOVS     R0,#+1
    853              }
    854            }
    855            /* Enable the write protection for RTC registers */
    856            RTC->WPR = 0xFF; 
   \                     ??RTC_SetTime_9: (+1)
   \       0xBC   0x21FF             MOVS     R1,#+255
   \       0xBE   0x6029             STR      R1,[R5, #+0]
    857              
    858            return status;
   \       0xC0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xC2   0xBD70             POP      {R4-R6,PC}       ;; return
    859          }
    860          
    861          /**
    862            * @brief  Fills each RTC_TimeStruct member with its default value
    863            *         (Time = 00h:00min:00sec).
    864            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
    865            *         initialized.
    866            * @retval None
    867            */

   \                                 In section .text, align 2, keep-with-next
    868          void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
    869          {
    870            /* Time = 00h:00min:00sec */
    871            RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
   \                     RTC_TimeStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x70C1             STRB     R1,[R0, #+3]
    872            RTC_TimeStruct->RTC_Hours = 0;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x7001             STRB     R1,[R0, #+0]
    873            RTC_TimeStruct->RTC_Minutes = 0;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x7041             STRB     R1,[R0, #+1]
    874            RTC_TimeStruct->RTC_Seconds = 0; 
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x7081             STRB     R1,[R0, #+2]
    875          }
   \       0x10   0x4770             BX       LR               ;; return
    876          
    877          /**
    878            * @brief  Get the RTC current Time.
    879            * @param  RTC_Format: specifies the format of the returned parameters.
    880            *          This parameter can be  one of the following values:
    881            *            @arg RTC_Format_BIN:  Binary data format 
    882            *            @arg RTC_Format_BCD:  BCD data format
    883            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
    884            *                        contain the returned current time configuration.     
    885            * @retval None
    886            */

   \                                 In section .text, align 2, keep-with-next
    887          void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
    888          {
   \                     RTC_GetTime: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x000C             MOVS     R4,R1
    889            uint32_t tmpreg = 0;
   \        0x4   0x2100             MOVS     R1,#+0
    890          
    891            /* Check the parameters */
    892            assert_param(IS_RTC_FORMAT(RTC_Format));
    893          
    894            /* Get the RTC_TR register */
    895            tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
   \        0x6   0x....'....        LDR.W    R1,??DataTable42  ;; 0x40002800
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0x....'....        LDR.W    R1,??DataTable50_3  ;; 0x7f7f7f
   \       0x10   0x400A             ANDS     R2,R1,R2
    896            
    897            /* Fill the structure fields with the read parameters */
    898            RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
   \       0x12   0x0011             MOVS     R1,R2
   \       0x14   0x0C09             LSRS     R1,R1,#+16
   \       0x16   0xF011 0x013F      ANDS     R1,R1,#0x3F
   \       0x1A   0x7021             STRB     R1,[R4, #+0]
    899            RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
   \       0x1C   0x0011             MOVS     R1,R2
   \       0x1E   0x0A09             LSRS     R1,R1,#+8
   \       0x20   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \       0x24   0x7061             STRB     R1,[R4, #+1]
    900            RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
   \       0x26   0xF012 0x017F      ANDS     R1,R2,#0x7F
   \       0x2A   0x70A1             STRB     R1,[R4, #+2]
    901            RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
   \       0x2C   0x0C12             LSRS     R2,R2,#+16
   \       0x2E   0xF012 0x0240      ANDS     R2,R2,#0x40
   \       0x32   0x70E2             STRB     R2,[R4, #+3]
    902          
    903            /* Check the input parameters format */
    904            if (RTC_Format == RTC_Format_BIN)
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD10B             BNE.N    ??RTC_GetTime_0
    905            {
    906              /* Convert the structure parameters to Binary format */
    907              RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
   \       0x38   0x7820             LDRB     R0,[R4, #+0]
   \       0x3A   0x....'....        BL       RTC_Bcd2ToByte
   \       0x3E   0x7020             STRB     R0,[R4, #+0]
    908              RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
   \       0x40   0x7860             LDRB     R0,[R4, #+1]
   \       0x42   0x....'....        BL       RTC_Bcd2ToByte
   \       0x46   0x7060             STRB     R0,[R4, #+1]
    909              RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
   \       0x48   0x78A0             LDRB     R0,[R4, #+2]
   \       0x4A   0x....'....        BL       RTC_Bcd2ToByte
   \       0x4E   0x70A0             STRB     R0,[R4, #+2]
    910            }
    911          }
   \                     ??RTC_GetTime_0: (+1)
   \       0x50   0xBD10             POP      {R4,PC}          ;; return
    912          
    913          /**
    914            * @brief  Gets the RTC current Calendar Sub seconds value.
    915            * @note   This function freeze the Time and Date registers after reading the 
    916            *         SSR register.
    917            * @param  None
    918            * @retval RTC current Calendar Sub seconds value.
    919            */

   \                                 In section .text, align 2, keep-with-next
    920          uint32_t RTC_GetSubSecond(void)
    921          {
    922            uint32_t tmpreg = 0;
   \                     RTC_GetSubSecond: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
    923            
    924            /* Get sub seconds values from the correspondent registers*/
    925            tmpreg = (uint32_t)(RTC->SSR);
   \        0x2   0x....'....        LDR.W    R0,??DataTable50_4  ;; 0x40002828
   \        0x6   0x6800             LDR      R0,[R0, #+0]
    926            
    927            /* Read DR register to unfroze calendar registers */
    928            (void) (RTC->DR);
   \        0x8   0x....'....        LDR.W    R1,??DataTable43  ;; 0x40002804
   \        0xC   0x6809             LDR      R1,[R1, #+0]
    929            
    930            return (tmpreg);
   \        0xE   0x4770             BX       LR               ;; return
    931          }
    932          
    933          /**
    934            * @brief  Set the RTC current date.
    935            * @param  RTC_Format: specifies the format of the entered parameters.
    936            *          This parameter can be  one of the following values:
    937            *            @arg RTC_Format_BIN:  Binary data format 
    938            *            @arg RTC_Format_BCD:  BCD data format
    939            * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure that contains 
    940            *                         the date configuration information for the RTC.
    941            * @retval An ErrorStatus enumeration value:
    942            *          - SUCCESS: RTC Date register is configured
    943            *          - ERROR: RTC Date register is not configured
    944            */

   \                                 In section .text, align 2, keep-with-next
    945          ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
    946          {
   \                     RTC_SetDate: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    947            uint32_t tmpreg = 0;
   \        0x6   0x2000             MOVS     R0,#+0
    948            ErrorStatus status = ERROR;
   \        0x8   0x2000             MOVS     R0,#+0
    949            
    950            /* Check the parameters */
    951            assert_param(IS_RTC_FORMAT(RTC_Format));
    952          
    953            if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD107             BNE.N    ??RTC_SetDate_0
   \        0xE   0x7868             LDRB     R0,[R5, #+1]
   \       0x10   0x06C0             LSLS     R0,R0,#+27
   \       0x12   0xD504             BPL.N    ??RTC_SetDate_0
    954            {
    955              RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
   \       0x14   0x7868             LDRB     R0,[R5, #+1]
   \       0x16   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \       0x1A   0x300A             ADDS     R0,R0,#+10
   \       0x1C   0x7068             STRB     R0,[R5, #+1]
    956            }  
    957            if (RTC_Format == RTC_Format_BIN)
   \                     ??RTC_SetDate_0: (+1)
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD005             BEQ.N    ??RTC_SetDate_1
    958            {
    959              assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
    960              assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
    961              assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
    962            }
    963            else
    964            {
    965              assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
    966              tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
   \                     ??RTC_SetDate_2: (+1)
   \       0x22   0x7868             LDRB     R0,[R5, #+1]
   \       0x24   0x....'....        BL       RTC_Bcd2ToByte
    967              assert_param(IS_RTC_MONTH(tmpreg));
    968              tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
   \       0x28   0x78A8             LDRB     R0,[R5, #+2]
   \       0x2A   0x....'....        BL       RTC_Bcd2ToByte
    969              assert_param(IS_RTC_DATE(tmpreg));
    970            }
    971            assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
    972          
    973            /* Check the input parameters format */
    974            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetDate_1: (+1)
   \       0x2E   0x2C00             CMP      R4,#+0
   \       0x30   0xD00A             BEQ.N    ??RTC_SetDate_3
    975            {
    976              tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
    977                        (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
    978                        ((uint32_t)RTC_DateStruct->RTC_Date) | \
    979                        (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
   \       0x32   0x78E8             LDRB     R0,[R5, #+3]
   \       0x34   0x786C             LDRB     R4,[R5, #+1]
   \       0x36   0x0224             LSLS     R4,R4,#+8
   \       0x38   0xEA54 0x4400      ORRS     R4,R4,R0, LSL #+16
   \       0x3C   0x78A8             LDRB     R0,[R5, #+2]
   \       0x3E   0x4304             ORRS     R4,R0,R4
   \       0x40   0x7828             LDRB     R0,[R5, #+0]
   \       0x42   0xEA54 0x3440      ORRS     R4,R4,R0, LSL #+13
   \       0x46   0xE014             B.N      ??RTC_SetDate_4
    980            }  
    981            else
    982            {
    983              tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
    984                        ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
    985                        ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
    986                        ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
   \                     ??RTC_SetDate_3: (+1)
   \       0x48   0x78E8             LDRB     R0,[R5, #+3]
   \       0x4A   0x....'....        BL       RTC_ByteToBcd2
   \       0x4E   0x0006             MOVS     R6,R0
   \       0x50   0x7868             LDRB     R0,[R5, #+1]
   \       0x52   0x....'....        BL       RTC_ByteToBcd2
   \       0x56   0x0004             MOVS     R4,R0
   \       0x58   0x78A8             LDRB     R0,[R5, #+2]
   \       0x5A   0x....'....        BL       RTC_ByteToBcd2
   \       0x5E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \       0x60   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x62   0x0224             LSLS     R4,R4,#+8
   \       0x64   0xEA54 0x4406      ORRS     R4,R4,R6, LSL #+16
   \       0x68   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x6A   0x4304             ORRS     R4,R0,R4
   \       0x6C   0x7828             LDRB     R0,[R5, #+0]
   \       0x6E   0xEA54 0x3440      ORRS     R4,R4,R0, LSL #+13
    987            }
    988          
    989            /* Disable the write protection for RTC registers */
    990            RTC->WPR = 0xCA;
   \                     ??RTC_SetDate_4: (+1)
   \       0x72   0x....'....        LDR.W    R5,??DataTable41  ;; 0x40002824
   \       0x76   0x20CA             MOVS     R0,#+202
   \       0x78   0x6028             STR      R0,[R5, #+0]
    991            RTC->WPR = 0x53;
   \       0x7A   0x2053             MOVS     R0,#+83
   \       0x7C   0x6028             STR      R0,[R5, #+0]
    992          
    993            /* Set Initialization mode */
    994            if (RTC_EnterInitMode() == ERROR)
   \       0x7E   0x....'....        BL       RTC_EnterInitMode
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD101             BNE.N    ??RTC_SetDate_5
    995            {
    996              status = ERROR;
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0xE015             B.N      ??RTC_SetDate_6
    997            } 
    998            else
    999            {
   1000              /* Set the RTC_DR register */
   1001              RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
   \                     ??RTC_SetDate_5: (+1)
   \       0x8A   0x....'....        LDR.W    R0,??DataTable50_5  ;; 0xffff3f
   \       0x8E   0x4004             ANDS     R4,R0,R4
   \       0x90   0x....'....        LDR.W    R0,??DataTable43  ;; 0x40002804
   \       0x94   0x6004             STR      R4,[R0, #+0]
   1002          
   1003              /* Exit Initialization mode */
   1004              RTC_ExitInitMode(); 
   \       0x96   0x....'....        BL       RTC_ExitInitMode
   1005          
   1006              /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
   1007              if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
   \       0x9A   0x....'....        LDR.W    R0,??DataTable50_2  ;; 0x40002808
   \       0x9E   0x6800             LDR      R0,[R0, #+0]
   \       0xA0   0x0680             LSLS     R0,R0,#+26
   \       0xA2   0xD407             BMI.N    ??RTC_SetDate_7
   1008              {
   1009              if(RTC_WaitForSynchro() == ERROR)
   \       0xA4   0x....'....        BL       RTC_WaitForSynchro
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD101             BNE.N    ??RTC_SetDate_8
   1010              {
   1011                status = ERROR;
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0xE002             B.N      ??RTC_SetDate_6
   1012              }
   1013              else
   1014              {
   1015                status = SUCCESS;
   \                     ??RTC_SetDate_8: (+1)
   \       0xB0   0x2001             MOVS     R0,#+1
   \       0xB2   0xE000             B.N      ??RTC_SetDate_6
   1016              }
   1017            }
   1018              else
   1019              {
   1020                status = SUCCESS;
   \                     ??RTC_SetDate_7: (+1)
   \       0xB4   0x2001             MOVS     R0,#+1
   1021              }
   1022            }
   1023            /* Enable the write protection for RTC registers */
   1024            RTC->WPR = 0xFF;   
   \                     ??RTC_SetDate_6: (+1)
   \       0xB6   0x21FF             MOVS     R1,#+255
   \       0xB8   0x6029             STR      R1,[R5, #+0]
   1025            
   1026            return status;
   \       0xBA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xBC   0xBD70             POP      {R4-R6,PC}       ;; return
   1027          }
   1028          
   1029          /**
   1030            * @brief  Fills each RTC_DateStruct member with its default value
   1031            *         (Monday, January 01 xx00).
   1032            * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
   1033            *         initialized.
   1034            * @retval None
   1035            */

   \                                 In section .text, align 2, keep-with-next
   1036          void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
   1037          {
   1038            /* Monday, January 01 xx00 */
   1039            RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
   \                     RTC_DateStructInit: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0x7001             STRB     R1,[R0, #+0]
   1040            RTC_DateStruct->RTC_Date = 1;
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x7081             STRB     R1,[R0, #+2]
   1041            RTC_DateStruct->RTC_Month = RTC_Month_January;
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0x7041             STRB     R1,[R0, #+1]
   1042            RTC_DateStruct->RTC_Year = 0;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x70C1             STRB     R1,[R0, #+3]
   1043          }
   \       0x10   0x4770             BX       LR               ;; return
   1044          
   1045          /**
   1046            * @brief  Get the RTC current date. 
   1047            * @param  RTC_Format: specifies the format of the returned parameters.
   1048            *          This parameter can be one of the following values:
   1049            *            @arg RTC_Format_BIN: Binary data format 
   1050            *            @arg RTC_Format_BCD: BCD data format
   1051            * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
   1052            *                        contain the returned current date configuration.     
   1053            * @retval None
   1054            */

   \                                 In section .text, align 2, keep-with-next
   1055          void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
   1056          {
   \                     RTC_GetDate: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x000C             MOVS     R4,R1
   1057            uint32_t tmpreg = 0;
   \        0x4   0x2100             MOVS     R1,#+0
   1058          
   1059            /* Check the parameters */
   1060            assert_param(IS_RTC_FORMAT(RTC_Format));
   1061            
   1062            /* Get the RTC_TR register */
   1063            tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
   \        0x6   0x....'....        LDR.W    R1,??DataTable43  ;; 0x40002804
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0x....'....        LDR.W    R1,??DataTable50_5  ;; 0xffff3f
   \       0x10   0x400A             ANDS     R2,R1,R2
   1064          
   1065            /* Fill the structure fields with the read parameters */
   1066            RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
   \       0x12   0x0011             MOVS     R1,R2
   \       0x14   0x0C09             LSRS     R1,R1,#+16
   \       0x16   0x70E1             STRB     R1,[R4, #+3]
   1067            RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
   \       0x18   0x0011             MOVS     R1,R2
   \       0x1A   0x0A09             LSRS     R1,R1,#+8
   \       0x1C   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \       0x20   0x7061             STRB     R1,[R4, #+1]
   1068            RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
   \       0x22   0xF012 0x013F      ANDS     R1,R2,#0x3F
   \       0x26   0x70A1             STRB     R1,[R4, #+2]
   1069            RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
   \       0x28   0x0B52             LSRS     R2,R2,#+13
   \       0x2A   0xF012 0x0207      ANDS     R2,R2,#0x7
   \       0x2E   0x7022             STRB     R2,[R4, #+0]
   1070          
   1071            /* Check the input parameters format */
   1072            if (RTC_Format == RTC_Format_BIN)
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD10B             BNE.N    ??RTC_GetDate_0
   1073            {
   1074              /* Convert the structure parameters to Binary format */
   1075              RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
   \       0x34   0x78E0             LDRB     R0,[R4, #+3]
   \       0x36   0x....'....        BL       RTC_Bcd2ToByte
   \       0x3A   0x70E0             STRB     R0,[R4, #+3]
   1076              RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
   \       0x3C   0x7860             LDRB     R0,[R4, #+1]
   \       0x3E   0x....'....        BL       RTC_Bcd2ToByte
   \       0x42   0x7060             STRB     R0,[R4, #+1]
   1077              RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
   \       0x44   0x78A0             LDRB     R0,[R4, #+2]
   \       0x46   0x....'....        BL       RTC_Bcd2ToByte
   \       0x4A   0x70A0             STRB     R0,[R4, #+2]
   1078            }
   1079          }
   \                     ??RTC_GetDate_0: (+1)
   \       0x4C   0xBD10             POP      {R4,PC}          ;; return
   1080          
   1081          /**
   1082            * @}
   1083            */
   1084          
   1085          /** @defgroup RTC_Group3 Alarms configuration functions
   1086           *  @brief   Alarms (Alarm A and Alarm B) configuration functions 
   1087           *
   1088          @verbatim   
   1089           ===============================================================================
   1090                   ##### Alarms A and B configuration functions #####
   1091           ===============================================================================  
   1092           
   1093           [..] This section provide functions allowing to program and read the RTC Alarms.
   1094          
   1095          @endverbatim
   1096            * @{
   1097            */
   1098          
   1099          /**
   1100            * @brief  Set the specified RTC Alarm.
   1101            * @note   The Alarm register can only be written when the corresponding Alarm
   1102            *         is disabled (Use the RTC_AlarmCmd(DISABLE)).    
   1103            * @param  RTC_Format: specifies the format of the returned parameters.
   1104            *          This parameter can be one of the following values:
   1105            *            @arg RTC_Format_BIN: Binary data format 
   1106            *            @arg RTC_Format_BCD: BCD data format
   1107            * @param  RTC_Alarm: specifies the alarm to be configured.
   1108            *          This parameter can be one of the following values:
   1109            *            @arg RTC_Alarm_A: to select Alarm A
   1110            *            @arg RTC_Alarm_B: to select Alarm B  
   1111            * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
   1112            *                          contains the alarm configuration parameters.     
   1113            * @retval None
   1114            */

   \                                 In section .text, align 2, keep-with-next
   1115          void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
   1116          {
   \                     RTC_SetAlarm: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1117            uint32_t tmpreg = 0;
   \        0xA   0x2000             MOVS     R0,#+0
   1118            
   1119            /* Check the parameters */
   1120            assert_param(IS_RTC_FORMAT(RTC_Format));
   1121            assert_param(IS_RTC_ALARM(RTC_Alarm));
   1122            assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
   1123            assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
   1124          
   1125            if (RTC_Format == RTC_Format_BIN)
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD10A             BNE.N    ??RTC_SetAlarm_0
   1126            {
   1127              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \       0x10   0x....'....        LDR.W    R0,??DataTable43_1  ;; 0x40002808
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x0640             LSLS     R0,R0,#+25
   \       0x18   0xD401             BMI.N    ??RTC_SetAlarm_1
   1128              {
   1129                assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1130                assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   1131              } 
   1132              else
   1133              {
   1134                RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
   \                     ??RTC_SetAlarm_2: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x70F0             STRB     R0,[R6, #+3]
   1135                assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1136              }
   1137              assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
   1138              assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
   1139              
   1140              if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
   \                     ??RTC_SetAlarm_1: (+1)
   \       0x1E   0x68B0             LDR      R0,[R6, #+8]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD015             BEQ.N    ??RTC_SetAlarm_3
   1141              {
   1142                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   1143              }
   1144              else
   1145              {
   1146                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   \                     ??RTC_SetAlarm_4: (+1)
   \       0x24   0xE014             B.N      ??RTC_SetAlarm_3
   1147              }
   1148            }
   1149            else
   1150            {
   1151              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \                     ??RTC_SetAlarm_0: (+1)
   \       0x26   0x....'....        LDR.W    R0,??DataTable43_1  ;; 0x40002808
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0x0640             LSLS     R0,R0,#+25
   \       0x2E   0xD503             BPL.N    ??RTC_SetAlarm_5
   1152              {
   1153                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
   \       0x30   0x7830             LDRB     R0,[R6, #+0]
   \       0x32   0x....'....        BL       RTC_Bcd2ToByte
   1154                assert_param(IS_RTC_HOUR12(tmpreg));
   1155                assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   \       0x36   0xE001             B.N      ??RTC_SetAlarm_6
   1156              } 
   1157              else
   1158              {
   1159                RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
   \                     ??RTC_SetAlarm_5: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x70F0             STRB     R0,[R6, #+3]
   1160                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   1161              }
   1162              
   1163              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
   1164              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
   1165              
   1166              if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
   \                     ??RTC_SetAlarm_6: (+1)
   \       0x3C   0x68B0             LDR      R0,[R6, #+8]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD103             BNE.N    ??RTC_SetAlarm_7
   1167              {
   1168                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \       0x42   0x7B30             LDRB     R0,[R6, #+12]
   \       0x44   0x....'....        BL       RTC_Bcd2ToByte
   1169                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
   \       0x48   0xE002             B.N      ??RTC_SetAlarm_3
   1170              }
   1171              else
   1172              {
   1173                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \                     ??RTC_SetAlarm_7: (+1)
   \       0x4A   0x7B30             LDRB     R0,[R6, #+12]
   \       0x4C   0x....'....        BL       RTC_Bcd2ToByte
   1174                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
   1175              }    
   1176            }
   1177          
   1178            /* Check the input parameters format */
   1179            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetAlarm_3: (+1)
   \       0x50   0x2C00             CMP      R4,#+0
   \       0x52   0xD011             BEQ.N    ??RTC_SetAlarm_8
   1180            {
   1181              tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
   1182                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
   1183                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
   1184                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
   1185                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
   1186                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
   1187                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
   \       0x54   0x7830             LDRB     R0,[R6, #+0]
   \       0x56   0x7874             LDRB     R4,[R6, #+1]
   \       0x58   0x0224             LSLS     R4,R4,#+8
   \       0x5A   0xEA54 0x4400      ORRS     R4,R4,R0, LSL #+16
   \       0x5E   0x78B0             LDRB     R0,[R6, #+2]
   \       0x60   0x4304             ORRS     R4,R0,R4
   \       0x62   0x78F0             LDRB     R0,[R6, #+3]
   \       0x64   0xEA54 0x4400      ORRS     R4,R4,R0, LSL #+16
   \       0x68   0x7B30             LDRB     R0,[R6, #+12]
   \       0x6A   0xEA54 0x6400      ORRS     R4,R4,R0, LSL #+24
   \       0x6E   0x68B0             LDR      R0,[R6, #+8]
   \       0x70   0x4304             ORRS     R4,R0,R4
   \       0x72   0x6870             LDR      R0,[R6, #+4]
   \       0x74   0x4304             ORRS     R4,R0,R4
   \       0x76   0xE021             B.N      ??RTC_SetAlarm_9
   1188            }  
   1189            else
   1190            {
   1191              tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
   1192                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
   1193                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
   1194                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
   1195                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
   1196                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
   1197                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
   \                     ??RTC_SetAlarm_8: (+1)
   \       0x78   0x7830             LDRB     R0,[R6, #+0]
   \       0x7A   0x....'....        BL       RTC_ByteToBcd2
   \       0x7E   0x0007             MOVS     R7,R0
   \       0x80   0x7870             LDRB     R0,[R6, #+1]
   \       0x82   0x....'....        BL       RTC_ByteToBcd2
   \       0x86   0x0004             MOVS     R4,R0
   \       0x88   0x78B0             LDRB     R0,[R6, #+2]
   \       0x8A   0x....'....        BL       RTC_ByteToBcd2
   \       0x8E   0x4680             MOV      R8,R0
   \       0x90   0x7B30             LDRB     R0,[R6, #+12]
   \       0x92   0x....'....        BL       RTC_ByteToBcd2
   \       0x96   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \       0x98   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x9A   0x0224             LSLS     R4,R4,#+8
   \       0x9C   0xEA54 0x4407      ORRS     R4,R4,R7, LSL #+16
   \       0xA0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \       0xA4   0xEA58 0x0404      ORRS     R4,R8,R4
   \       0xA8   0x78F1             LDRB     R1,[R6, #+3]
   \       0xAA   0xEA54 0x4401      ORRS     R4,R4,R1, LSL #+16
   \       0xAE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xB0   0xEA54 0x6400      ORRS     R4,R4,R0, LSL #+24
   \       0xB4   0x68B0             LDR      R0,[R6, #+8]
   \       0xB6   0x4304             ORRS     R4,R0,R4
   \       0xB8   0x6870             LDR      R0,[R6, #+4]
   \       0xBA   0x4304             ORRS     R4,R0,R4
   1198            } 
   1199          
   1200            /* Disable the write protection for RTC registers */
   1201            RTC->WPR = 0xCA;
   \                     ??RTC_SetAlarm_9: (+1)
   \       0xBC   0x....'....        LDR.W    R0,??DataTable41  ;; 0x40002824
   \       0xC0   0x21CA             MOVS     R1,#+202
   \       0xC2   0x6001             STR      R1,[R0, #+0]
   1202            RTC->WPR = 0x53;
   \       0xC4   0x2153             MOVS     R1,#+83
   \       0xC6   0x6001             STR      R1,[R0, #+0]
   1203          
   1204            /* Configure the Alarm register */
   1205            if (RTC_Alarm == RTC_Alarm_A)
   \       0xC8   0xF5B5 0x7F80      CMP      R5,#+256
   \       0xCC   0xD103             BNE.N    ??RTC_SetAlarm_10
   1206            {
   1207              RTC->ALRMAR = (uint32_t)tmpreg;
   \       0xCE   0x....'....        LDR.W    R1,??DataTable44_4  ;; 0x4000281c
   \       0xD2   0x600C             STR      R4,[R1, #+0]
   \       0xD4   0xE002             B.N      ??RTC_SetAlarm_11
   1208            }
   1209            else
   1210            {
   1211              RTC->ALRMBR = (uint32_t)tmpreg;
   \                     ??RTC_SetAlarm_10: (+1)
   \       0xD6   0x....'....        LDR.W    R1,??DataTable44_5  ;; 0x40002820
   \       0xDA   0x600C             STR      R4,[R1, #+0]
   1212            }
   1213          
   1214            /* Enable the write protection for RTC registers */
   1215            RTC->WPR = 0xFF;   
   \                     ??RTC_SetAlarm_11: (+1)
   \       0xDC   0x21FF             MOVS     R1,#+255
   \       0xDE   0x6001             STR      R1,[R0, #+0]
   1216          }
   \       0xE0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1217          
   1218          /**
   1219            * @brief  Fills each RTC_AlarmStruct member with its default value
   1220            *         (Time = 00h:00mn:00sec / Date = 1st day of the month/Mask =
   1221            *         all fields are masked).
   1222            * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
   1223            *         will be initialized.
   1224            * @retval None
   1225            */

   \                                 In section .text, align 2, keep-with-next
   1226          void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
   1227          {
   1228            /* Alarm Time Settings : Time = 00h:00mn:00sec */
   1229            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
   \                     RTC_AlarmStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x70C1             STRB     R1,[R0, #+3]
   1230            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x7001             STRB     R1,[R0, #+0]
   1231            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x7041             STRB     R1,[R0, #+1]
   1232            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x7081             STRB     R1,[R0, #+2]
   1233          
   1234            /* Alarm Date Settings : Date = 1st day of the month */
   1235            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x6081             STR      R1,[R0, #+8]
   1236            RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x7301             STRB     R1,[R0, #+12]
   1237          
   1238            /* Alarm Masks Settings : Mask =  all fields are not masked */
   1239            RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6041             STR      R1,[R0, #+4]
   1240          }
   \       0x1C   0x4770             BX       LR               ;; return
   1241          
   1242          /**
   1243            * @brief  Get the RTC Alarm value and masks.
   1244            * @param  RTC_Format: specifies the format of the output parameters.
   1245            *          This parameter can be one of the following values:
   1246            *            @arg RTC_Format_BIN: Binary data format 
   1247            *            @arg RTC_Format_BCD: BCD data format
   1248            * @param  RTC_Alarm: specifies the alarm to be read.
   1249            *          This parameter can be one of the following values:
   1250            *            @arg RTC_Alarm_A: to select Alarm A
   1251            *            @arg RTC_Alarm_B: to select Alarm B  
   1252            * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
   1253            *                          contains the output alarm configuration values.     
   1254            * @retval None
   1255            */

   \                                 In section .text, align 2, keep-with-next
   1256          void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
   1257          {
   \                     RTC_GetAlarm: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0014             MOVS     R4,R2
   1258            uint32_t tmpreg = 0;
   \        0x4   0x2200             MOVS     R2,#+0
   1259          
   1260            /* Check the parameters */
   1261            assert_param(IS_RTC_FORMAT(RTC_Format));
   1262            assert_param(IS_RTC_ALARM(RTC_Alarm)); 
   1263          
   1264            /* Get the RTC_ALRMxR register */
   1265            if (RTC_Alarm == RTC_Alarm_A)
   \        0x6   0xF5B1 0x7F80      CMP      R1,#+256
   \        0xA   0xD103             BNE.N    ??RTC_GetAlarm_0
   1266            {
   1267              tmpreg = (uint32_t)(RTC->ALRMAR);
   \        0xC   0x....'....        LDR.W    R1,??DataTable44_4  ;; 0x4000281c
   \       0x10   0x6809             LDR      R1,[R1, #+0]
   \       0x12   0xE002             B.N      ??RTC_GetAlarm_1
   1268            }
   1269            else
   1270            {
   1271              tmpreg = (uint32_t)(RTC->ALRMBR);
   \                     ??RTC_GetAlarm_0: (+1)
   \       0x14   0x....'....        LDR.W    R1,??DataTable44_5  ;; 0x40002820
   \       0x18   0x6809             LDR      R1,[R1, #+0]
   1272            }
   1273          
   1274            /* Fill the structure with the read parameters */
   1275            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
   1276                                                               RTC_ALRMAR_HU)) >> 16);
   \                     ??RTC_GetAlarm_1: (+1)
   \       0x1A   0x000A             MOVS     R2,R1
   \       0x1C   0x0C12             LSRS     R2,R2,#+16
   \       0x1E   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \       0x22   0x7022             STRB     R2,[R4, #+0]
   1277            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
   1278                                                               RTC_ALRMAR_MNU)) >> 8);
   \       0x24   0x000A             MOVS     R2,R1
   \       0x26   0x0A12             LSRS     R2,R2,#+8
   \       0x28   0xF012 0x027F      ANDS     R2,R2,#0x7F
   \       0x2C   0x7062             STRB     R2,[R4, #+1]
   1279            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
   1280                                                               RTC_ALRMAR_SU));
   \       0x2E   0xF011 0x027F      ANDS     R2,R1,#0x7F
   \       0x32   0x70A2             STRB     R2,[R4, #+2]
   1281            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
   \       0x34   0x000A             MOVS     R2,R1
   \       0x36   0x0C12             LSRS     R2,R2,#+16
   \       0x38   0xF012 0x0240      ANDS     R2,R2,#0x40
   \       0x3C   0x70E2             STRB     R2,[R4, #+3]
   1282            RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
   \       0x3E   0x000A             MOVS     R2,R1
   \       0x40   0x0E12             LSRS     R2,R2,#+24
   \       0x42   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \       0x46   0x7322             STRB     R2,[R4, #+12]
   1283            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
   \       0x48   0xF011 0x4280      ANDS     R2,R1,#0x40000000
   \       0x4C   0x60A2             STR      R2,[R4, #+8]
   1284            RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
   \       0x4E   0xF031 0x317F      BICS     R1,R1,#0x7F7F7F7F
   \       0x52   0x6061             STR      R1,[R4, #+4]
   1285          
   1286            if (RTC_Format == RTC_Format_BIN)
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD10F             BNE.N    ??RTC_GetAlarm_2
   1287            {
   1288              RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1289                                                                  RTC_AlarmTime.RTC_Hours);
   \       0x58   0x7820             LDRB     R0,[R4, #+0]
   \       0x5A   0x....'....        BL       RTC_Bcd2ToByte
   \       0x5E   0x7020             STRB     R0,[R4, #+0]
   1290              RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1291                                                                  RTC_AlarmTime.RTC_Minutes);
   \       0x60   0x7860             LDRB     R0,[R4, #+1]
   \       0x62   0x....'....        BL       RTC_Bcd2ToByte
   \       0x66   0x7060             STRB     R0,[R4, #+1]
   1292              RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1293                                                                  RTC_AlarmTime.RTC_Seconds);
   \       0x68   0x78A0             LDRB     R0,[R4, #+2]
   \       0x6A   0x....'....        BL       RTC_Bcd2ToByte
   \       0x6E   0x70A0             STRB     R0,[R4, #+2]
   1294              RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \       0x70   0x7B20             LDRB     R0,[R4, #+12]
   \       0x72   0x....'....        BL       RTC_Bcd2ToByte
   \       0x76   0x7320             STRB     R0,[R4, #+12]
   1295            }  
   1296          }
   \                     ??RTC_GetAlarm_2: (+1)
   \       0x78   0xBD10             POP      {R4,PC}          ;; return
   1297          
   1298          /**
   1299            * @brief  Enables or disables the specified RTC Alarm.
   1300            * @param  RTC_Alarm: specifies the alarm to be configured.
   1301            *          This parameter can be any combination of the following values:
   1302            *            @arg RTC_Alarm_A: to select Alarm A
   1303            *            @arg RTC_Alarm_B: to select Alarm B  
   1304            * @param  NewState: new state of the specified alarm.
   1305            *          This parameter can be: ENABLE or DISABLE.
   1306            * @retval An ErrorStatus enumeration value:
   1307            *          - SUCCESS: RTC Alarm is enabled/disabled
   1308            *          - ERROR: RTC Alarm is not enabled/disabled  
   1309            */

   \                                 In section .text, align 2, keep-with-next
   1310          ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
   1311          {
   \                     RTC_AlarmCmd: (+1)
   \        0x0   0xB418             PUSH     {R3,R4}
   \        0x2   0x0002             MOVS     R2,R0
   1312            __IO uint32_t alarmcounter = 0x00;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
   1313            uint32_t alarmstatus = 0x00;
   \        0x8   0x2000             MOVS     R0,#+0
   1314            ErrorStatus status = ERROR;
   \        0xA   0x2000             MOVS     R0,#+0
   1315              
   1316            /* Check the parameters */
   1317            assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
   1318            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1319          
   1320            /* Disable the write protection for RTC registers */
   1321            RTC->WPR = 0xCA;
   \        0xC   0x....'....        LDR.W    R3,??DataTable41  ;; 0x40002824
   \       0x10   0x20CA             MOVS     R0,#+202
   \       0x12   0x6018             STR      R0,[R3, #+0]
   1322            RTC->WPR = 0x53;
   \       0x14   0x2053             MOVS     R0,#+83
   \       0x16   0x6018             STR      R0,[R3, #+0]
   1323          
   1324            /* Configure the Alarm state */
   1325            if (NewState != DISABLE)
   \       0x18   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x1A   0x2900             CMP      R1,#+0
   \       0x1C   0xD006             BEQ.N    ??RTC_AlarmCmd_0
   1326            {
   1327              RTC->CR |= (uint32_t)RTC_Alarm;
   \       0x1E   0x....'....        LDR.W    R0,??DataTable43_1  ;; 0x40002808
   \       0x22   0x6801             LDR      R1,[R0, #+0]
   \       0x24   0x430A             ORRS     R2,R2,R1
   \       0x26   0x6002             STR      R2,[R0, #+0]
   1328          
   1329              status = SUCCESS;    
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE019             B.N      ??RTC_AlarmCmd_1
   1330            }
   1331            else
   1332            { 
   1333              /* Disable the Alarm in RTC_CR register */
   1334              RTC->CR &= (uint32_t)~RTC_Alarm;
   \                     ??RTC_AlarmCmd_0: (+1)
   \       0x2C   0x....'....        LDR.W    R0,??DataTable43_1  ;; 0x40002808
   \       0x30   0x6801             LDR      R1,[R0, #+0]
   \       0x32   0x4391             BICS     R1,R1,R2
   \       0x34   0x6001             STR      R1,[R0, #+0]
   1335             
   1336              /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
   1337              do
   1338              {
   1339                alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
   \                     ??RTC_AlarmCmd_2: (+1)
   \       0x36   0x....'....        LDR.W    R1,??DataTable50_6  ;; 0x4000280c
   \       0x3A   0x6808             LDR      R0,[R1, #+0]
   \       0x3C   0xEA10 0x2012      ANDS     R0,R0,R2, LSR #+8
   1340                alarmcounter++;  
   \       0x40   0x9C00             LDR      R4,[SP, #+0]
   \       0x42   0x1C64             ADDS     R4,R4,#+1
   \       0x44   0x9400             STR      R4,[SP, #+0]
   1341              } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
   \       0x46   0x9C00             LDR      R4,[SP, #+0]
   \       0x48   0xF5B4 0x3F80      CMP      R4,#+65536
   \       0x4C   0xD001             BEQ.N    ??RTC_AlarmCmd_3
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD0F1             BEQ.N    ??RTC_AlarmCmd_2
   1342              
   1343              if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
   \                     ??RTC_AlarmCmd_3: (+1)
   \       0x52   0x6808             LDR      R0,[R1, #+0]
   \       0x54   0xEA10 0x2F12      TST      R0,R2, LSR #+8
   \       0x58   0xD101             BNE.N    ??RTC_AlarmCmd_4
   1344              {
   1345                status = ERROR;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xE000             B.N      ??RTC_AlarmCmd_1
   1346              } 
   1347              else
   1348              {
   1349                status = SUCCESS;
   \                     ??RTC_AlarmCmd_4: (+1)
   \       0x5E   0x2001             MOVS     R0,#+1
   1350              }        
   1351            } 
   1352          
   1353            /* Enable the write protection for RTC registers */
   1354            RTC->WPR = 0xFF; 
   \                     ??RTC_AlarmCmd_1: (+1)
   \       0x60   0x21FF             MOVS     R1,#+255
   \       0x62   0x6019             STR      R1,[R3, #+0]
   1355            
   1356            return status;
   \       0x64   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x66   0xBC12             POP      {R1,R4}
   \       0x68   0x4770             BX       LR               ;; return
   1357          }
   1358          
   1359          /**
   1360            * @brief  Configure the RTC AlarmA/B Sub seconds value and mask.*
   1361            * @note   This function is performed only when the Alarm is disabled. 
   1362            * @param  RTC_Alarm: specifies the alarm to be configured.
   1363            *   This parameter can be one of the following values:
   1364            *     @arg RTC_Alarm_A: to select Alarm A
   1365            *     @arg RTC_Alarm_B: to select Alarm B
   1366            * @param  RTC_AlarmSubSecondValue: specifies the Sub seconds value.
   1367            *   This parameter can be a value from 0 to 0x00007FFF.
   1368            * @param  RTC_AlarmSubSecondMask:  specifies the Sub seconds Mask.
   1369            *   This parameter can be any combination of the following values:
   1370            *     @arg RTC_AlarmSubSecondMask_All    : All Alarm SS fields are masked.
   1371            *                                          There is no comparison on sub seconds for Alarm.
   1372            *     @arg RTC_AlarmSubSecondMask_SS14_1 : SS[14:1] are don't care in Alarm comparison.
   1373            *                                          Only SS[0] is compared
   1374            *     @arg RTC_AlarmSubSecondMask_SS14_2 : SS[14:2] are don't care in Alarm comparison.
   1375            *                                          Only SS[1:0] are compared
   1376            *     @arg RTC_AlarmSubSecondMask_SS14_3 : SS[14:3] are don't care in Alarm comparison.
   1377            *                                          Only SS[2:0] are compared
   1378            *     @arg RTC_AlarmSubSecondMask_SS14_4 : SS[14:4] are don't care in Alarm comparison.
   1379            *                                          Only SS[3:0] are compared
   1380            *     @arg RTC_AlarmSubSecondMask_SS14_5 : SS[14:5] are don't care in Alarm comparison.
   1381            *                                          Only SS[4:0] are compared
   1382            *     @arg RTC_AlarmSubSecondMask_SS14_6 : SS[14:6] are don't care in Alarm comparison.
   1383            *                                          Only SS[5:0] are compared
   1384            *     @arg RTC_AlarmSubSecondMask_SS14_7 : SS[14:7] are don't care in Alarm comparison.
   1385            *                                          Only SS[6:0] are compared
   1386            *     @arg RTC_AlarmSubSecondMask_SS14_8 : SS[14:8] are don't care in Alarm comparison.
   1387            *                                          Only SS[7:0] are compared
   1388            *     @arg RTC_AlarmSubSecondMask_SS14_9 : SS[14:9] are don't care in Alarm comparison.
   1389            *                                          Only SS[8:0] are compared
   1390            *     @arg RTC_AlarmSubSecondMask_SS14_10: SS[14:10] are don't care in Alarm comparison.
   1391            *                                          Only SS[9:0] are compared
   1392            *     @arg RTC_AlarmSubSecondMask_SS14_11: SS[14:11] are don't care in Alarm comparison.
   1393            *                                          Only SS[10:0] are compared
   1394            *     @arg RTC_AlarmSubSecondMask_SS14_12: SS[14:12] are don't care in Alarm comparison.
   1395            *                                          Only SS[11:0] are compared
   1396            *     @arg RTC_AlarmSubSecondMask_SS14_13: SS[14:13] are don't care in Alarm comparison.
   1397            *                                          Only SS[12:0] are compared
   1398            *     @arg RTC_AlarmSubSecondMask_SS14   : SS[14] is don't care in Alarm comparison.
   1399            *                                          Only SS[13:0] are compared
   1400            *     @arg RTC_AlarmSubSecondMask_None   : SS[14:0] are compared and must match
   1401            *                                          to activate alarm
   1402            * @retval None
   1403            */

   \                                 In section .text, align 2, keep-with-next
   1404          void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
   1405          {
   \                     RTC_AlarmSubSecondConfig: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1406            uint32_t tmpreg = 0;
   \        0x2   0x2300             MOVS     R3,#+0
   1407          
   1408            /* Check the parameters */
   1409            assert_param(IS_RTC_ALARM(RTC_Alarm));
   1410            assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
   1411            assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
   1412            
   1413            /* Disable the write protection for RTC registers */
   1414            RTC->WPR = 0xCA;
   \        0x4   0x....'....        LDR.W    R3,??DataTable41  ;; 0x40002824
   \        0x8   0x24CA             MOVS     R4,#+202
   \        0xA   0x601C             STR      R4,[R3, #+0]
   1415            RTC->WPR = 0x53;
   \        0xC   0x2453             MOVS     R4,#+83
   \        0xE   0x601C             STR      R4,[R3, #+0]
   1416            
   1417            /* Configure the Alarm A or Alarm B Sub Second registers */
   1418            tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
   \       0x10   0x4311             ORRS     R1,R2,R1
   1419            
   1420            if (RTC_Alarm == RTC_Alarm_A)
   \       0x12   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x16   0xD103             BNE.N    ??RTC_AlarmSubSecondConfig_0
   1421            {
   1422              /* Configure the Alarm A Sub Second register */
   1423              RTC->ALRMASSR = tmpreg;
   \       0x18   0x....'....        LDR.W    R0,??DataTable45_1  ;; 0x40002844
   \       0x1C   0x6001             STR      R1,[R0, #+0]
   \       0x1E   0xE002             B.N      ??RTC_AlarmSubSecondConfig_1
   1424            }
   1425            else
   1426            {
   1427              /* Configure the Alarm B Sub Second register */
   1428              RTC->ALRMBSSR = tmpreg;
   \                     ??RTC_AlarmSubSecondConfig_0: (+1)
   \       0x20   0x....'....        LDR.W    R0,??DataTable45_2  ;; 0x40002848
   \       0x24   0x6001             STR      R1,[R0, #+0]
   1429            }
   1430          
   1431            /* Enable the write protection for RTC registers */
   1432            RTC->WPR = 0xFF;
   \                     ??RTC_AlarmSubSecondConfig_1: (+1)
   \       0x26   0x20FF             MOVS     R0,#+255
   \       0x28   0x6018             STR      R0,[R3, #+0]
   1433          
   1434          }
   \       0x2A   0xBC10             POP      {R4}
   \       0x2C   0x4770             BX       LR               ;; return
   1435          
   1436          /**
   1437            * @brief  Gets the RTC Alarm Sub seconds value.
   1438            * @param  RTC_Alarm: specifies the alarm to be read.
   1439            *   This parameter can be one of the following values:
   1440            *     @arg RTC_Alarm_A: to select Alarm A
   1441            *     @arg RTC_Alarm_B: to select Alarm B
   1442            * @param  None
   1443            * @retval RTC Alarm Sub seconds value.
   1444            */

   \                                 In section .text, align 2, keep-with-next
   1445          uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
   1446          {
   1447            uint32_t tmpreg = 0;
   \                     RTC_GetAlarmSubSecond: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   1448            
   1449            /* Get the RTC_ALRMxR register */
   1450            if (RTC_Alarm == RTC_Alarm_A)
   \        0x2   0xF5B0 0x7F80      CMP      R0,#+256
   \        0x6   0xD105             BNE.N    ??RTC_GetAlarmSubSecond_0
   1451            {
   1452              tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
   \        0x8   0x....'....        LDR.W    R0,??DataTable45_1  ;; 0x40002844
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x0440             LSLS     R0,R0,#+17       ;; ZeroExtS R0,R0,#+17,#+17
   \       0x10   0x0C40             LSRS     R0,R0,#+17
   \       0x12   0xE004             B.N      ??RTC_GetAlarmSubSecond_1
   1453            }
   1454            else
   1455            {
   1456              tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
   \                     ??RTC_GetAlarmSubSecond_0: (+1)
   \       0x14   0x....'....        LDR.W    R0,??DataTable45_2  ;; 0x40002848
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x0440             LSLS     R0,R0,#+17       ;; ZeroExtS R0,R0,#+17,#+17
   \       0x1C   0x0C40             LSRS     R0,R0,#+17
   1457            } 
   1458            
   1459            return (tmpreg);
   \                     ??RTC_GetAlarmSubSecond_1: (+1)
   \       0x1E   0x4770             BX       LR               ;; return
   1460          }
   1461          
   1462          /**
   1463            * @}
   1464            */
   1465          
   1466          /** @defgroup RTC_Group4 WakeUp Timer configuration functions
   1467           *  @brief   WakeUp Timer configuration functions 
   1468           *
   1469          @verbatim   
   1470           ===============================================================================
   1471                           ##### WakeUp Timer configuration functions #####
   1472           ===============================================================================  
   1473          
   1474           [..] This section provide functions allowing to program and read the RTC WakeUp.
   1475          
   1476          @endverbatim
   1477            * @{
   1478            */
   1479          
   1480          /**
   1481            * @brief  Configures the RTC Wakeup clock source.
   1482            * @note   The WakeUp Clock source can only be changed when the RTC WakeUp
   1483            *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).      
   1484            * @param  RTC_WakeUpClock: Wakeup Clock source.
   1485            *          This parameter can be one of the following values:
   1486            *            @arg RTC_WakeUpClock_RTCCLK_Div16: RTC Wakeup Counter Clock = RTCCLK/16
   1487            *            @arg RTC_WakeUpClock_RTCCLK_Div8: RTC Wakeup Counter Clock = RTCCLK/8
   1488            *            @arg RTC_WakeUpClock_RTCCLK_Div4: RTC Wakeup Counter Clock = RTCCLK/4
   1489            *            @arg RTC_WakeUpClock_RTCCLK_Div2: RTC Wakeup Counter Clock = RTCCLK/2
   1490            *            @arg RTC_WakeUpClock_CK_SPRE_16bits: RTC Wakeup Counter Clock = CK_SPRE
   1491            *            @arg RTC_WakeUpClock_CK_SPRE_17bits: RTC Wakeup Counter Clock = CK_SPRE
   1492            * @retval None
   1493            */

   \                                 In section .text, align 2, keep-with-next
   1494          void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
   1495          {
   1496            /* Check the parameters */
   1497            assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
   1498          
   1499            /* Disable the write protection for RTC registers */
   1500            RTC->WPR = 0xCA;
   \                     RTC_WakeUpClockConfig: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable41  ;; 0x40002824
   \        0x4   0x22CA             MOVS     R2,#+202
   \        0x6   0x600A             STR      R2,[R1, #+0]
   1501            RTC->WPR = 0x53;
   \        0x8   0x2253             MOVS     R2,#+83
   \        0xA   0x600A             STR      R2,[R1, #+0]
   1502          
   1503            /* Clear the Wakeup Timer clock source bits in CR register */
   1504            RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
   \        0xC   0x....'....        LDR.W    R2,??DataTable50_2  ;; 0x40002808
   \       0x10   0x6813             LDR      R3,[R2, #+0]
   \       0x12   0x08DB             LSRS     R3,R3,#+3
   \       0x14   0x00DB             LSLS     R3,R3,#+3
   \       0x16   0x6013             STR      R3,[R2, #+0]
   1505          
   1506            /* Configure the clock source */
   1507            RTC->CR |= (uint32_t)RTC_WakeUpClock;
   \       0x18   0x6813             LDR      R3,[R2, #+0]
   \       0x1A   0x4318             ORRS     R0,R0,R3
   \       0x1C   0x6010             STR      R0,[R2, #+0]
   1508            
   1509            /* Enable the write protection for RTC registers */
   1510            RTC->WPR = 0xFF; 
   \       0x1E   0x20FF             MOVS     R0,#+255
   \       0x20   0x6008             STR      R0,[R1, #+0]
   1511          }
   \       0x22   0x4770             BX       LR               ;; return
   1512          
   1513          /**
   1514            * @brief  Configures the RTC Wakeup counter.
   1515            * @note   The RTC WakeUp counter can only be written when the RTC WakeUp
   1516            *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).        
   1517            * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
   1518            *          This parameter can be a value from 0x0000 to 0xFFFF. 
   1519            * @retval None
   1520            */

   \                                 In section .text, align 2, keep-with-next
   1521          void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
   1522          {
   1523            /* Check the parameters */
   1524            assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
   1525            
   1526            /* Disable the write protection for RTC registers */
   1527            RTC->WPR = 0xCA;
   \                     RTC_SetWakeUpCounter: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable41  ;; 0x40002824
   \        0x4   0x22CA             MOVS     R2,#+202
   \        0x6   0x600A             STR      R2,[R1, #+0]
   1528            RTC->WPR = 0x53;
   \        0x8   0x2253             MOVS     R2,#+83
   \        0xA   0x600A             STR      R2,[R1, #+0]
   1529            
   1530            /* Configure the Wakeup Timer counter */
   1531            RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
   \        0xC   0x....'....        LDR.W    R2,??DataTable44  ;; 0x40002814
   \       0x10   0x6010             STR      R0,[R2, #+0]
   1532            
   1533            /* Enable the write protection for RTC registers */
   1534            RTC->WPR = 0xFF; 
   \       0x12   0x20FF             MOVS     R0,#+255
   \       0x14   0x6008             STR      R0,[R1, #+0]
   1535          }
   \       0x16   0x4770             BX       LR               ;; return
   1536          
   1537          /**
   1538            * @brief  Returns the RTC WakeUp timer counter value.
   1539            * @param  None
   1540            * @retval The RTC WakeUp Counter value.
   1541            */

   \                                 In section .text, align 2, keep-with-next
   1542          uint32_t RTC_GetWakeUpCounter(void)
   1543          {
   1544            /* Get the counter value */
   1545            return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
   \                     RTC_GetWakeUpCounter: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable44  ;; 0x40002814
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \        0x8   0x4770             BX       LR               ;; return
   1546          }
   1547          
   1548          /**
   1549            * @brief  Enables or Disables the RTC WakeUp timer.
   1550            * @param  NewState: new state of the WakeUp timer.
   1551            *          This parameter can be: ENABLE or DISABLE.
   1552            * @retval None
   1553            */

   \                                 In section .text, align 2, keep-with-next
   1554          ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
   1555          {
   \                     RTC_WakeUpCmd: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   1556            __IO uint32_t wutcounter = 0x00;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x9100             STR      R1,[SP, #+0]
   1557            uint32_t wutwfstatus = 0x00;
   \        0x6   0x2100             MOVS     R1,#+0
   1558            ErrorStatus status = ERROR;
   \        0x8   0x2100             MOVS     R1,#+0
   1559            
   1560            /* Check the parameters */
   1561            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1562          
   1563            /* Disable the write protection for RTC registers */
   1564            RTC->WPR = 0xCA;
   \        0xA   0x....'....        LDR.W    R1,??DataTable41  ;; 0x40002824
   \        0xE   0x22CA             MOVS     R2,#+202
   \       0x10   0x600A             STR      R2,[R1, #+0]
   1565            RTC->WPR = 0x53;
   \       0x12   0x2253             MOVS     R2,#+83
   \       0x14   0x600A             STR      R2,[R1, #+0]
   1566          
   1567            if (NewState != DISABLE)
   \       0x16   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD007             BEQ.N    ??RTC_WakeUpCmd_0
   1568            {
   1569              /* Enable the Wakeup Timer */
   1570              RTC->CR |= (uint32_t)RTC_CR_WUTE;
   \       0x1C   0x....'....        LDR.W    R0,??DataTable43_1  ;; 0x40002808
   \       0x20   0x6802             LDR      R2,[R0, #+0]
   \       0x22   0xF452 0x6280      ORRS     R2,R2,#0x400
   \       0x26   0x6002             STR      R2,[R0, #+0]
   1571              status = SUCCESS;    
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE019             B.N      ??RTC_WakeUpCmd_1
   1572            }
   1573            else
   1574            {
   1575              /* Disable the Wakeup Timer */
   1576              RTC->CR &= (uint32_t)~RTC_CR_WUTE;
   \                     ??RTC_WakeUpCmd_0: (+1)
   \       0x2C   0x....'....        LDR.W    R0,??DataTable43_1  ;; 0x40002808
   \       0x30   0x6802             LDR      R2,[R0, #+0]
   \       0x32   0xF432 0x6280      BICS     R2,R2,#0x400
   \       0x36   0x6002             STR      R2,[R0, #+0]
   1577              /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
   1578              do
   1579              {
   1580                wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
   \                     ??RTC_WakeUpCmd_2: (+1)
   \       0x38   0x....'....        LDR.W    R2,??DataTable50_6  ;; 0x4000280c
   \       0x3C   0x6810             LDR      R0,[R2, #+0]
   \       0x3E   0xF010 0x0004      ANDS     R0,R0,#0x4
   1581                wutcounter++;  
   \       0x42   0x9B00             LDR      R3,[SP, #+0]
   \       0x44   0x1C5B             ADDS     R3,R3,#+1
   \       0x46   0x9300             STR      R3,[SP, #+0]
   1582              } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
   \       0x48   0x9B00             LDR      R3,[SP, #+0]
   \       0x4A   0xF5B3 0x3F80      CMP      R3,#+65536
   \       0x4E   0xD001             BEQ.N    ??RTC_WakeUpCmd_3
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD0F1             BEQ.N    ??RTC_WakeUpCmd_2
   1583              
   1584              if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
   \                     ??RTC_WakeUpCmd_3: (+1)
   \       0x54   0x6810             LDR      R0,[R2, #+0]
   \       0x56   0x0740             LSLS     R0,R0,#+29
   \       0x58   0xD401             BMI.N    ??RTC_WakeUpCmd_4
   1585              {
   1586                status = ERROR;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xE000             B.N      ??RTC_WakeUpCmd_1
   1587              }
   1588              else
   1589              {
   1590                status = SUCCESS;
   \                     ??RTC_WakeUpCmd_4: (+1)
   \       0x5E   0x2001             MOVS     R0,#+1
   1591              }    
   1592            }
   1593          
   1594            /* Enable the write protection for RTC registers */
   1595            RTC->WPR = 0xFF; 
   \                     ??RTC_WakeUpCmd_1: (+1)
   \       0x60   0x22FF             MOVS     R2,#+255
   \       0x62   0x600A             STR      R2,[R1, #+0]
   1596            
   1597            return status;
   \       0x64   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x66   0xB001             ADD      SP,SP,#+4
   \       0x68   0x4770             BX       LR               ;; return
   1598          }
   1599          
   1600          /**
   1601            * @}
   1602            */
   1603          
   1604          /** @defgroup RTC_Group5 Daylight Saving configuration functions
   1605           *  @brief   Daylight Saving configuration functions 
   1606           *
   1607          @verbatim   
   1608           ===============================================================================
   1609                        ##### Daylight Saving configuration functions #####
   1610           ===============================================================================  
   1611          
   1612           [..] This section provide functions allowing to configure the RTC DayLight Saving.
   1613          
   1614          @endverbatim
   1615            * @{
   1616            */
   1617          
   1618          /**
   1619            * @brief  Adds or substract one hour from the current time.
   1620            * @param  RTC_DayLightSaveOperation: the value of hour adjustment. 
   1621            *          This parameter can be one of the following values:
   1622            *            @arg RTC_DayLightSaving_SUB1H: Substract one hour (winter time)
   1623            *            @arg RTC_DayLightSaving_ADD1H: Add one hour (summer time)
   1624            * @param  RTC_StoreOperation: Specifies the value to be written in the BCK bit 
   1625            *                            in CR register to store the operation.
   1626            *          This parameter can be one of the following values:
   1627            *            @arg RTC_StoreOperation_Reset: BCK Bit Reset
   1628            *            @arg RTC_StoreOperation_Set: BCK Bit Set
   1629            * @retval None
   1630            */

   \                                 In section .text, align 2, keep-with-next
   1631          void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
   1632          {
   \                     RTC_DayLightSavingConfig: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1633            /* Check the parameters */
   1634            assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
   1635            assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
   1636          
   1637            /* Disable the write protection for RTC registers */
   1638            RTC->WPR = 0xCA;
   \        0x2   0x....             LDR.N    R2,??DataTable41  ;; 0x40002824
   \        0x4   0x23CA             MOVS     R3,#+202
   \        0x6   0x6013             STR      R3,[R2, #+0]
   1639            RTC->WPR = 0x53;
   \        0x8   0x2353             MOVS     R3,#+83
   \        0xA   0x6013             STR      R3,[R2, #+0]
   1640          
   1641            /* Clear the bits to be configured */
   1642            RTC->CR &= (uint32_t)~(RTC_CR_BCK);
   \        0xC   0x....'....        LDR.W    R3,??DataTable50_2  ;; 0x40002808
   \       0x10   0x681C             LDR      R4,[R3, #+0]
   \       0x12   0xF434 0x2480      BICS     R4,R4,#0x40000
   \       0x16   0x601C             STR      R4,[R3, #+0]
   1643          
   1644            /* Configure the RTC_CR register */
   1645            RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
   \       0x18   0x681C             LDR      R4,[R3, #+0]
   \       0x1A   0x4308             ORRS     R0,R1,R0
   \       0x1C   0x4320             ORRS     R0,R0,R4
   \       0x1E   0x6018             STR      R0,[R3, #+0]
   1646          
   1647            /* Enable the write protection for RTC registers */
   1648            RTC->WPR = 0xFF; 
   \       0x20   0x20FF             MOVS     R0,#+255
   \       0x22   0x6010             STR      R0,[R2, #+0]
   1649          }
   \       0x24   0xBC10             POP      {R4}
   \       0x26   0x4770             BX       LR               ;; return
   1650          
   1651          /**
   1652            * @brief  Returns the RTC Day Light Saving stored operation.
   1653            * @param  None
   1654            * @retval RTC Day Light Saving stored operation.
   1655            *          - RTC_StoreOperation_Reset
   1656            *          - RTC_StoreOperation_Set       
   1657            */

   \                                 In section .text, align 2, keep-with-next
   1658          uint32_t RTC_GetStoreOperation(void)
   1659          {
   1660            return (RTC->CR & RTC_CR_BCK);
   \                     RTC_GetStoreOperation: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable50_2  ;; 0x40002808
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0xF410 0x2080      ANDS     R0,R0,#0x40000
   \        0xA   0x4770             BX       LR               ;; return
   1661          }
   1662          
   1663          /**
   1664            * @}
   1665            */
   1666          
   1667          /** @defgroup RTC_Group6 Output pin Configuration function
   1668           *  @brief   Output pin Configuration function 
   1669           *
   1670          @verbatim   
   1671           ===============================================================================
   1672                           ##### Output pin Configuration function #####
   1673           ===============================================================================  
   1674          
   1675           [..] This section provide functions allowing to configure the RTC Output source.
   1676          
   1677          @endverbatim
   1678            * @{
   1679            */
   1680          
   1681          /**
   1682            * @brief  Configures the RTC output source (AFO_ALARM).
   1683            * @param  RTC_Output: Specifies which signal will be routed to the RTC output. 
   1684            *          This parameter can be one of the following values:
   1685            *            @arg RTC_Output_Disable: No output selected
   1686            *            @arg RTC_Output_AlarmA: signal of AlarmA mapped to output
   1687            *            @arg RTC_Output_AlarmB: signal of AlarmB mapped to output
   1688            *            @arg RTC_Output_WakeUp: signal of WakeUp mapped to output
   1689            * @param  RTC_OutputPolarity: Specifies the polarity of the output signal. 
   1690            *          This parameter can be one of the following:
   1691            *            @arg RTC_OutputPolarity_High: The output pin is high when the 
   1692            *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
   1693            *            @arg RTC_OutputPolarity_Low: The output pin is low when the 
   1694            *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
   1695            * @retval None
   1696            */

   \                                 In section .text, align 2, keep-with-next
   1697          void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
   1698          {
   \                     RTC_OutputConfig: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1699            /* Check the parameters */
   1700            assert_param(IS_RTC_OUTPUT(RTC_Output));
   1701            assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
   1702          
   1703            /* Disable the write protection for RTC registers */
   1704            RTC->WPR = 0xCA;
   \        0x2   0x....             LDR.N    R2,??DataTable41  ;; 0x40002824
   \        0x4   0x23CA             MOVS     R3,#+202
   \        0x6   0x6013             STR      R3,[R2, #+0]
   1705            RTC->WPR = 0x53;
   \        0x8   0x2353             MOVS     R3,#+83
   \        0xA   0x6013             STR      R3,[R2, #+0]
   1706          
   1707            /* Clear the bits to be configured */
   1708            RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
   \        0xC   0x....'....        LDR.W    R3,??DataTable50_2  ;; 0x40002808
   \       0x10   0x681C             LDR      R4,[R3, #+0]
   \       0x12   0xF434 0x04E0      BICS     R4,R4,#0x700000
   \       0x16   0x601C             STR      R4,[R3, #+0]
   1709          
   1710            /* Configure the output selection and polarity */
   1711            RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
   \       0x18   0x681C             LDR      R4,[R3, #+0]
   \       0x1A   0x4308             ORRS     R0,R1,R0
   \       0x1C   0x4320             ORRS     R0,R0,R4
   \       0x1E   0x6018             STR      R0,[R3, #+0]
   1712          
   1713            /* Enable the write protection for RTC registers */
   1714            RTC->WPR = 0xFF; 
   \       0x20   0x20FF             MOVS     R0,#+255
   \       0x22   0x6010             STR      R0,[R2, #+0]
   1715          }
   \       0x24   0xBC10             POP      {R4}
   \       0x26   0x4770             BX       LR               ;; return
   1716          
   1717          /**
   1718            * @}
   1719            */
   1720          
   1721          /** @defgroup RTC_Group7 Digital Calibration configuration functions
   1722           *  @brief   Coarse Calibration configuration functions 
   1723           *
   1724          @verbatim   
   1725           ===============================================================================
   1726                        ##### Digital Calibration configuration functions #####
   1727           ===============================================================================  
   1728          
   1729          @endverbatim
   1730            * @{
   1731            */
   1732          
   1733          /**
   1734            * @brief  Configures the Coarse calibration parameters.
   1735            * @param  RTC_CalibSign: specifies the sign of the coarse calibration value.
   1736            *          This parameter can be  one of the following values:
   1737            *            @arg RTC_CalibSign_Positive: The value sign is positive 
   1738            *            @arg RTC_CalibSign_Negative: The value sign is negative
   1739            * @param  Value: value of coarse calibration expressed in ppm (coded on 5 bits).
   1740            *    
   1741            * @note   This Calibration value should be between 0 and 63 when using negative
   1742            *         sign with a 2-ppm step.
   1743            *           
   1744            * @note   This Calibration value should be between 0 and 126 when using positive
   1745            *         sign with a 4-ppm step.
   1746            *           
   1747            * @retval An ErrorStatus enumeration value:
   1748            *          - SUCCESS: RTC Coarse calibration are initialized
   1749            *          - ERROR: RTC Coarse calibration are not initialized     
   1750            */

   \                                 In section .text, align 2, keep-with-next
   1751          ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
   1752          {
   \                     RTC_CoarseCalibConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1753            ErrorStatus status = ERROR;
   \        0x6   0x2000             MOVS     R0,#+0
   1754             
   1755            /* Check the parameters */
   1756            assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
   1757            assert_param(IS_RTC_CALIB_VALUE(Value)); 
   1758          
   1759            /* Disable the write protection for RTC registers */
   1760            RTC->WPR = 0xCA;
   \        0x8   0x....             LDR.N    R6,??DataTable41  ;; 0x40002824
   \        0xA   0x20CA             MOVS     R0,#+202
   \        0xC   0x6030             STR      R0,[R6, #+0]
   1761            RTC->WPR = 0x53;
   \        0xE   0x2053             MOVS     R0,#+83
   \       0x10   0x6030             STR      R0,[R6, #+0]
   1762          
   1763            /* Set Initialization mode */
   1764            if (RTC_EnterInitMode() == ERROR)
   \       0x12   0x....'....        BL       RTC_EnterInitMode
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??RTC_CoarseCalibConfig_0
   1765            {
   1766              status = ERROR;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xE005             B.N      ??RTC_CoarseCalibConfig_1
   1767            } 
   1768            else
   1769            {
   1770              /* Set the coarse calibration value */
   1771              RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
   \                     ??RTC_CoarseCalibConfig_0: (+1)
   \       0x1E   0x432C             ORRS     R4,R5,R4
   \       0x20   0x....             LDR.N    R0,??DataTable44_3  ;; 0x40002818
   \       0x22   0x6004             STR      R4,[R0, #+0]
   1772              /* Exit Initialization mode */
   1773              RTC_ExitInitMode();
   \       0x24   0x....'....        BL       RTC_ExitInitMode
   1774              
   1775              status = SUCCESS;
   \       0x28   0x2001             MOVS     R0,#+1
   1776            } 
   1777          
   1778            /* Enable the write protection for RTC registers */
   1779            RTC->WPR = 0xFF; 
   \                     ??RTC_CoarseCalibConfig_1: (+1)
   \       0x2A   0x21FF             MOVS     R1,#+255
   \       0x2C   0x6031             STR      R1,[R6, #+0]
   1780            
   1781            return status;
   \       0x2E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x30   0xBD70             POP      {R4-R6,PC}       ;; return
   1782          }
   1783          
   1784          /**
   1785            * @brief  Enables or disables the Coarse calibration process.
   1786            * @param  NewState: new state of the Coarse calibration.
   1787            *          This parameter can be: ENABLE or DISABLE.
   1788            * @retval An ErrorStatus enumeration value:
   1789            *          - SUCCESS: RTC Coarse calibration are enabled/disabled
   1790            *          - ERROR: RTC Coarse calibration are not enabled/disabled    
   1791            */

   \                                 In section .text, align 2, keep-with-next
   1792          ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
   1793          {
   \                     RTC_CoarseCalibCmd: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1794            ErrorStatus status = ERROR;
   \        0x4   0x2000             MOVS     R0,#+0
   1795            
   1796            /* Check the parameters */
   1797            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1798          
   1799            /* Disable the write protection for RTC registers */
   1800            RTC->WPR = 0xCA;
   \        0x6   0x....             LDR.N    R5,??DataTable41  ;; 0x40002824
   \        0x8   0x20CA             MOVS     R0,#+202
   \        0xA   0x6028             STR      R0,[R5, #+0]
   1801            RTC->WPR = 0x53;
   \        0xC   0x2053             MOVS     R0,#+83
   \        0xE   0x6028             STR      R0,[R5, #+0]
   1802            
   1803            /* Set Initialization mode */
   1804            if (RTC_EnterInitMode() == ERROR)
   \       0x10   0x....'....        BL       RTC_EnterInitMode
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??RTC_CoarseCalibCmd_0
   1805            {
   1806              status =  ERROR;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xE012             B.N      ??RTC_CoarseCalibCmd_1
   1807            }
   1808            else
   1809            {
   1810              if (NewState != DISABLE)
   \                     ??RTC_CoarseCalibCmd_0: (+1)
   \       0x1C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD006             BEQ.N    ??RTC_CoarseCalibCmd_2
   1811              {
   1812                /* Enable the Coarse Calibration */
   1813                RTC->CR |= (uint32_t)RTC_CR_DCE;
   \       0x22   0x....'....        LDR.W    R0,??DataTable50_2  ;; 0x40002808
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0xF051 0x0180      ORRS     R1,R1,#0x80
   \       0x2C   0x6001             STR      R1,[R0, #+0]
   \       0x2E   0xE005             B.N      ??RTC_CoarseCalibCmd_3
   1814              }
   1815              else
   1816              { 
   1817                /* Disable the Coarse Calibration */
   1818                RTC->CR &= (uint32_t)~RTC_CR_DCE;
   \                     ??RTC_CoarseCalibCmd_2: (+1)
   \       0x30   0x....'....        LDR.W    R0,??DataTable50_2  ;; 0x40002808
   \       0x34   0x6801             LDR      R1,[R0, #+0]
   \       0x36   0xF031 0x0180      BICS     R1,R1,#0x80
   \       0x3A   0x6001             STR      R1,[R0, #+0]
   1819              }
   1820              /* Exit Initialization mode */
   1821              RTC_ExitInitMode();
   \                     ??RTC_CoarseCalibCmd_3: (+1)
   \       0x3C   0x....'....        BL       RTC_ExitInitMode
   1822              
   1823              status = SUCCESS;
   \       0x40   0x2001             MOVS     R0,#+1
   1824            } 
   1825            
   1826            /* Enable the write protection for RTC registers */
   1827            RTC->WPR = 0xFF; 
   \                     ??RTC_CoarseCalibCmd_1: (+1)
   \       0x42   0x21FF             MOVS     R1,#+255
   \       0x44   0x6029             STR      R1,[R5, #+0]
   1828            
   1829            return status;
   \       0x46   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x48   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1830          }
   1831          
   1832          /**
   1833            * @brief  Enables or disables the RTC clock to be output through the relative pin.
   1834            * @param  NewState: new state of the digital calibration Output.
   1835            *          This parameter can be: ENABLE or DISABLE.
   1836            * @retval None
   1837            */

   \                                 In section .text, align 2, keep-with-next
   1838          void RTC_CalibOutputCmd(FunctionalState NewState)
   1839          {
   1840            /* Check the parameters */
   1841            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1842            
   1843            /* Disable the write protection for RTC registers */
   1844            RTC->WPR = 0xCA;
   \                     RTC_CalibOutputCmd: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable41  ;; 0x40002824
   \        0x2   0x22CA             MOVS     R2,#+202
   \        0x4   0x600A             STR      R2,[R1, #+0]
   1845            RTC->WPR = 0x53;
   \        0x6   0x2253             MOVS     R2,#+83
   \        0x8   0x600A             STR      R2,[R1, #+0]
   1846            
   1847            if (NewState != DISABLE)
   \        0xA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD006             BEQ.N    ??RTC_CalibOutputCmd_0
   1848            {
   1849              /* Enable the RTC clock output */
   1850              RTC->CR |= (uint32_t)RTC_CR_COE;
   \       0x10   0x....'....        LDR.W    R0,??DataTable50_2  ;; 0x40002808
   \       0x14   0x6802             LDR      R2,[R0, #+0]
   \       0x16   0xF452 0x0200      ORRS     R2,R2,#0x800000
   \       0x1A   0x6002             STR      R2,[R0, #+0]
   \       0x1C   0xE005             B.N      ??RTC_CalibOutputCmd_1
   1851            }
   1852            else
   1853            { 
   1854              /* Disable the RTC clock output */
   1855              RTC->CR &= (uint32_t)~RTC_CR_COE;
   \                     ??RTC_CalibOutputCmd_0: (+1)
   \       0x1E   0x....'....        LDR.W    R0,??DataTable50_2  ;; 0x40002808
   \       0x22   0x6802             LDR      R2,[R0, #+0]
   \       0x24   0xF432 0x0200      BICS     R2,R2,#0x800000
   \       0x28   0x6002             STR      R2,[R0, #+0]
   1856            }
   1857            
   1858            /* Enable the write protection for RTC registers */
   1859            RTC->WPR = 0xFF; 
   \                     ??RTC_CalibOutputCmd_1: (+1)
   \       0x2A   0x20FF             MOVS     R0,#+255
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   1860          }
   \       0x2E   0x4770             BX       LR               ;; return
   1861          
   1862          /**
   1863            * @brief  Configure the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
   1864            * @param  RTC_CalibOutput : Select the Calibration output Selection .
   1865            *   This parameter can be one of the following values:
   1866            *     @arg RTC_CalibOutput_512Hz: A signal has a regular waveform at 512Hz. 
   1867            *     @arg RTC_CalibOutput_1Hz  : A signal has a regular waveform at 1Hz.
   1868            * @retval None
   1869          */

   \                                 In section .text, align 2, keep-with-next
   1870          void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
   1871          {
   1872            /* Check the parameters */
   1873            assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
   1874          
   1875            /* Disable the write protection for RTC registers */
   1876            RTC->WPR = 0xCA;
   \                     RTC_CalibOutputConfig: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable41  ;; 0x40002824
   \        0x2   0x22CA             MOVS     R2,#+202
   \        0x4   0x600A             STR      R2,[R1, #+0]
   1877            RTC->WPR = 0x53;
   \        0x6   0x2253             MOVS     R2,#+83
   \        0x8   0x600A             STR      R2,[R1, #+0]
   1878            
   1879            /*clear flags before configuration */
   1880            RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
   \        0xA   0x....'....        LDR.W    R2,??DataTable50_2  ;; 0x40002808
   \        0xE   0x6813             LDR      R3,[R2, #+0]
   \       0x10   0xF433 0x2300      BICS     R3,R3,#0x80000
   \       0x14   0x6013             STR      R3,[R2, #+0]
   1881          
   1882            /* Configure the RTC_CR register */
   1883            RTC->CR |= (uint32_t)RTC_CalibOutput;
   \       0x16   0x6813             LDR      R3,[R2, #+0]
   \       0x18   0x4318             ORRS     R0,R0,R3
   \       0x1A   0x6010             STR      R0,[R2, #+0]
   1884          
   1885            /* Enable the write protection for RTC registers */
   1886            RTC->WPR = 0xFF;
   \       0x1C   0x20FF             MOVS     R0,#+255
   \       0x1E   0x6008             STR      R0,[R1, #+0]
   1887          }
   \       0x20   0x4770             BX       LR               ;; return
   1888          
   1889          /**
   1890            * @brief  Configures the Smooth Calibration Settings.
   1891            * @param  RTC_SmoothCalibPeriod : Select the Smooth Calibration Period.
   1892            *   This parameter can be can be one of the following values:
   1893            *     @arg RTC_SmoothCalibPeriod_32sec : The smooth calibration period is 32s.
   1894            *     @arg RTC_SmoothCalibPeriod_16sec : The smooth calibration period is 16s.
   1895            *     @arg RTC_SmoothCalibPeriod_8sec  : The smooth calibration period is 8s.
   1896            * @param  RTC_SmoothCalibPlusPulses : Select to Set or reset the CALP bit.
   1897            *   This parameter can be one of the following values:
   1898            *     @arg RTC_SmoothCalibPlusPulses_Set  : Add one RTCCLK pulse every 2**11 pulses.
   1899            *     @arg RTC_SmoothCalibPlusPulses_Reset: No RTCCLK pulses are added.
   1900            * @param  RTC_SmouthCalibMinusPulsesValue: Select the value of CALM[8:0] bits.
   1901            *   This parameter can be one any value from 0 to 0x000001FF.
   1902            * @retval An ErrorStatus enumeration value:
   1903            *          - SUCCESS: RTC Calib registers are configured
   1904            *          - ERROR: RTC Calib registers are not configured
   1905          */

   \                                 In section .text, align 2, keep-with-next
   1906          ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
   1907                                            uint32_t RTC_SmoothCalibPlusPulses,
   1908                                            uint32_t RTC_SmouthCalibMinusPulsesValue)
   1909          {
   \                     RTC_SmoothCalibConfig: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   1910            ErrorStatus status = ERROR;
   \        0x2   0x2300             MOVS     R3,#+0
   1911            uint32_t recalpfcount = 0;
   \        0x4   0x2400             MOVS     R4,#+0
   1912          
   1913            /* Check the parameters */
   1914            assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
   1915            assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
   1916            assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
   1917          
   1918            /* Disable the write protection for RTC registers */
   1919            RTC->WPR = 0xCA;
   \        0x6   0x....             LDR.N    R3,??DataTable41  ;; 0x40002824
   \        0x8   0x25CA             MOVS     R5,#+202
   \        0xA   0x601D             STR      R5,[R3, #+0]
   1920            RTC->WPR = 0x53;
   \        0xC   0x2553             MOVS     R5,#+83
   \        0xE   0x601D             STR      R5,[R3, #+0]
   1921            
   1922            /* check if a calibration is pending*/
   1923            if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
   \       0x10   0x....'....        LDR.W    R5,??DataTable49  ;; 0x4000280c
   \       0x14   0x682E             LDR      R6,[R5, #+0]
   \       0x16   0x03F6             LSLS     R6,R6,#+15
   \       0x18   0xD401             BMI.N    ??RTC_SmoothCalibConfig_0
   \       0x1A   0xE006             B.N      ??RTC_SmoothCalibConfig_1
   1924            {
   1925              /* wait until the Calibration is completed*/
   1926              while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
   1927              {
   1928                recalpfcount++;
   \                     ??RTC_SmoothCalibConfig_2: (+1)
   \       0x1C   0x1C64             ADDS     R4,R4,#+1
   1929              }
   \                     ??RTC_SmoothCalibConfig_0: (+1)
   \       0x1E   0x682E             LDR      R6,[R5, #+0]
   \       0x20   0x03F6             LSLS     R6,R6,#+15
   \       0x22   0xD502             BPL.N    ??RTC_SmoothCalibConfig_1
   \       0x24   0xF5B4 0x3F00      CMP      R4,#+131072
   \       0x28   0xD1F8             BNE.N    ??RTC_SmoothCalibConfig_2
   1930            }
   1931          
   1932            /* check if the calibration pending is completed or if there is no calibration operation at all*/
   1933            if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
   \                     ??RTC_SmoothCalibConfig_1: (+1)
   \       0x2A   0x682C             LDR      R4,[R5, #+0]
   \       0x2C   0x03E4             LSLS     R4,R4,#+15
   \       0x2E   0xD405             BMI.N    ??RTC_SmoothCalibConfig_3
   1934            {
   1935              /* Configure the Smooth calibration settings */
   1936              RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
   \       0x30   0x4308             ORRS     R0,R1,R0
   \       0x32   0x4310             ORRS     R0,R2,R0
   \       0x34   0x....             LDR.N    R1,??DataTable45  ;; 0x4000283c
   \       0x36   0x6008             STR      R0,[R1, #+0]
   1937          
   1938              status = SUCCESS;
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0xE000             B.N      ??RTC_SmoothCalibConfig_4
   1939            }
   1940            else
   1941            {
   1942              status = ERROR;
   \                     ??RTC_SmoothCalibConfig_3: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   1943            }
   1944          
   1945            /* Enable the write protection for RTC registers */
   1946            RTC->WPR = 0xFF;
   \                     ??RTC_SmoothCalibConfig_4: (+1)
   \       0x3E   0x21FF             MOVS     R1,#+255
   \       0x40   0x6019             STR      R1,[R3, #+0]
   1947            
   1948            return (ErrorStatus)(status);
   \       0x42   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x44   0xBC70             POP      {R4-R6}
   \       0x46   0x4770             BX       LR               ;; return
   1949          }
   1950          
   1951          /**
   1952            * @}
   1953            */
   1954          
   1955          
   1956          /** @defgroup RTC_Group8 TimeStamp configuration functions
   1957           *  @brief   TimeStamp configuration functions 
   1958           *
   1959          @verbatim   
   1960           ===============================================================================
   1961                           ##### TimeStamp configuration functions #####
   1962           ===============================================================================  
   1963          
   1964          @endverbatim
   1965            * @{
   1966            */
   1967          
   1968          /**
   1969            * @brief  Enables or Disables the RTC TimeStamp functionality with the 
   1970            *         specified time stamp pin stimulating edge.
   1971            * @param  RTC_TimeStampEdge: Specifies the pin edge on which the TimeStamp is 
   1972            *         activated.
   1973            *          This parameter can be one of the following:
   1974            *            @arg RTC_TimeStampEdge_Rising: the Time stamp event occurs on the rising 
   1975            *                                    edge of the related pin.
   1976            *            @arg RTC_TimeStampEdge_Falling: the Time stamp event occurs on the 
   1977            *                                     falling edge of the related pin.
   1978            * @param  NewState: new state of the TimeStamp.
   1979            *          This parameter can be: ENABLE or DISABLE.
   1980            * @retval None
   1981            */

   \                                 In section .text, align 2, keep-with-next
   1982          void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
   1983          {
   \                     RTC_TimeStampCmd: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1984            uint32_t tmpreg = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   1985          
   1986            /* Check the parameters */
   1987            assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
   1988            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1989          
   1990            /* Get the RTC_CR register and clear the bits to be configured */
   1991            tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
   \        0x4   0x....             LDR.N    R4,??DataTable43_1  ;; 0x40002808
   \        0x6   0x6823             LDR      R3,[R4, #+0]
   \        0x8   0x....'....        LDR.W    R2,??DataTable50_7  ;; 0xfffff7f7
   \        0xC   0x4013             ANDS     R3,R2,R3
   1992          
   1993            /* Get the new configuration */
   1994            if (NewState != DISABLE)
   \        0xE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x10   0x2900             CMP      R1,#+0
   \       0x12   0xD003             BEQ.N    ??RTC_TimeStampCmd_0
   1995            {
   1996              tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
   \       0x14   0xF450 0x6000      ORRS     R0,R0,#0x800
   \       0x18   0x4318             ORRS     R0,R0,R3
   \       0x1A   0xE000             B.N      ??RTC_TimeStampCmd_1
   1997            }
   1998            else
   1999            {
   2000              tmpreg |= (uint32_t)(RTC_TimeStampEdge);
   \                     ??RTC_TimeStampCmd_0: (+1)
   \       0x1C   0x4318             ORRS     R0,R0,R3
   2001            }
   2002          
   2003            /* Disable the write protection for RTC registers */
   2004            RTC->WPR = 0xCA;
   \                     ??RTC_TimeStampCmd_1: (+1)
   \       0x1E   0x....             LDR.N    R1,??DataTable50_1  ;; 0x40002824
   \       0x20   0x22CA             MOVS     R2,#+202
   \       0x22   0x600A             STR      R2,[R1, #+0]
   2005            RTC->WPR = 0x53;
   \       0x24   0x2253             MOVS     R2,#+83
   \       0x26   0x600A             STR      R2,[R1, #+0]
   2006          
   2007            /* Configure the Time Stamp TSEDGE and Enable bits */
   2008            RTC->CR = (uint32_t)tmpreg;
   \       0x28   0x6020             STR      R0,[R4, #+0]
   2009          
   2010            /* Enable the write protection for RTC registers */
   2011            RTC->WPR = 0xFF; 
   \       0x2A   0x20FF             MOVS     R0,#+255
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   2012          }
   \       0x2E   0xBC10             POP      {R4}
   \       0x30   0x4770             BX       LR               ;; return
   2013          
   2014          /**
   2015            * @brief  Get the RTC TimeStamp value and masks.
   2016            * @param  RTC_Format: specifies the format of the output parameters.
   2017            *          This parameter can be one of the following values:
   2018            *            @arg RTC_Format_BIN: Binary data format 
   2019            *            @arg RTC_Format_BCD: BCD data format
   2020            * @param RTC_StampTimeStruct: pointer to a RTC_TimeTypeDef structure that will 
   2021            *                             contains the TimeStamp time values. 
   2022            * @param RTC_StampDateStruct: pointer to a RTC_DateTypeDef structure that will 
   2023            *                             contains the TimeStamp date values.     
   2024            * @retval None
   2025            */

   \                                 In section .text, align 2, keep-with-next
   2026          void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
   2027                                                RTC_DateTypeDef* RTC_StampDateStruct)
   2028          {
   \                     RTC_GetTimeStamp: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x000C             MOVS     R4,R1
   \        0x4   0x0015             MOVS     R5,R2
   2029            uint32_t tmptime = 0, tmpdate = 0;
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x2100             MOVS     R1,#+0
   2030          
   2031            /* Check the parameters */
   2032            assert_param(IS_RTC_FORMAT(RTC_Format));
   2033          
   2034            /* Get the TimeStamp time and date registers values */
   2035            tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
   \        0xA   0x....             LDR.N    R1,??DataTable50_8  ;; 0x40002830
   \        0xC   0x680A             LDR      R2,[R1, #+0]
   \        0xE   0x....             LDR.N    R1,??DataTable50_3  ;; 0x7f7f7f
   \       0x10   0x400A             ANDS     R2,R1,R2
   2036            tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
   \       0x12   0x....             LDR.N    R1,??DataTable50_9  ;; 0x40002834
   \       0x14   0x680B             LDR      R3,[R1, #+0]
   \       0x16   0x....             LDR.N    R1,??DataTable50_5  ;; 0xffff3f
   \       0x18   0x400B             ANDS     R3,R1,R3
   2037          
   2038            /* Fill the Time structure fields with the read parameters */
   2039            RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
   \       0x1A   0x0011             MOVS     R1,R2
   \       0x1C   0x0C09             LSRS     R1,R1,#+16
   \       0x1E   0xF011 0x013F      ANDS     R1,R1,#0x3F
   \       0x22   0x7021             STRB     R1,[R4, #+0]
   2040            RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
   \       0x24   0x0011             MOVS     R1,R2
   \       0x26   0x0A09             LSRS     R1,R1,#+8
   \       0x28   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \       0x2C   0x7061             STRB     R1,[R4, #+1]
   2041            RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
   \       0x2E   0xF012 0x017F      ANDS     R1,R2,#0x7F
   \       0x32   0x70A1             STRB     R1,[R4, #+2]
   2042            RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
   \       0x34   0x0C12             LSRS     R2,R2,#+16
   \       0x36   0xF012 0x0240      ANDS     R2,R2,#0x40
   \       0x3A   0x70E2             STRB     R2,[R4, #+3]
   2043          
   2044            /* Fill the Date structure fields with the read parameters */
   2045            RTC_StampDateStruct->RTC_Year = 0;
   \       0x3C   0x2100             MOVS     R1,#+0
   \       0x3E   0x70E9             STRB     R1,[R5, #+3]
   2046            RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
   \       0x40   0x0019             MOVS     R1,R3
   \       0x42   0x0A09             LSRS     R1,R1,#+8
   \       0x44   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \       0x48   0x7069             STRB     R1,[R5, #+1]
   2047            RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
   \       0x4A   0xF013 0x013F      ANDS     R1,R3,#0x3F
   \       0x4E   0x70A9             STRB     R1,[R5, #+2]
   2048            RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
   \       0x50   0x0B5B             LSRS     R3,R3,#+13
   \       0x52   0xF013 0x0307      ANDS     R3,R3,#0x7
   \       0x56   0x702B             STRB     R3,[R5, #+0]
   2049          
   2050            /* Check the input parameters format */
   2051            if (RTC_Format == RTC_Format_BIN)
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD117             BNE.N    ??RTC_GetTimeStamp_0
   2052            {
   2053              /* Convert the Time structure parameters to Binary format */
   2054              RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
   \       0x5C   0x7820             LDRB     R0,[R4, #+0]
   \       0x5E   0x....'....        BL       RTC_Bcd2ToByte
   \       0x62   0x7020             STRB     R0,[R4, #+0]
   2055              RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
   \       0x64   0x7860             LDRB     R0,[R4, #+1]
   \       0x66   0x....'....        BL       RTC_Bcd2ToByte
   \       0x6A   0x7060             STRB     R0,[R4, #+1]
   2056              RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
   \       0x6C   0x78A0             LDRB     R0,[R4, #+2]
   \       0x6E   0x....'....        BL       RTC_Bcd2ToByte
   \       0x72   0x70A0             STRB     R0,[R4, #+2]
   2057          
   2058              /* Convert the Date structure parameters to Binary format */
   2059              RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
   \       0x74   0x7868             LDRB     R0,[R5, #+1]
   \       0x76   0x....'....        BL       RTC_Bcd2ToByte
   \       0x7A   0x7068             STRB     R0,[R5, #+1]
   2060              RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
   \       0x7C   0x78A8             LDRB     R0,[R5, #+2]
   \       0x7E   0x....'....        BL       RTC_Bcd2ToByte
   \       0x82   0x70A8             STRB     R0,[R5, #+2]
   2061              RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
   \       0x84   0x7828             LDRB     R0,[R5, #+0]
   \       0x86   0x....'....        BL       RTC_Bcd2ToByte
   \       0x8A   0x7028             STRB     R0,[R5, #+0]
   2062            }
   2063          }
   \                     ??RTC_GetTimeStamp_0: (+1)
   \       0x8C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2064          
   2065          /**
   2066            * @brief  Get the RTC timestamp Sub seconds value.
   2067            * @param  None
   2068            * @retval RTC current timestamp Sub seconds value.
   2069            */

   \                                 In section .text, align 2, keep-with-next
   2070          uint32_t RTC_GetTimeStampSubSecond(void)
   2071          {
   2072            /* Get timestamp sub seconds values from the correspondent registers */
   2073            return (uint32_t)(RTC->TSSSR);
   \                     RTC_GetTimeStampSubSecond: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable50_10  ;; 0x40002838
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
   2074          }
   2075          
   2076          /**
   2077            * @}
   2078            */
   2079          
   2080          /** @defgroup RTC_Group9 Tampers configuration functions
   2081           *  @brief   Tampers configuration functions 
   2082           *
   2083          @verbatim   
   2084           ===============================================================================
   2085                           ##### Tampers configuration functions #####
   2086           ===============================================================================  
   2087          
   2088          @endverbatim
   2089            * @{
   2090            */
   2091          
   2092          /**
   2093            * @brief  Configures the select Tamper pin edge.
   2094            * @param  RTC_Tamper: Selected tamper pin.
   2095            *          This parameter can be RTC_Tamper_1 or RTC_Tamper 2
   2096            * @param  RTC_TamperTrigger: Specifies the trigger on the tamper pin that 
   2097            *         stimulates tamper event. 
   2098            *   This parameter can be one of the following values:
   2099            *     @arg RTC_TamperTrigger_RisingEdge: Rising Edge of the tamper pin causes tamper event.
   2100            *     @arg RTC_TamperTrigger_FallingEdge: Falling Edge of the tamper pin causes tamper event.
   2101            *     @arg RTC_TamperTrigger_LowLevel: Low Level of the tamper pin causes tamper event.
   2102            *     @arg RTC_TamperTrigger_HighLevel: High Level of the tamper pin causes tamper event.
   2103            * @retval None
   2104            */

   \                                 In section .text, align 2, keep-with-next
   2105          void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
   2106          {
   2107            /* Check the parameters */
   2108            assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
   2109            assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
   2110           
   2111            if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
   \                     RTC_TamperTriggerConfig: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0xD105             BNE.N    ??RTC_TamperTriggerConfig_0
   2112            {  
   2113              /* Configure the RTC_TAFCR register */
   2114              RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
   \        0x4   0x....             LDR.N    R1,??DataTable50  ;; 0x40002840
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0xEA32 0x0240      BICS     R2,R2,R0, LSL #+1
   \        0xC   0x600A             STR      R2,[R1, #+0]
   \        0xE   0xE004             B.N      ??RTC_TamperTriggerConfig_1
   2115            }
   2116            else
   2117            { 
   2118              /* Configure the RTC_TAFCR register */
   2119              RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
   \                     ??RTC_TamperTriggerConfig_0: (+1)
   \       0x10   0x....             LDR.N    R1,??DataTable50  ;; 0x40002840
   \       0x12   0x680A             LDR      R2,[R1, #+0]
   \       0x14   0xEA52 0x0240      ORRS     R2,R2,R0, LSL #+1
   \       0x18   0x600A             STR      R2,[R1, #+0]
   2120            }  
   2121          }
   \                     ??RTC_TamperTriggerConfig_1: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
   2122          
   2123          /**
   2124            * @brief  Enables or Disables the Tamper detection.
   2125            * @param  RTC_Tamper: Selected tamper pin.
   2126            *          This parameter can be RTC_Tamper_1 or RTC_Tamper_2
   2127            * @param  NewState: new state of the tamper pin.
   2128            *          This parameter can be: ENABLE or DISABLE.                   
   2129            * @retval None
   2130            */

   \                                 In section .text, align 2, keep-with-next
   2131          void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
   2132          {
   2133            /* Check the parameters */
   2134            assert_param(IS_RTC_TAMPER(RTC_Tamper));  
   2135            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2136            
   2137            if (NewState != DISABLE)
   \                     RTC_TamperCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??RTC_TamperCmd_0
   2138            {
   2139              /* Enable the selected Tamper pin */
   2140              RTC->TAFCR |= (uint32_t)RTC_Tamper;
   \        0x6   0x....             LDR.N    R1,??DataTable50  ;; 0x40002840
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0x4310             ORRS     R0,R0,R2
   \        0xC   0x6008             STR      R0,[R1, #+0]
   \        0xE   0xE004             B.N      ??RTC_TamperCmd_1
   2141            }
   2142            else
   2143            {
   2144              /* Disable the selected Tamper pin */
   2145              RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
   \                     ??RTC_TamperCmd_0: (+1)
   \       0x10   0x....             LDR.N    R1,??DataTable50  ;; 0x40002840
   \       0x12   0x680A             LDR      R2,[R1, #+0]
   \       0x14   0xEA32 0x0000      BICS     R0,R2,R0
   \       0x18   0x6008             STR      R0,[R1, #+0]
   2146            }  
   2147          }
   \                     ??RTC_TamperCmd_1: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
   2148          
   2149          /**
   2150            * @brief  Configures the Tampers Filter.
   2151            * @param  RTC_TamperFilter: Specifies the tampers filter.
   2152            *   This parameter can be one of the following values:
   2153            *     @arg RTC_TamperFilter_Disable: Tamper filter is disabled.
   2154            *     @arg RTC_TamperFilter_2Sample: Tamper is activated after 2 consecutive 
   2155            *                                    samples at the active level 
   2156            *     @arg RTC_TamperFilter_4Sample: Tamper is activated after 4 consecutive 
   2157            *                                    samples at the active level
   2158            *     @arg RTC_TamperFilter_8Sample: Tamper is activated after 8 consecutive 
   2159            *                                    samples at the active level 
   2160            * @retval None
   2161            */

   \                                 In section .text, align 2, keep-with-next
   2162          void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
   2163          {
   2164            /* Check the parameters */
   2165            assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
   2166             
   2167            /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
   2168            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
   \                     RTC_TamperFilterConfig: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable50  ;; 0x40002840
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xF432 0x52C0      BICS     R2,R2,#0x1800
   \        0x8   0x600A             STR      R2,[R1, #+0]
   2169          
   2170            /* Configure the RTC_TAFCR register */
   2171            RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0x4310             ORRS     R0,R0,R2
   \        0xE   0x6008             STR      R0,[R1, #+0]
   2172          }
   \       0x10   0x4770             BX       LR               ;; return
   2173          
   2174          /**
   2175            * @brief  Configures the Tampers Sampling Frequency.
   2176            * @param  RTC_TamperSamplingFreq: Specifies the tampers Sampling Frequency.
   2177            *   This parameter can be one of the following values:
   2178            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div32768: Each of the tamper inputs are sampled
   2179            *                                           with a frequency =  RTCCLK / 32768
   2180            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div16384: Each of the tamper inputs are sampled
   2181            *                                           with a frequency =  RTCCLK / 16384
   2182            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div8192: Each of the tamper inputs are sampled
   2183            *                                           with a frequency =  RTCCLK / 8192
   2184            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div4096: Each of the tamper inputs are sampled
   2185            *                                           with a frequency =  RTCCLK / 4096
   2186            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div2048: Each of the tamper inputs are sampled
   2187            *                                           with a frequency =  RTCCLK / 2048
   2188            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div1024: Each of the tamper inputs are sampled
   2189            *                                           with a frequency =  RTCCLK / 1024
   2190            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div512: Each of the tamper inputs are sampled
   2191            *                                           with a frequency =  RTCCLK / 512  
   2192            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div256: Each of the tamper inputs are sampled
   2193            *                                           with a frequency =  RTCCLK / 256  
   2194            * @retval None
   2195            */

   \                                 In section .text, align 2, keep-with-next
   2196          void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
   2197          {
   2198            /* Check the parameters */
   2199            assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
   2200           
   2201            /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
   2202            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
   \                     RTC_TamperSamplingFreqConfig: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable50  ;; 0x40002840
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xF432 0x62E0      BICS     R2,R2,#0x700
   \        0x8   0x600A             STR      R2,[R1, #+0]
   2203          
   2204            /* Configure the RTC_TAFCR register */
   2205            RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0x4310             ORRS     R0,R0,R2
   \        0xE   0x6008             STR      R0,[R1, #+0]
   2206          }
   \       0x10   0x4770             BX       LR               ;; return
   2207          
   2208          /**
   2209            * @brief  Configures the Tampers Pins input Precharge Duration.
   2210            * @param  RTC_TamperPrechargeDuration: Specifies the Tampers Pins input
   2211            *         Precharge Duration.
   2212            *   This parameter can be one of the following values:
   2213            *     @arg RTC_TamperPrechargeDuration_1RTCCLK: Tamper pins are precharged before sampling during 1 RTCCLK cycle
   2214            *     @arg RTC_TamperPrechargeDuration_2RTCCLK: Tamper pins are precharged before sampling during 2 RTCCLK cycle
   2215            *     @arg RTC_TamperPrechargeDuration_4RTCCLK: Tamper pins are precharged before sampling during 4 RTCCLK cycle    
   2216            *     @arg RTC_TamperPrechargeDuration_8RTCCLK: Tamper pins are precharged before sampling during 8 RTCCLK cycle
   2217            * @retval None
   2218            */

   \                                 In section .text, align 2, keep-with-next
   2219          void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
   2220          {
   2221            /* Check the parameters */
   2222            assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
   2223             
   2224            /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
   2225            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
   \                     RTC_TamperPinsPrechargeDuration: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable50  ;; 0x40002840
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xF432 0x42C0      BICS     R2,R2,#0x6000
   \        0x8   0x600A             STR      R2,[R1, #+0]
   2226          
   2227            /* Configure the RTC_TAFCR register */
   2228            RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0x4310             ORRS     R0,R0,R2
   \        0xE   0x6008             STR      R0,[R1, #+0]
   2229          }
   \       0x10   0x4770             BX       LR               ;; return
   2230          
   2231          /**
   2232            * @brief  Enables or Disables the TimeStamp on Tamper Detection Event.
   2233            * @note   The timestamp is valid even the TSE bit in tamper control register 
   2234            *         is reset.   
   2235            * @param  NewState: new state of the timestamp on tamper event.
   2236            *         This parameter can be: ENABLE or DISABLE.
   2237            * @retval None
   2238            */

   \                                 In section .text, align 2, keep-with-next
   2239          void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
   2240          {
   2241            /* Check the parameters */
   2242            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2243             
   2244            if (NewState != DISABLE)
   \                     RTC_TimeStampOnTamperDetectionCmd: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD005             BEQ.N    ??RTC_TimeStampOnTamperDetectionCmd_0
   2245            {
   2246              /* Save timestamp on tamper detection event */
   2247              RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
   \        0x6   0x....             LDR.N    R0,??DataTable50  ;; 0x40002840
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0xF051 0x0180      ORRS     R1,R1,#0x80
   \        0xE   0x6001             STR      R1,[R0, #+0]
   \       0x10   0xE004             B.N      ??RTC_TimeStampOnTamperDetectionCmd_1
   2248            }
   2249            else
   2250            {
   2251              /* Tamper detection does not cause a timestamp to be saved */
   2252              RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
   \                     ??RTC_TimeStampOnTamperDetectionCmd_0: (+1)
   \       0x12   0x....             LDR.N    R0,??DataTable50  ;; 0x40002840
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xF031 0x0180      BICS     R1,R1,#0x80
   \       0x1A   0x6001             STR      R1,[R0, #+0]
   2253            }
   2254          }
   \                     ??RTC_TimeStampOnTamperDetectionCmd_1: (+1)
   \       0x1C   0x4770             BX       LR               ;; return
   2255          
   2256          /**
   2257            * @brief  Enables or Disables the Precharge of Tamper pin.
   2258            * @param  NewState: new state of tamper pull up.
   2259            *   This parameter can be: ENABLE or DISABLE.                   
   2260            * @retval None
   2261            */

   \                                 In section .text, align 2, keep-with-next
   2262          void RTC_TamperPullUpCmd(FunctionalState NewState)
   2263          {
   2264            /* Check the parameters */
   2265            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2266            
   2267           if (NewState != DISABLE)
   \                     RTC_TamperPullUpCmd: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD005             BEQ.N    ??RTC_TamperPullUpCmd_0
   2268            {
   2269              /* Enable precharge of the selected Tamper pin */
   2270              RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
   \        0x6   0x....             LDR.N    R0,??DataTable50  ;; 0x40002840
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0xF431 0x4100      BICS     R1,R1,#0x8000
   \        0xE   0x6001             STR      R1,[R0, #+0]
   \       0x10   0xE004             B.N      ??RTC_TamperPullUpCmd_1
   2271            }
   2272            else
   2273            {
   2274              /* Disable precharge of the selected Tamper pin */
   2275              RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
   \                     ??RTC_TamperPullUpCmd_0: (+1)
   \       0x12   0x....             LDR.N    R0,??DataTable50  ;; 0x40002840
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \       0x1A   0x6001             STR      R1,[R0, #+0]
   2276            } 
   2277          }
   \                     ??RTC_TamperPullUpCmd_1: (+1)
   \       0x1C   0x4770             BX       LR               ;; return
   2278          
   2279          /**
   2280            * @}
   2281            */
   2282          
   2283          /** @defgroup RTC_Group10 Backup Data Registers configuration functions
   2284           *  @brief   Backup Data Registers configuration functions  
   2285           *
   2286          @verbatim   
   2287           ===============================================================================
   2288                       ##### Backup Data Registers configuration functions ##### 
   2289           ===============================================================================  
   2290          
   2291          @endverbatim
   2292            * @{
   2293            */
   2294          
   2295          /**
   2296            * @brief  Writes a data in a specified RTC Backup data register.
   2297            * @param  RTC_BKP_DR: RTC Backup data Register number.
   2298            *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
   2299            *                          specify the register.
   2300            * @param  Data: Data to be written in the specified RTC Backup data register.                     
   2301            * @retval None
   2302            */

   \                                 In section .text, align 2, keep-with-next
   2303          void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
   2304          {
   \                     RTC_WriteBackupRegister: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   2305            __IO uint32_t tmp = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x9200             STR      R2,[SP, #+0]
   2306            
   2307            /* Check the parameters */
   2308            assert_param(IS_RTC_BKP(RTC_BKP_DR));
   2309          
   2310            tmp = RTC_BASE + 0x50;
   \        0x6   0x....             LDR.N    R2,??DataTable50_11  ;; 0x40002850
   \        0x8   0x9200             STR      R2,[SP, #+0]
   2311            tmp += (RTC_BKP_DR * 4);
   \        0xA   0x9A00             LDR      R2,[SP, #+0]
   \        0xC   0xEB12 0x0280      ADDS     R2,R2,R0, LSL #+2
   \       0x10   0x9200             STR      R2,[SP, #+0]
   2312          
   2313            /* Write the specified register */
   2314            *(__IO uint32_t *)tmp = (uint32_t)Data;
   \       0x12   0x9800             LDR      R0,[SP, #+0]
   \       0x14   0x6001             STR      R1,[R0, #+0]
   2315          }
   \       0x16   0xB001             ADD      SP,SP,#+4
   \       0x18   0x4770             BX       LR               ;; return
   2316          
   2317          /**
   2318            * @brief  Reads data from the specified RTC Backup data Register.
   2319            * @param  RTC_BKP_DR: RTC Backup data Register number.
   2320            *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
   2321            *                          specify the register.                   
   2322            * @retval None
   2323            */

   \                                 In section .text, align 2, keep-with-next
   2324          uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
   2325          {
   \                     RTC_ReadBackupRegister: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   2326            __IO uint32_t tmp = 0;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x9100             STR      R1,[SP, #+0]
   2327            
   2328            /* Check the parameters */
   2329            assert_param(IS_RTC_BKP(RTC_BKP_DR));
   2330          
   2331            tmp = RTC_BASE + 0x50;
   \        0x6   0x....             LDR.N    R1,??DataTable50_11  ;; 0x40002850
   \        0x8   0x9100             STR      R1,[SP, #+0]
   2332            tmp += (RTC_BKP_DR * 4);
   \        0xA   0x9900             LDR      R1,[SP, #+0]
   \        0xC   0xEB11 0x0180      ADDS     R1,R1,R0, LSL #+2
   \       0x10   0x9100             STR      R1,[SP, #+0]
   2333            
   2334            /* Read the specified register */
   2335            return (*(__IO uint32_t *)tmp);
   \       0x12   0x9800             LDR      R0,[SP, #+0]
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0xB001             ADD      SP,SP,#+4
   \       0x18   0x4770             BX       LR               ;; return
   2336          }
   2337          
   2338          /**
   2339            * @}
   2340            */
   2341          
   2342          /** @defgroup RTC_Group11 RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration functions
   2343           *  @brief   RTC Tamper and TimeStamp Pins Selection and Output Type Config 
   2344           *           configuration functions  
   2345           *
   2346          @verbatim   
   2347           ==================================================================================================
   2348           ##### RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration functions ##### 
   2349           ==================================================================================================  
   2350          
   2351          @endverbatim
   2352            * @{
   2353            */
   2354          
   2355          /**
   2356            * @brief  Selects the RTC Tamper Pin.
   2357            * @param  RTC_TamperPin: specifies the RTC Tamper Pin.
   2358            *          This parameter can be one of the following values:
   2359            *            @arg RTC_TamperPin_Default: RTC_AF1 is used as RTC Tamper Pin.
   2360            *            @arg RTC_TamperPin_Pos1: RTC_AF2 is selected as RTC Tamper Pin.    
   2361            * @retval None
   2362            */

   \                                 In section .text, align 2, keep-with-next
   2363          void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
   2364          {
   2365            /* Check the parameters */
   2366            assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
   2367            
   2368            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
   \                     RTC_TamperPinSelection: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable50  ;; 0x40002840
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xF432 0x3280      BICS     R2,R2,#0x10000
   \        0x8   0x600A             STR      R2,[R1, #+0]
   2369            RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0x4310             ORRS     R0,R0,R2
   \        0xE   0x6008             STR      R0,[R1, #+0]
   2370          }
   \       0x10   0x4770             BX       LR               ;; return
   2371          
   2372          /**
   2373            * @brief  Selects the RTC TimeStamp Pin.
   2374            * @param  RTC_TimeStampPin: specifies the RTC TimeStamp Pin.
   2375            *          This parameter can be one of the following values:
   2376            *            @arg RTC_TimeStampPin_PC13: PC13 is selected as RTC TimeStamp Pin.
   2377            *            @arg RTC_TimeStampPin_PI8: PI8 is selected as RTC TimeStamp Pin.    
   2378            * @retval None
   2379            */

   \                                 In section .text, align 2, keep-with-next
   2380          void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
   2381          {
   2382            /* Check the parameters */
   2383            assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
   2384            
   2385            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
   \                     RTC_TimeStampPinSelection: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable50  ;; 0x40002840
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xF432 0x3200      BICS     R2,R2,#0x20000
   \        0x8   0x600A             STR      R2,[R1, #+0]
   2386            RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0x4310             ORRS     R0,R0,R2
   \        0xE   0x6008             STR      R0,[R1, #+0]
   2387          }
   \       0x10   0x4770             BX       LR               ;; return
   2388          
   2389          /**
   2390            * @brief  Configures the RTC Output Pin mode. 
   2391            * @param  RTC_OutputType: specifies the RTC Output (PC13) pin mode.
   2392            *          This parameter can be one of the following values:
   2393            *            @arg RTC_OutputType_OpenDrain: RTC Output (PC13) is configured in 
   2394            *                                    Open Drain mode.
   2395            *            @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
   2396            *                                    Push Pull mode.    
   2397            * @retval None
   2398            */

   \                                 In section .text, align 2, keep-with-next
   2399          void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
   2400          {
   2401            /* Check the parameters */
   2402            assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
   2403            
   2404            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
   \                     RTC_OutputTypeConfig: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable50  ;; 0x40002840
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xF432 0x2280      BICS     R2,R2,#0x40000
   \        0x8   0x600A             STR      R2,[R1, #+0]
   2405            RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0x4310             ORRS     R0,R0,R2
   \        0xE   0x6008             STR      R0,[R1, #+0]
   2406          }
   \       0x10   0x4770             BX       LR               ;; return
   2407          
   2408          /**
   2409            * @}
   2410            */
   2411          
   2412          /** @defgroup RTC_Group12 Shift control synchronisation functions
   2413           *  @brief   Shift control synchronisation functions 
   2414           *
   2415          @verbatim   
   2416           ===============================================================================
   2417                        ##### Shift control synchronisation functions #####
   2418           ===============================================================================  
   2419          
   2420          @endverbatim
   2421            * @{
   2422            */
   2423          
   2424          /**
   2425            * @brief  Configures the Synchronization Shift Control Settings.
   2426            * @note   When REFCKON is set, firmware must not write to Shift control register 
   2427            * @param  RTC_ShiftAdd1S : Select to add or not 1 second to the time Calendar.
   2428            *   This parameter can be one of the following values :
   2429            *     @arg RTC_ShiftAdd1S_Set  : Add one second to the clock calendar. 
   2430            *     @arg RTC_ShiftAdd1S_Reset: No effect.
   2431            * @param  RTC_ShiftSubFS: Select the number of Second Fractions to Substitute.
   2432            *         This parameter can be one any value from 0 to 0x7FFF.
   2433            * @retval An ErrorStatus enumeration value:
   2434            *          - SUCCESS: RTC Shift registers are configured
   2435            *          - ERROR: RTC Shift registers are not configured
   2436          */

   \                                 In section .text, align 2, keep-with-next
   2437          ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
   2438          {
   \                     RTC_SynchroShiftConfig: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   2439            ErrorStatus status = ERROR;
   \        0x2   0x2200             MOVS     R2,#+0
   2440            uint32_t shpfcount = 0;
   \        0x4   0x2200             MOVS     R2,#+0
   2441          
   2442            /* Check the parameters */
   2443            assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
   2444            assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
   2445          
   2446            /* Disable the write protection for RTC registers */
   2447            RTC->WPR = 0xCA;
   \        0x6   0x....             LDR.N    R4,??DataTable50_1  ;; 0x40002824
   \        0x8   0x23CA             MOVS     R3,#+202
   \        0xA   0x6023             STR      R3,[R4, #+0]
   2448            RTC->WPR = 0x53;
   \        0xC   0x2353             MOVS     R3,#+83
   \        0xE   0x6023             STR      R3,[R4, #+0]
   2449            
   2450            /* Check if a Shift is pending*/
   2451            if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
   \       0x10   0x....             LDR.N    R3,??DataTable49  ;; 0x4000280c
   \       0x12   0x681D             LDR      R5,[R3, #+0]
   \       0x14   0x072D             LSLS     R5,R5,#+28
   \       0x16   0xD401             BMI.N    ??RTC_SynchroShiftConfig_0
   \       0x18   0xE006             B.N      ??RTC_SynchroShiftConfig_1
   2452            {
   2453              /* Wait until the shift is completed*/
   2454              while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
   2455              {
   2456                shpfcount++;
   \                     ??RTC_SynchroShiftConfig_2: (+1)
   \       0x1A   0x1C52             ADDS     R2,R2,#+1
   2457              }
   \                     ??RTC_SynchroShiftConfig_0: (+1)
   \       0x1C   0x681D             LDR      R5,[R3, #+0]
   \       0x1E   0x072D             LSLS     R5,R5,#+28
   \       0x20   0xD502             BPL.N    ??RTC_SynchroShiftConfig_1
   \       0x22   0xF5B2 0x5F80      CMP      R2,#+4096
   \       0x26   0xD1F8             BNE.N    ??RTC_SynchroShiftConfig_2
   2458            }
   2459          
   2460            /* Check if the Shift pending is completed or if there is no Shift operation at all*/
   2461            if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
   \                     ??RTC_SynchroShiftConfig_1: (+1)
   \       0x28   0x681A             LDR      R2,[R3, #+0]
   \       0x2A   0x0712             LSLS     R2,R2,#+28
   \       0x2C   0xD410             BMI.N    ??RTC_SynchroShiftConfig_3
   2462            {
   2463              /* check if the reference clock detection is disabled */
   2464              if((RTC->CR & RTC_CR_REFCKON) == RESET)
   \       0x2E   0x....             LDR.N    R2,??DataTable50_2  ;; 0x40002808
   \       0x30   0x6812             LDR      R2,[R2, #+0]
   \       0x32   0x06D2             LSLS     R2,R2,#+27
   \       0x34   0xD40A             BMI.N    ??RTC_SynchroShiftConfig_4
   2465              {
   2466                /* Configure the Shift settings */
   2467                RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
   \       0x36   0x4308             ORRS     R0,R0,R1
   \       0x38   0x....             LDR.N    R1,??DataTable50_12  ;; 0x4000282c
   \       0x3A   0x6008             STR      R0,[R1, #+0]
   2468              
   2469                if(RTC_WaitForSynchro() == ERROR)
   \       0x3C   0x....'....        BL       RTC_WaitForSynchro
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD101             BNE.N    ??RTC_SynchroShiftConfig_5
   2470                {
   2471                  status = ERROR;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xE004             B.N      ??RTC_SynchroShiftConfig_6
   2472                }
   2473                else
   2474                {
   2475                  status = SUCCESS;
   \                     ??RTC_SynchroShiftConfig_5: (+1)
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xE002             B.N      ??RTC_SynchroShiftConfig_6
   2476                }
   2477              }
   2478              else
   2479              {
   2480                status = ERROR;
   \                     ??RTC_SynchroShiftConfig_4: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xE000             B.N      ??RTC_SynchroShiftConfig_6
   2481              }
   2482            }
   2483            else
   2484            {
   2485              status = ERROR;
   \                     ??RTC_SynchroShiftConfig_3: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   2486            }
   2487          
   2488            /* Enable the write protection for RTC registers */
   2489            RTC->WPR = 0xFF;
   \                     ??RTC_SynchroShiftConfig_6: (+1)
   \       0x52   0x21FF             MOVS     R1,#+255
   \       0x54   0x6021             STR      R1,[R4, #+0]
   2490            
   2491            return (ErrorStatus)(status);
   \       0x56   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x58   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2492          }
   2493          
   2494          /**
   2495            * @}
   2496            */
   2497          
   2498          /** @defgroup RTC_Group13 Interrupts and flags management functions
   2499           *  @brief   Interrupts and flags management functions  
   2500           *
   2501          @verbatim   
   2502           ===============================================================================
   2503                        ##### Interrupts and flags management functions #####
   2504           ===============================================================================  
   2505           [..] All RTC interrupts are connected to the EXTI controller.
   2506           
   2507             (+) To enable the RTC Alarm interrupt, the following sequence is required:
   2508                 (++) Configure and enable the EXTI Line 17 in interrupt mode and select 
   2509                      the rising edge sensitivity using the EXTI_Init() function.
   2510                 (++) Configure and enable the RTC_Alarm IRQ channel in the NVIC using the 
   2511                      NVIC_Init() function.
   2512                 (++) Configure the RTC to generate RTC alarms (Alarm A and/or Alarm B) using
   2513                      the RTC_SetAlarm() and RTC_AlarmCmd() functions.
   2514          
   2515             (+) To enable the RTC Wakeup interrupt, the following sequence is required:
   2516                 (++) Configure and enable the EXTI Line 22 in interrupt mode and select the
   2517                      rising edge sensitivity using the EXTI_Init() function.
   2518                 (++) Configure and enable the RTC_WKUP IRQ channel in the NVIC using the 
   2519                      NVIC_Init() function.
   2520                 (++) Configure the RTC to generate the RTC wakeup timer event using the 
   2521                      RTC_WakeUpClockConfig(), RTC_SetWakeUpCounter() and RTC_WakeUpCmd() 
   2522                      functions.
   2523          
   2524             (+) To enable the RTC Tamper interrupt, the following sequence is required:
   2525                 (++) Configure and enable the EXTI Line 21 in interrupt mode and select 
   2526                      the rising edge sensitivity using the EXTI_Init() function.
   2527                 (++) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the
   2528                      NVIC_Init() function.
   2529                 (++) Configure the RTC to detect the RTC tamper event using the 
   2530                      RTC_TamperTriggerConfig() and RTC_TamperCmd() functions.
   2531          
   2532             (+) To enable the RTC TimeStamp interrupt, the following sequence is required:
   2533                 (++) Configure and enable the EXTI Line 21 in interrupt mode and select the
   2534                      rising edge sensitivity using the EXTI_Init() function.
   2535                 (++) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the 
   2536                      NVIC_Init() function.
   2537                 (++) Configure the RTC to detect the RTC time stamp event using the 
   2538                      RTC_TimeStampCmd() functions.
   2539          
   2540          @endverbatim
   2541            * @{
   2542            */
   2543          
   2544          /**
   2545            * @brief  Enables or disables the specified RTC interrupts.
   2546            * @param  RTC_IT: specifies the RTC interrupt sources to be enabled or disabled. 
   2547            *          This parameter can be any combination of the following values:
   2548            *            @arg RTC_IT_TS:  Time Stamp interrupt mask
   2549            *            @arg RTC_IT_WUT:  WakeUp Timer interrupt mask
   2550            *            @arg RTC_IT_ALRB:  Alarm B interrupt mask
   2551            *            @arg RTC_IT_ALRA:  Alarm A interrupt mask
   2552            *            @arg RTC_IT_TAMP: Tamper event interrupt mask
   2553            * @param  NewState: new state of the specified RTC interrupts.
   2554            *          This parameter can be: ENABLE or DISABLE.
   2555            * @retval None
   2556            */

   \                                 In section .text, align 2, keep-with-next
   2557          void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
   2558          {
   \                     RTC_ITConfig: (+1)
   \        0x0   0xB410             PUSH     {R4}
   2559            /* Check the parameters */
   2560            assert_param(IS_RTC_CONFIG_IT(RTC_IT));
   2561            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2562          
   2563            /* Disable the write protection for RTC registers */
   2564            RTC->WPR = 0xCA;
   \        0x2   0x....             LDR.N    R2,??DataTable50_1  ;; 0x40002824
   \        0x4   0x23CA             MOVS     R3,#+202
   \        0x6   0x6013             STR      R3,[R2, #+0]
   2565            RTC->WPR = 0x53;
   \        0x8   0x2353             MOVS     R3,#+83
   \        0xA   0x6013             STR      R3,[R2, #+0]
   2566          
   2567            if (NewState != DISABLE)
   \        0xC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD00C             BEQ.N    ??RTC_ITConfig_0
   2568            {
   2569              /* Configure the Interrupts in the RTC_CR register */
   2570              RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
   \       0x12   0x....             LDR.N    R3,??DataTable50_2  ;; 0x40002808
   \       0x14   0x681C             LDR      R4,[R3, #+0]
   \       0x16   0xF030 0x0104      BICS     R1,R0,#0x4
   \       0x1A   0x430C             ORRS     R4,R1,R4
   \       0x1C   0x601C             STR      R4,[R3, #+0]
   2571              /* Configure the Tamper Interrupt in the RTC_TAFCR */
   2572              RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
   \       0x1E   0x....             LDR.N    R1,??DataTable50  ;; 0x40002840
   \       0x20   0x680B             LDR      R3,[R1, #+0]
   \       0x22   0xF010 0x0004      ANDS     R0,R0,#0x4
   \       0x26   0x4318             ORRS     R0,R0,R3
   \       0x28   0x6008             STR      R0,[R1, #+0]
   \       0x2A   0xE00C             B.N      ??RTC_ITConfig_1
   2573            }
   2574            else
   2575            {
   2576              /* Configure the Interrupts in the RTC_CR register */
   2577              RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
   \                     ??RTC_ITConfig_0: (+1)
   \       0x2C   0x....             LDR.N    R3,??DataTable50_2  ;; 0x40002808
   \       0x2E   0x681C             LDR      R4,[R3, #+0]
   \       0x30   0xF030 0x0104      BICS     R1,R0,#0x4
   \       0x34   0x438C             BICS     R4,R4,R1
   \       0x36   0x601C             STR      R4,[R3, #+0]
   2578              /* Configure the Tamper Interrupt in the RTC_TAFCR */
   2579              RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
   \       0x38   0x....             LDR.N    R1,??DataTable50  ;; 0x40002840
   \       0x3A   0x680B             LDR      R3,[R1, #+0]
   \       0x3C   0xF010 0x0004      ANDS     R0,R0,#0x4
   \       0x40   0xEA33 0x0000      BICS     R0,R3,R0
   \       0x44   0x6008             STR      R0,[R1, #+0]
   2580            }
   2581            /* Enable the write protection for RTC registers */
   2582            RTC->WPR = 0xFF; 
   \                     ??RTC_ITConfig_1: (+1)
   \       0x46   0x20FF             MOVS     R0,#+255
   \       0x48   0x6010             STR      R0,[R2, #+0]
   2583          }
   \       0x4A   0xBC10             POP      {R4}
   \       0x4C   0x4770             BX       LR               ;; return
   2584          
   2585          /**
   2586            * @brief  Checks whether the specified RTC flag is set or not.
   2587            * @param  RTC_FLAG: specifies the flag to check.
   2588            *          This parameter can be one of the following values:
   2589            *            @arg RTC_FLAG_RECALPF: RECALPF event flag.
   2590            *            @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
   2591            *            @arg RTC_FLAG_TAMP2F: Tamper 2 event flag
   2592            *            @arg RTC_FLAG_TSOVF: Time Stamp OverFlow flag
   2593            *            @arg RTC_FLAG_TSF: Time Stamp event flag
   2594            *            @arg RTC_FLAG_WUTF: WakeUp Timer flag
   2595            *            @arg RTC_FLAG_ALRBF: Alarm B flag
   2596            *            @arg RTC_FLAG_ALRAF: Alarm A flag
   2597            *            @arg RTC_FLAG_INITF: Initialization mode flag
   2598            *            @arg RTC_FLAG_RSF: Registers Synchronized flag
   2599            *            @arg RTC_FLAG_INITS: Registers Configured flag
   2600            *            @arg RTC_FLAG_SHPF: Shift operation pending flag.
   2601            *            @arg RTC_FLAG_WUTWF: WakeUp Timer Write flag
   2602            *            @arg RTC_FLAG_ALRBWF: Alarm B Write flag
   2603            *            @arg RTC_FLAG_ALRAWF: Alarm A write flag
   2604            * @retval The new state of RTC_FLAG (SET or RESET).
   2605            */

   \                                 In section .text, align 2, keep-with-next
   2606          FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
   2607          {
   2608            FlagStatus bitstatus = RESET;
   \                     RTC_GetFlagStatus: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   2609            uint32_t tmpreg = 0;
   \        0x2   0x2100             MOVS     R1,#+0
   2610            
   2611            /* Check the parameters */
   2612            assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
   2613            
   2614            /* Get all the flags */
   2615            tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
   \        0x4   0x....             LDR.N    R1,??DataTable49  ;; 0x4000280c
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x....             LDR.N    R1,??DataTable50_13  ;; 0x17f7f
   \        0xA   0x400A             ANDS     R2,R1,R2
   2616            
   2617            /* Return the status of the flag */
   2618            if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
   \        0xC   0x4202             TST      R2,R0
   \        0xE   0xD001             BEQ.N    ??RTC_GetFlagStatus_0
   2619            {
   2620              bitstatus = SET;
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xE000             B.N      ??RTC_GetFlagStatus_1
   2621            }
   2622            else
   2623            {
   2624              bitstatus = RESET;
   \                     ??RTC_GetFlagStatus_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   2625            }
   2626            return bitstatus;
   \                     ??RTC_GetFlagStatus_1: (+1)
   \       0x16   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x18   0x4770             BX       LR               ;; return
   2627          }
   2628          
   2629          /**
   2630            * @brief  Clears the RTC's pending flags.
   2631            * @param  RTC_FLAG: specifies the RTC flag to clear.
   2632            *          This parameter can be any combination of the following values:
   2633            *            @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
   2634            *            @arg RTC_FLAG_TAMP2F: Tamper 2 event flag
   2635            *            @arg RTC_FLAG_TSOVF: Time Stamp Overflow flag 
   2636            *            @arg RTC_FLAG_TSF: Time Stamp event flag
   2637            *            @arg RTC_FLAG_WUTF: WakeUp Timer flag
   2638            *            @arg RTC_FLAG_ALRBF: Alarm B flag
   2639            *            @arg RTC_FLAG_ALRAF: Alarm A flag
   2640            *            @arg RTC_FLAG_RSF: Registers Synchronized flag
   2641            * @retval None
   2642            */

   \                                 In section .text, align 2, keep-with-next
   2643          void RTC_ClearFlag(uint32_t RTC_FLAG)
   2644          {
   2645            /* Check the parameters */
   2646            assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
   2647          
   2648            /* Clear the Flags in the RTC_ISR register */
   2649            RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
   \                     RTC_ClearFlag: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable50_6  ;; 0x4000280c
   \        0x2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \        0x4   0xF050 0x0080      ORRS     R0,R0,#0x80
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0xF012 0x0280      ANDS     R2,R2,#0x80
   \        0xE   0xEA72 0x0000      ORNS     R0,R2,R0
   \       0x12   0x6008             STR      R0,[R1, #+0]
   2650          }
   \       0x14   0x4770             BX       LR               ;; return
   2651          
   2652          /**
   2653            * @brief  Checks whether the specified RTC interrupt has occurred or not.
   2654            * @param  RTC_IT: specifies the RTC interrupt source to check.
   2655            *          This parameter can be one of the following values:
   2656            *            @arg RTC_IT_TS: Time Stamp interrupt 
   2657            *            @arg RTC_IT_WUT: WakeUp Timer interrupt 
   2658            *            @arg RTC_IT_ALRB: Alarm B interrupt 
   2659            *            @arg RTC_IT_ALRA: Alarm A interrupt 
   2660            *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt
   2661            *            @arg RTC_IT_TAMP2: Tamper 2 event interrupt
   2662            * @retval The new state of RTC_IT (SET or RESET).
   2663            */

   \                                 In section .text, align 2, keep-with-next
   2664          ITStatus RTC_GetITStatus(uint32_t RTC_IT)
   2665          {
   2666            ITStatus bitstatus = RESET;
   \                     RTC_GetITStatus: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   2667            uint32_t tmpreg = 0, enablestatus = 0;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x2100             MOVS     R1,#+0
   2668           
   2669            /* Check the parameters */
   2670            assert_param(IS_RTC_GET_IT(RTC_IT));
   2671            
   2672            /* Get the TAMPER Interrupt enable bit and pending bit */
   2673            tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
   \        0x6   0x....             LDR.N    R1,??DataTable50  ;; 0x40002840
   \        0x8   0x6809             LDR      R1,[R1, #+0]
   \        0xA   0xF011 0x0104      ANDS     R1,R1,#0x4
   2674           
   2675            /* Get the Interrupt enable Status */
   2676            enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)) | (tmpreg & (RTC_IT >> 16)));
   \        0xE   0x....             LDR.N    R2,??DataTable50_2  ;; 0x40002808
   \       0x10   0x6813             LDR      R3,[R2, #+0]
   \       0x12   0x4003             ANDS     R3,R0,R3
   \       0x14   0xEA11 0x32D0      ANDS     R2,R1,R0, LSR #+15
   \       0x18   0x4313             ORRS     R3,R2,R3
   \       0x1A   0xEA11 0x4110      ANDS     R1,R1,R0, LSR #+16
   \       0x1E   0x4319             ORRS     R1,R1,R3
   2677            
   2678            /* Get the Interrupt pending bit */
   2679            tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
   \       0x20   0x....             LDR.N    R2,??DataTable50_6  ;; 0x4000280c
   \       0x22   0x6812             LDR      R2,[R2, #+0]
   \       0x24   0xEA12 0x1210      ANDS     R2,R2,R0, LSR #+4
   2680            
   2681            /* Get the status of the Interrupt */
   2682            if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
   \       0x28   0x2900             CMP      R1,#+0
   \       0x2A   0xD003             BEQ.N    ??RTC_GetITStatus_0
   \       0x2C   0x0410             LSLS     R0,R2,#+16
   \       0x2E   0xD001             BEQ.N    ??RTC_GetITStatus_0
   2683            {
   2684              bitstatus = SET;
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0xE000             B.N      ??RTC_GetITStatus_1
   2685            }
   2686            else
   2687            {
   2688              bitstatus = RESET;
   \                     ??RTC_GetITStatus_0: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   2689            }
   2690            return bitstatus;
   \                     ??RTC_GetITStatus_1: (+1)
   \       0x36   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x38   0x4770             BX       LR               ;; return
   2691          }
   2692          
   2693          /**
   2694            * @brief  Clears the RTC's interrupt pending bits.
   2695            * @param  RTC_IT: specifies the RTC interrupt pending bit to clear.
   2696            *          This parameter can be any combination of the following values:
   2697            *            @arg RTC_IT_TS: Time Stamp interrupt 
   2698            *            @arg RTC_IT_WUT: WakeUp Timer interrupt 
   2699            *            @arg RTC_IT_ALRB: Alarm B interrupt 
   2700            *            @arg RTC_IT_ALRA: Alarm A interrupt 
   2701            *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt
   2702            *            @arg RTC_IT_TAMP2: Tamper 2 event interrupt 
   2703            * @retval None
   2704            */

   \                                 In section .text, align 2, keep-with-next
   2705          void RTC_ClearITPendingBit(uint32_t RTC_IT)
   2706          {
   2707            uint32_t tmpreg = 0;
   \                     RTC_ClearITPendingBit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   2708          
   2709            /* Check the parameters */
   2710            assert_param(IS_RTC_CLEAR_IT(RTC_IT));
   2711          
   2712            /* Get the RTC_ISR Interrupt pending bits mask */
   2713            tmpreg = (uint32_t)(RTC_IT >> 4);
   \        0x2   0x0900             LSRS     R0,R0,#+4
   2714          
   2715            /* Clear the interrupt pending bits in the RTC_ISR register */
   2716            RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
   \        0x4   0x....             LDR.N    R1,??DataTable50_6  ;; 0x4000280c
   \        0x6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \        0x8   0xF050 0x0080      ORRS     R0,R0,#0x80
   \        0xC   0x680A             LDR      R2,[R1, #+0]
   \        0xE   0xF012 0x0280      ANDS     R2,R2,#0x80
   \       0x12   0xEA72 0x0000      ORNS     R0,R2,R0
   \       0x16   0x6008             STR      R0,[R1, #+0]
   2717          }
   \       0x18   0x4770             BX       LR               ;; return
   2718          
   2719          /**
   2720            * @}
   2721            */
   2722          
   2723          /**
   2724            * @brief  Converts a 2 digit decimal to BCD format.
   2725            * @param  Value: Byte to be converted.
   2726            * @retval Converted byte
   2727            */

   \                                 In section .text, align 2, keep-with-next
   2728          static uint8_t RTC_ByteToBcd2(uint8_t Value)
   2729          {
   2730            uint8_t bcdhigh = 0;
   \                     RTC_ByteToBcd2: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0xE001             B.N      ??RTC_ByteToBcd2_0
   2731            
   2732            while (Value >= 10)
   2733            {
   2734              bcdhigh++;
   \                     ??RTC_ByteToBcd2_1: (+1)
   \        0x4   0x1C49             ADDS     R1,R1,#+1
   2735              Value -= 10;
   \        0x6   0x380A             SUBS     R0,R0,#+10
   2736            }
   \                     ??RTC_ByteToBcd2_0: (+1)
   \        0x8   0x0002             MOVS     R2,R0
   \        0xA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \        0xC   0x2A0A             CMP      R2,#+10
   \        0xE   0xDAF9             BGE.N    ??RTC_ByteToBcd2_1
   2737            
   2738            return  ((uint8_t)(bcdhigh << 4) | Value);
   \       0x10   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \       0x14   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x16   0x4770             BX       LR               ;; return
   2739          }
   2740          
   2741          /**
   2742            * @brief  Convert from 2 digit BCD to Binary.
   2743            * @param  Value: BCD value to be converted.
   2744            * @retval Converted word
   2745            */

   \                                 In section .text, align 2, keep-with-next
   2746          static uint8_t RTC_Bcd2ToByte(uint8_t Value)
   2747          {
   2748            uint8_t tmp = 0;
   \                     RTC_Bcd2ToByte: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   2749            tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
   \        0x2   0x0001             MOVS     R1,R0
   \        0x4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x6   0x0909             LSRS     R1,R1,#+4
   \        0x8   0x220A             MOVS     R2,#+10
   \        0xA   0xFB11 0xF102      SMULBB   R1,R1,R2
   2750            return (tmp + (Value & (uint8_t)0x0F));
   \        0xE   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x12   0x1840             ADDS     R0,R0,R1
   \       0x14   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x16   0x4770             BX       LR               ;; return
   2751          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41:
   \        0x0   0x4000'2824        DC32     0x40002824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \        0x0   0x4000'2800        DC32     0x40002800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \        0x0   0x4000'2804        DC32     0x40002804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_1:
   \        0x0   0x4000'2808        DC32     0x40002808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44:
   \        0x0   0x4000'2814        DC32     0x40002814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_1:
   \        0x0   0x007F'00FF        DC32     0x7f00ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_2:
   \        0x0   0x4000'2810        DC32     0x40002810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_3:
   \        0x0   0x4000'2818        DC32     0x40002818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_4:
   \        0x0   0x4000'281C        DC32     0x4000281c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_5:
   \        0x0   0x4000'2820        DC32     0x40002820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_6:
   \        0x0   0x4000'282C        DC32     0x4000282c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45:
   \        0x0   0x4000'283C        DC32     0x4000283c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_1:
   \        0x0   0x4000'2844        DC32     0x40002844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_2:
   \        0x0   0x4000'2848        DC32     0x40002848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49:
   \        0x0   0x4000'280C        DC32     0x4000280c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50:
   \        0x0   0x4000'2840        DC32     0x40002840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_1:
   \        0x0   0x4000'2824        DC32     0x40002824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_2:
   \        0x0   0x4000'2808        DC32     0x40002808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_3:
   \        0x0   0x007F'7F7F        DC32     0x7f7f7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_4:
   \        0x0   0x4000'2828        DC32     0x40002828

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_5:
   \        0x0   0x00FF'FF3F        DC32     0xffff3f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_6:
   \        0x0   0x4000'280C        DC32     0x4000280c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_7:
   \        0x0   0xFFFF'F7F7        DC32     0xfffff7f7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_8:
   \        0x0   0x4000'2830        DC32     0x40002830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_9:
   \        0x0   0x4000'2834        DC32     0x40002834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_10:
   \        0x0   0x4000'2838        DC32     0x40002838

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_11:
   \        0x0   0x4000'2850        DC32     0x40002850

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_12:
   \        0x0   0x4000'282C        DC32     0x4000282c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_13:
   \        0x0   0x0001'7F7F        DC32     0x17f7f
   2752          
   2753          /**
   2754            * @}
   2755            */ 
   2756          
   2757          /**
   2758            * @}
   2759            */ 
   2760          
   2761          /**
   2762            * @}
   2763            */ 
   2764          
   2765          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   RTC_AlarmCmd
       0   RTC_AlarmStructInit
       4   RTC_AlarmSubSecondConfig
       0   RTC_Bcd2ToByte
       0   RTC_BypassShadowCmd
       0   RTC_ByteToBcd2
       0   RTC_CalibOutputCmd
       0   RTC_CalibOutputConfig
       0   RTC_ClearFlag
       0   RTC_ClearITPendingBit
      16   RTC_CoarseCalibCmd
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
      16   RTC_CoarseCalibConfig
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
       0   RTC_DateStructInit
       4   RTC_DayLightSavingConfig
      16   RTC_DeInit
        16   -> RTC_EnterInitMode
        16   -> RTC_WaitForSynchro
       4   RTC_EnterInitMode
       0   RTC_ExitInitMode
       8   RTC_GetAlarm
         8   -> RTC_Bcd2ToByte
       0   RTC_GetAlarmSubSecond
       8   RTC_GetDate
         8   -> RTC_Bcd2ToByte
       0   RTC_GetFlagStatus
       0   RTC_GetITStatus
       0   RTC_GetStoreOperation
       0   RTC_GetSubSecond
       8   RTC_GetTime
         8   -> RTC_Bcd2ToByte
      16   RTC_GetTimeStamp
        16   -> RTC_Bcd2ToByte
       0   RTC_GetTimeStampSubSecond
       0   RTC_GetWakeUpCounter
       4   RTC_ITConfig
      16   RTC_Init
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
       4   RTC_OutputConfig
       0   RTC_OutputTypeConfig
       4   RTC_ReadBackupRegister
      16   RTC_RefClockCmd
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
      24   RTC_SetAlarm
        24   -> RTC_Bcd2ToByte
        24   -> RTC_ByteToBcd2
      16   RTC_SetDate
        16   -> RTC_Bcd2ToByte
        16   -> RTC_ByteToBcd2
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
        16   -> RTC_WaitForSynchro
      16   RTC_SetTime
        16   -> RTC_Bcd2ToByte
        16   -> RTC_ByteToBcd2
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
        16   -> RTC_WaitForSynchro
       0   RTC_SetWakeUpCounter
      12   RTC_SmoothCalibConfig
       0   RTC_StructInit
      16   RTC_SynchroShiftConfig
        16   -> RTC_WaitForSynchro
       0   RTC_TamperCmd
       0   RTC_TamperFilterConfig
       0   RTC_TamperPinSelection
       0   RTC_TamperPinsPrechargeDuration
       0   RTC_TamperPullUpCmd
       0   RTC_TamperSamplingFreqConfig
       0   RTC_TamperTriggerConfig
       4   RTC_TimeStampCmd
       0   RTC_TimeStampOnTamperDetectionCmd
       0   RTC_TimeStampPinSelection
       0   RTC_TimeStructInit
       4   RTC_WaitForSynchro
       0   RTC_WakeUpClockConfig
       4   RTC_WakeUpCmd
       4   RTC_WriteBackupRegister
       0   RTC_WriteProtectionCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable41
       4  ??DataTable42
       4  ??DataTable43
       4  ??DataTable43_1
       4  ??DataTable44
       4  ??DataTable44_1
       4  ??DataTable44_2
       4  ??DataTable44_3
       4  ??DataTable44_4
       4  ??DataTable44_5
       4  ??DataTable44_6
       4  ??DataTable45
       4  ??DataTable45_1
       4  ??DataTable45_2
       4  ??DataTable49
       4  ??DataTable50
       4  ??DataTable50_1
       4  ??DataTable50_10
       4  ??DataTable50_11
       4  ??DataTable50_12
       4  ??DataTable50_13
       4  ??DataTable50_2
       4  ??DataTable50_3
       4  ??DataTable50_4
       4  ??DataTable50_5
       4  ??DataTable50_6
       4  ??DataTable50_7
       4  ??DataTable50_8
       4  ??DataTable50_9
     106  RTC_AlarmCmd
      30  RTC_AlarmStructInit
      46  RTC_AlarmSubSecondConfig
      24  RTC_Bcd2ToByte
      50  RTC_BypassShadowCmd
      24  RTC_ByteToBcd2
      48  RTC_CalibOutputCmd
      34  RTC_CalibOutputConfig
      22  RTC_ClearFlag
      26  RTC_ClearITPendingBit
      74  RTC_CoarseCalibCmd
      50  RTC_CoarseCalibConfig
      18  RTC_DateStructInit
      40  RTC_DayLightSavingConfig
     218  RTC_DeInit
      72  RTC_EnterInitMode
      14  RTC_ExitInitMode
     122  RTC_GetAlarm
      32  RTC_GetAlarmSubSecond
      78  RTC_GetDate
      26  RTC_GetFlagStatus
      58  RTC_GetITStatus
      12  RTC_GetStoreOperation
      16  RTC_GetSubSecond
      82  RTC_GetTime
     142  RTC_GetTimeStamp
       6  RTC_GetTimeStampSubSecond
      10  RTC_GetWakeUpCounter
      78  RTC_ITConfig
      82  RTC_Init
      40  RTC_OutputConfig
      18  RTC_OutputTypeConfig
      26  RTC_ReadBackupRegister
      76  RTC_RefClockCmd
     228  RTC_SetAlarm
     190  RTC_SetDate
     196  RTC_SetTime
      24  RTC_SetWakeUpCounter
      72  RTC_SmoothCalibConfig
      14  RTC_StructInit
      90  RTC_SynchroShiftConfig
      28  RTC_TamperCmd
      18  RTC_TamperFilterConfig
      18  RTC_TamperPinSelection
      18  RTC_TamperPinsPrechargeDuration
      30  RTC_TamperPullUpCmd
      18  RTC_TamperSamplingFreqConfig
      28  RTC_TamperTriggerConfig
      50  RTC_TimeStampCmd
      30  RTC_TimeStampOnTamperDetectionCmd
      18  RTC_TimeStampPinSelection
      18  RTC_TimeStructInit
      80  RTC_WaitForSynchro
      36  RTC_WakeUpClockConfig
     106  RTC_WakeUpCmd
      26  RTC_WriteBackupRegister
      30  RTC_WriteProtectionCmd

 
 3'282 bytes in section .text
 
 3'282 bytes of CODE memory

Errors: none
Warnings: none
