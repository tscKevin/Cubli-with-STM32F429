###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.2.214/W32 for ARM         14/Jul/2020  18:42:06
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_ltdc.c
#    Command line =
#        -f C:\Users\Evan\AppData\Local\Temp\EW9DEE.tmp
#        (E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_ltdc.c
#        -D USE_STDPERIPH_DRIVER -D STM32F429_439xx -lC
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List
#        -o
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\IAR Systems\Embedded
#        Workbench 8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\iar\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\user\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\user\src\
#        -Ol --use_c++_inline -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List\stm32f4xx_ltdc.lst
#    Object file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj\stm32f4xx_ltdc.o
#
###############################################################################

E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_ltdc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_ltdc.c
      4            * @author  MCD Application Team
      5            * @version V1.8.0
      6            * @date    04-November-2016
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the LTDC controller (LTDC) peripheral:
      9            *           + Initialization and configuration
     10            *           + Interrupts and flags management
     11            *           
     12            *  @verbatim
     13            
     14           ===============================================================================
     15                                ##### How to use this driver #####
     16           ===============================================================================
     17              [..]
     18                  (#) Enable LTDC clock using 
     19                      RCC_APB2PeriphResetCmd(RCC_APB2Periph_LTDC, ENABLE) function.
     20                  (#) Configures LTDC
     21                    (++) Configure the required Pixel clock following the panel datasheet
     22                    (++) Configure the Synchronous timings: VSYNC, HSYNC, Vertical and 
     23                        Horizontal back proch, active data area and the front proch 
     24                        timings 
     25                    (++) Configure the synchronous signals and clock polarity in the 
     26                        LTDC_GCR register
     27                  (#) Configures Layer1/2 parameters
     28                    (++) The Layer window horizontal and vertical position in the LTDC_LxWHPCR and 
     29                         LTDC_WVPCR registers. The layer window must be in the active data area.
     30                    (++) The pixel input format in the LTDC_LxPFCR register
     31                    (++) The color frame buffer start address in the LTDC_LxCFBAR register
     32                    (++) The line length and pitch of the color frame buffer in the 
     33                         LTDC_LxCFBLR register
     34                    (++) The number of lines of the color frame buffer in 
     35                         the LTDC_LxCFBLNR register
     36                    (++) if needed, load the CLUT with the RGB values and the address 
     37                         in the LTDC_LxCLUTWR register
     38                    (++) If needed, configure the default color and the blending factors 
     39                         respectively in the LTDC_LxDCCR and LTDC_LxBFCR registers 
     40          
     41                    (++) If needed, Dithering and color keying can be enabled respectively 
     42                         in the LTDC_GCR and LTDC_LxCKCR registers. It can be also enabled 
     43                         on the fly.    
     44                  (#) Enable Layer1/2 and if needed the CLUT in the LTDC_LxCR register 
     45            
     46                  (#) Reload the shadow registers to active register through 
     47                      the LTDC_SRCR register.
     48                    -@- All layer parameters can be modified on the fly except the CLUT. 
     49                        The new configuration has to be either reloaded immediately 
     50                        or during vertical blanking period by configuring the LTDC_SRCR register.
     51                  (#) Call the LTDC_Cmd() to enable the LTDC controller.
     52          
     53              @endverbatim
     54            
     55            ******************************************************************************
     56            * @attention
     57            *
     58            * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
     59            *
     60            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     61            * You may not use this file except in compliance with the License.
     62            * You may obtain a copy of the License at:
     63            *
     64            *        http://www.st.com/software_license_agreement_liberty_v2
     65            *
     66            * Unless required by applicable law or agreed to in writing, software 
     67            * distributed under the License is distributed on an "AS IS" BASIS, 
     68            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     69            * See the License for the specific language governing permissions and
     70            * limitations under the License.
     71            *
     72            ******************************************************************************
     73            */
     74          
     75          /* Includes ------------------------------------------------------------------*/
     76          #include "stm32f4xx_ltdc.h"
     77          #include "stm32f4xx_rcc.h"
     78          
     79          /** @addtogroup STM32F4xx_StdPeriph_Driver
     80            * @{
     81            */
     82          
     83          /** @defgroup LTDC 
     84            * @brief LTDC driver modules
     85            * @{
     86            */
     87          
     88          /* Private typedef -----------------------------------------------------------*/
     89          /* Private define ------------------------------------------------------------*/
     90          /* Private macro -------------------------------------------------------------*/
     91          /* Private variables ---------------------------------------------------------*/
     92          /* Private function prototypes -----------------------------------------------*/
     93          /* Private functions ---------------------------------------------------------*/
     94          
     95          #define GCR_MASK                     ((uint32_t)0x0FFE888F)  /* LTDC GCR Mask */
     96          
     97          
     98          /** @defgroup LTDC_Private_Functions
     99            * @{
    100            */
    101          
    102          /** @defgroup LTDC_Group1 Initialization and Configuration functions
    103           *  @brief   Initialization and Configuration functions 
    104           *
    105          @verbatim
    106           ===============================================================================
    107                      ##### Initialization and Configuration functions #####
    108           ===============================================================================
    109              [..]  This section provides functions allowing to:
    110                (+) Initialize and configure the LTDC
    111                (+) Enable or Disable Dither
    112                (+) Define the position of the line interrupt
    113                (+) reload layers registers with new parameters
    114                (+) Initialize and configure layer1 and layer2
    115                (+) Set and configure the color keying functionality
    116                (+) Configure and Enables or disables CLUT 
    117                
    118          @endverbatim
    119            * @{
    120            */
    121          
    122          /**
    123            * @brief  Deinitializes the LTDC peripheral registers to their default reset
    124            *         values.
    125            * @param  None
    126            * @retval None
    127            */
    128          

   \                                 In section .text, align 2, keep-with-next
    129          void LTDC_DeInit(void)
    130          {
   \                     LTDC_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    131            /* Enable LTDC reset state */
    132            RCC_APB2PeriphResetCmd(RCC_APB2Periph_LTDC, ENABLE);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0xF05F 0x6080      MOVS     R0,#+67108864
   \        0x8   0x....'....        BL       RCC_APB2PeriphResetCmd
    133            /* Release LTDC from reset state */
    134            RCC_APB2PeriphResetCmd(RCC_APB2Periph_LTDC, DISABLE);
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0xF05F 0x6080      MOVS     R0,#+67108864
   \       0x12   0x....'....        BL       RCC_APB2PeriphResetCmd
    135          }
   \       0x16   0xBD01             POP      {R0,PC}          ;; return
    136          
    137          /**
    138            * @brief  Initializes the LTDC peripheral according to the specified parameters
    139            *         in the LTDC_InitStruct.
    140            * @note   This function can be used only when the LTDC is disabled.
    141            * @param  LTDC_InitStruct: pointer to a LTDC_InitTypeDef structure that contains
    142            *         the configuration information for the specified LTDC peripheral.
    143            * @retval None
    144            */
    145          

   \                                 In section .text, align 2, keep-with-next
    146          void LTDC_Init(LTDC_InitTypeDef* LTDC_InitStruct)
    147          {
   \                     LTDC_Init: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    148            uint32_t horizontalsync = 0;
   \        0x2   0x2100             MOVS     R1,#+0
    149            uint32_t accumulatedHBP = 0;
   \        0x4   0x2100             MOVS     R1,#+0
    150            uint32_t accumulatedactiveW = 0;
   \        0x6   0x2100             MOVS     R1,#+0
    151            uint32_t totalwidth = 0;
   \        0x8   0x2100             MOVS     R1,#+0
    152            uint32_t backgreen = 0;
   \        0xA   0x2100             MOVS     R1,#+0
    153            uint32_t backred = 0;
   \        0xC   0x2100             MOVS     R1,#+0
    154          
    155            /* Check function parameters */
    156            assert_param(IS_LTDC_HSYNC(LTDC_InitStruct->LTDC_HorizontalSync));
    157            assert_param(IS_LTDC_VSYNC(LTDC_InitStruct->LTDC_VerticalSync));
    158            assert_param(IS_LTDC_AHBP(LTDC_InitStruct->LTDC_AccumulatedHBP));
    159            assert_param(IS_LTDC_AVBP(LTDC_InitStruct->LTDC_AccumulatedVBP));
    160            assert_param(IS_LTDC_AAH(LTDC_InitStruct->LTDC_AccumulatedActiveH));
    161            assert_param(IS_LTDC_AAW(LTDC_InitStruct->LTDC_AccumulatedActiveW));
    162            assert_param(IS_LTDC_TOTALH(LTDC_InitStruct->LTDC_TotalHeigh));
    163            assert_param(IS_LTDC_TOTALW(LTDC_InitStruct->LTDC_TotalWidth));
    164            assert_param(IS_LTDC_HSPOL(LTDC_InitStruct->LTDC_HSPolarity));
    165            assert_param(IS_LTDC_VSPOL(LTDC_InitStruct->LTDC_VSPolarity));
    166            assert_param(IS_LTDC_DEPOL(LTDC_InitStruct->LTDC_DEPolarity));
    167            assert_param(IS_LTDC_PCPOL(LTDC_InitStruct->LTDC_PCPolarity));
    168            assert_param(IS_LTDC_BackBlueValue(LTDC_InitStruct->LTDC_BackgroundBlueValue));
    169            assert_param(IS_LTDC_BackGreenValue(LTDC_InitStruct->LTDC_BackgroundGreenValue));
    170            assert_param(IS_LTDC_BackRedValue(LTDC_InitStruct->LTDC_BackgroundRedValue));
    171          
    172            /* Sets Synchronization size */
    173            LTDC->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
   \        0xE   0x....'....        LDR.W    R2,??DataTable17  ;; 0xf000f800
   \       0x12   0x....'....        LDR.W    R4,??DataTable17_1  ;; 0x40016808
   \       0x16   0x6821             LDR      R1,[R4, #+0]
   \       0x18   0x4011             ANDS     R1,R2,R1
   \       0x1A   0x6021             STR      R1,[R4, #+0]
    174            horizontalsync = (LTDC_InitStruct->LTDC_HorizontalSync << 16);
   \       0x1C   0x6903             LDR      R3,[R0, #+16]
   \       0x1E   0x041B             LSLS     R3,R3,#+16
    175            LTDC->SSCR |= (horizontalsync | LTDC_InitStruct->LTDC_VerticalSync);
   \       0x20   0x6825             LDR      R5,[R4, #+0]
   \       0x22   0x6941             LDR      R1,[R0, #+20]
   \       0x24   0x430B             ORRS     R3,R1,R3
   \       0x26   0x432B             ORRS     R3,R3,R5
   \       0x28   0x6023             STR      R3,[R4, #+0]
    176          
    177            /* Sets Accumulated Back porch */
    178            LTDC->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
   \       0x2A   0x....'....        LDR.W    R4,??DataTable17_2  ;; 0x4001680c
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0x4011             ANDS     R1,R2,R1
   \       0x32   0x6021             STR      R1,[R4, #+0]
    179            accumulatedHBP = (LTDC_InitStruct->LTDC_AccumulatedHBP << 16);
   \       0x34   0x6983             LDR      R3,[R0, #+24]
   \       0x36   0x041B             LSLS     R3,R3,#+16
    180            LTDC->BPCR |= (accumulatedHBP | LTDC_InitStruct->LTDC_AccumulatedVBP);
   \       0x38   0x6825             LDR      R5,[R4, #+0]
   \       0x3A   0x69C1             LDR      R1,[R0, #+28]
   \       0x3C   0x430B             ORRS     R3,R1,R3
   \       0x3E   0x432B             ORRS     R3,R3,R5
   \       0x40   0x6023             STR      R3,[R4, #+0]
    181          
    182            /* Sets Accumulated Active Width */
    183            LTDC->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
   \       0x42   0x....'....        LDR.W    R4,??DataTable17_3  ;; 0x40016810
   \       0x46   0x6821             LDR      R1,[R4, #+0]
   \       0x48   0x4011             ANDS     R1,R2,R1
   \       0x4A   0x6021             STR      R1,[R4, #+0]
    184            accumulatedactiveW = (LTDC_InitStruct->LTDC_AccumulatedActiveW << 16);
   \       0x4C   0x6A03             LDR      R3,[R0, #+32]
   \       0x4E   0x041B             LSLS     R3,R3,#+16
    185            LTDC->AWCR |= (accumulatedactiveW | LTDC_InitStruct->LTDC_AccumulatedActiveH);
   \       0x50   0x6825             LDR      R5,[R4, #+0]
   \       0x52   0x6A41             LDR      R1,[R0, #+36]
   \       0x54   0x430B             ORRS     R3,R1,R3
   \       0x56   0x432B             ORRS     R3,R3,R5
   \       0x58   0x6023             STR      R3,[R4, #+0]
    186          
    187            /* Sets Total Width */
    188            LTDC->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
   \       0x5A   0x....'....        LDR.W    R3,??DataTable17_4  ;; 0x40016814
   \       0x5E   0x6819             LDR      R1,[R3, #+0]
   \       0x60   0x400A             ANDS     R2,R2,R1
   \       0x62   0x601A             STR      R2,[R3, #+0]
    189            totalwidth = (LTDC_InitStruct->LTDC_TotalWidth << 16);
   \       0x64   0x6A82             LDR      R2,[R0, #+40]
   \       0x66   0x0412             LSLS     R2,R2,#+16
    190            LTDC->TWCR |= (totalwidth | LTDC_InitStruct->LTDC_TotalHeigh);
   \       0x68   0x681C             LDR      R4,[R3, #+0]
   \       0x6A   0x6AC1             LDR      R1,[R0, #+44]
   \       0x6C   0x430A             ORRS     R2,R1,R2
   \       0x6E   0x4322             ORRS     R2,R2,R4
   \       0x70   0x601A             STR      R2,[R3, #+0]
    191          
    192            LTDC->GCR &= (uint32_t)GCR_MASK;
   \       0x72   0x....'....        LDR.W    R2,??DataTable17_5  ;; 0x40016818
   \       0x76   0x6813             LDR      R3,[R2, #+0]
   \       0x78   0x....'....        LDR.W    R1,??DataTable17_6  ;; 0xffe888f
   \       0x7C   0x400B             ANDS     R3,R1,R3
   \       0x7E   0x6013             STR      R3,[R2, #+0]
    193            LTDC->GCR |=  (uint32_t)(LTDC_InitStruct->LTDC_HSPolarity | LTDC_InitStruct->LTDC_VSPolarity | \
    194                                     LTDC_InitStruct->LTDC_DEPolarity | LTDC_InitStruct->LTDC_PCPolarity);
   \       0x80   0x6813             LDR      R3,[R2, #+0]
   \       0x82   0x6804             LDR      R4,[R0, #+0]
   \       0x84   0x6841             LDR      R1,[R0, #+4]
   \       0x86   0x430C             ORRS     R4,R1,R4
   \       0x88   0x6881             LDR      R1,[R0, #+8]
   \       0x8A   0x430C             ORRS     R4,R1,R4
   \       0x8C   0x68C1             LDR      R1,[R0, #+12]
   \       0x8E   0x430C             ORRS     R4,R1,R4
   \       0x90   0x4323             ORRS     R3,R4,R3
   \       0x92   0x6013             STR      R3,[R2, #+0]
    195          
    196            /* sets the background color value */
    197            backgreen = (LTDC_InitStruct->LTDC_BackgroundGreenValue << 8);
   \       0x94   0x6B41             LDR      R1,[R0, #+52]
   \       0x96   0x0209             LSLS     R1,R1,#+8
    198            backred = (LTDC_InitStruct->LTDC_BackgroundRedValue << 16);
   \       0x98   0x6B02             LDR      R2,[R0, #+48]
   \       0x9A   0x0412             LSLS     R2,R2,#+16
    199          
    200            LTDC->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
   \       0x9C   0x....'....        LDR.W    R3,??DataTable17_7  ;; 0x4001682c
   \       0xA0   0x681C             LDR      R4,[R3, #+0]
   \       0xA2   0xF014 0x447F      ANDS     R4,R4,#0xFF000000
   \       0xA6   0x601C             STR      R4,[R3, #+0]
    201            LTDC->BCCR |= (backred | backgreen | LTDC_InitStruct->LTDC_BackgroundBlueValue);
   \       0xA8   0x681C             LDR      R4,[R3, #+0]
   \       0xAA   0x4311             ORRS     R1,R1,R2
   \       0xAC   0x6B80             LDR      R0,[R0, #+56]
   \       0xAE   0x4301             ORRS     R1,R0,R1
   \       0xB0   0x4321             ORRS     R1,R1,R4
   \       0xB2   0x6019             STR      R1,[R3, #+0]
    202          }
   \       0xB4   0xBC30             POP      {R4,R5}
   \       0xB6   0x4770             BX       LR               ;; return
    203          
    204          /**
    205            * @brief  Fills each LTDC_InitStruct member with its default value.
    206            * @param  LTDC_InitStruct: pointer to a LTDC_InitTypeDef structure which will
    207            *         be initialized.
    208            * @retval None
    209            */
    210          

   \                                 In section .text, align 2, keep-with-next
    211          void LTDC_StructInit(LTDC_InitTypeDef* LTDC_InitStruct)
    212          {
    213            /*--------------- Reset LTDC init structure parameters values ----------------*/
    214            LTDC_InitStruct->LTDC_HSPolarity = LTDC_HSPolarity_AL;      /*!< Initialize the LTDC_HSPolarity member */ 
   \                     LTDC_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    215            LTDC_InitStruct->LTDC_VSPolarity = LTDC_VSPolarity_AL;      /*!< Initialize the LTDC_VSPolarity member */
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6041             STR      R1,[R0, #+4]
    216            LTDC_InitStruct->LTDC_DEPolarity = LTDC_DEPolarity_AL;      /*!< Initialize the LTDC_DEPolarity member */
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6081             STR      R1,[R0, #+8]
    217            LTDC_InitStruct->LTDC_PCPolarity = LTDC_PCPolarity_IPC;     /*!< Initialize the LTDC_PCPolarity member */
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x60C1             STR      R1,[R0, #+12]
    218            LTDC_InitStruct->LTDC_HorizontalSync = 0x00;                /*!< Initialize the LTDC_HorizontalSync member */
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x6101             STR      R1,[R0, #+16]
    219            LTDC_InitStruct->LTDC_VerticalSync = 0x00;                  /*!< Initialize the LTDC_VerticalSync member */
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6141             STR      R1,[R0, #+20]
    220            LTDC_InitStruct->LTDC_AccumulatedHBP = 0x00;                /*!< Initialize the LTDC_AccumulatedHBP member */
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6181             STR      R1,[R0, #+24]
    221            LTDC_InitStruct->LTDC_AccumulatedVBP = 0x00;                /*!< Initialize the LTDC_AccumulatedVBP member */
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x61C1             STR      R1,[R0, #+28]
    222            LTDC_InitStruct->LTDC_AccumulatedActiveW = 0x00;            /*!< Initialize the LTDC_AccumulatedActiveW member */
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6201             STR      R1,[R0, #+32]
    223            LTDC_InitStruct->LTDC_AccumulatedActiveH = 0x00;            /*!< Initialize the LTDC_AccumulatedActiveH member */
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x6241             STR      R1,[R0, #+36]
    224            LTDC_InitStruct->LTDC_TotalWidth = 0x00;                    /*!< Initialize the LTDC_TotalWidth member */
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x6281             STR      R1,[R0, #+40]
    225            LTDC_InitStruct->LTDC_TotalHeigh = 0x00;                    /*!< Initialize the LTDC_TotalHeigh member */
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x62C1             STR      R1,[R0, #+44]
    226            LTDC_InitStruct->LTDC_BackgroundRedValue = 0x00;            /*!< Initialize the LTDC_BackgroundRedValue member */
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x6301             STR      R1,[R0, #+48]
    227            LTDC_InitStruct->LTDC_BackgroundGreenValue = 0x00;          /*!< Initialize the LTDC_BackgroundGreenValue member */
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x6341             STR      R1,[R0, #+52]
    228            LTDC_InitStruct->LTDC_BackgroundBlueValue = 0x00;           /*!< Initialize the LTDC_BackgroundBlueValue member */
   \       0x38   0x2100             MOVS     R1,#+0
   \       0x3A   0x6381             STR      R1,[R0, #+56]
    229          }
   \       0x3C   0x4770             BX       LR               ;; return
    230          
    231          /**
    232            * @brief  Enables or disables the LTDC Controller.
    233            * @param  NewState: new state of the LTDC peripheral.
    234            *   This parameter can be: ENABLE or DISABLE.
    235            * @retval None
    236            */
    237          

   \                                 In section .text, align 2, keep-with-next
    238          void LTDC_Cmd(FunctionalState NewState)
    239          {
    240            /* Check the parameters */
    241            assert_param(IS_FUNCTIONAL_STATE(NewState));
    242          
    243            if (NewState != DISABLE)
   \                     LTDC_Cmd: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD006             BEQ.N    ??LTDC_Cmd_0
    244            {
    245              /* Enable LTDC by setting LTDCEN bit */
    246              LTDC->GCR |= (uint32_t)LTDC_GCR_LTDCEN;
   \        0x6   0x....'....        LDR.W    R0,??DataTable17_5  ;; 0x40016818
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x10   0x6001             STR      R1,[R0, #+0]
   \       0x12   0xE005             B.N      ??LTDC_Cmd_1
    247            }
    248            else
    249            {
    250              /* Disable LTDC by clearing LTDCEN bit */
    251              LTDC->GCR &= ~(uint32_t)LTDC_GCR_LTDCEN;
   \                     ??LTDC_Cmd_0: (+1)
   \       0x14   0x....'....        LDR.W    R0,??DataTable17_5  ;; 0x40016818
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0x0849             LSRS     R1,R1,#+1
   \       0x1C   0x0049             LSLS     R1,R1,#+1
   \       0x1E   0x6001             STR      R1,[R0, #+0]
    252            }
    253          }
   \                     ??LTDC_Cmd_1: (+1)
   \       0x20   0x4770             BX       LR               ;; return
    254          
    255          /**
    256            * @brief  Enables or disables Dither.
    257            * @param  NewState: new state of the Dither.
    258            *   This parameter can be: ENABLE or DISABLE.
    259            * @retval None
    260            */
    261          

   \                                 In section .text, align 2, keep-with-next
    262          void LTDC_DitherCmd(FunctionalState NewState)
    263          {
    264            /* Check the parameters */
    265            assert_param(IS_FUNCTIONAL_STATE(NewState));
    266          
    267            if (NewState != DISABLE)
   \                     LTDC_DitherCmd: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD006             BEQ.N    ??LTDC_DitherCmd_0
    268            {
    269              /* Enable Dither by setting DTEN bit */
    270              LTDC->GCR |= (uint32_t)LTDC_GCR_DTEN;
   \        0x6   0x....'....        LDR.W    R0,??DataTable17_5  ;; 0x40016818
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \       0x10   0x6001             STR      R1,[R0, #+0]
   \       0x12   0xE005             B.N      ??LTDC_DitherCmd_1
    271            }
    272            else
    273            {
    274              /* Disable Dither by clearing DTEN bit */
    275              LTDC->GCR &= ~(uint32_t)LTDC_GCR_DTEN;
   \                     ??LTDC_DitherCmd_0: (+1)
   \       0x14   0x....'....        LDR.W    R0,??DataTable17_5  ;; 0x40016818
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xF431 0x3180      BICS     R1,R1,#0x10000
   \       0x1E   0x6001             STR      R1,[R0, #+0]
    276            }
    277          }
   \                     ??LTDC_DitherCmd_1: (+1)
   \       0x20   0x4770             BX       LR               ;; return
    278          
    279          /**
    280            * @brief  Get the dither RGB width.
    281            * @param  LTDC_RGB_InitStruct: pointer to a LTDC_RGBTypeDef structure that contains
    282            *         the Dither RGB width.
    283            * @retval None
    284            */
    285          

   \                                 In section .text, align 2, keep-with-next
    286          LTDC_RGBTypeDef LTDC_GetRGBWidth(void)
    287          {
   \                     LTDC_GetRGBWidth: (+1)
   \        0x0   0xB41E             PUSH     {R1-R4}
    288            LTDC_RGBTypeDef LTDC_RGB_InitStruct;
    289          
    290            LTDC->GCR &= (uint32_t)GCR_MASK;
   \        0x2   0x....'....        LDR.W    R2,??DataTable17_5  ;; 0x40016818
   \        0x6   0x6813             LDR      R3,[R2, #+0]
   \        0x8   0x....'....        LDR.W    R1,??DataTable17_6  ;; 0xffe888f
   \        0xC   0x400B             ANDS     R3,R1,R3
   \        0xE   0x6013             STR      R3,[R2, #+0]
    291          
    292            LTDC_RGB_InitStruct.LTDC_BlueWidth = (uint32_t)((LTDC->GCR >> 4) & 0x7);
   \       0x10   0x6811             LDR      R1,[R2, #+0]
   \       0x12   0xF3C1 0x1102      UBFX     R1,R1,#+4,#+3
   \       0x16   0x9100             STR      R1,[SP, #+0]
    293            LTDC_RGB_InitStruct.LTDC_GreenWidth = (uint32_t)((LTDC->GCR >> 8) & 0x7);
   \       0x18   0x6811             LDR      R1,[R2, #+0]
   \       0x1A   0xF3C1 0x2102      UBFX     R1,R1,#+8,#+3
   \       0x1E   0x9101             STR      R1,[SP, #+4]
    294            LTDC_RGB_InitStruct.LTDC_RedWidth = (uint32_t)((LTDC->GCR >> 12) & 0x7);
   \       0x20   0x6811             LDR      R1,[R2, #+0]
   \       0x22   0xF3C1 0x3102      UBFX     R1,R1,#+12,#+3
   \       0x26   0x9102             STR      R1,[SP, #+8]
    295          
    296            return LTDC_RGB_InitStruct;
   \       0x28   0x4669             MOV      R1,SP
   \       0x2A   0xE891 0x001C      LDM      R1,{R2-R4}
   \       0x2E   0xE880 0x001C      STM      R0,{R2-R4}
   \       0x32   0xBC17             POP      {R0-R2,R4}
   \       0x34   0x4770             BX       LR               ;; return
    297          }
    298          
    299          /**
    300            * @brief  Fills each LTDC_RGBStruct member with its default value.
    301            * @param  LTDC_RGB_InitStruct: pointer to a LTDC_RGBTypeDef structure which will
    302            *         be initialized.
    303            * @retval None
    304            */
    305          

   \                                 In section .text, align 2, keep-with-next
    306          void LTDC_RGBStructInit(LTDC_RGBTypeDef* LTDC_RGB_InitStruct)
    307          {
    308            LTDC_RGB_InitStruct->LTDC_BlueWidth = 0x02;
   \                     LTDC_RGBStructInit: (+1)
   \        0x0   0x2102             MOVS     R1,#+2
   \        0x2   0x6001             STR      R1,[R0, #+0]
    309            LTDC_RGB_InitStruct->LTDC_GreenWidth = 0x02;
   \        0x4   0x2102             MOVS     R1,#+2
   \        0x6   0x6041             STR      R1,[R0, #+4]
    310            LTDC_RGB_InitStruct->LTDC_RedWidth = 0x02;
   \        0x8   0x2102             MOVS     R1,#+2
   \        0xA   0x6081             STR      R1,[R0, #+8]
    311          }
   \        0xC   0x4770             BX       LR               ;; return
    312          
    313          
    314          /**
    315            * @brief  Define the position of the line interrupt .
    316            * @param  LTDC_LIPositionConfig: Line Interrupt Position.
    317            * @retval None
    318            */
    319          

   \                                 In section .text, align 2, keep-with-next
    320          void LTDC_LIPConfig(uint32_t LTDC_LIPositionConfig)
    321          {
    322            /* Check the parameters */
    323            assert_param(IS_LTDC_LIPOS(LTDC_LIPositionConfig));
    324          
    325            /* Sets the Line Interrupt position */
    326            LTDC->LIPCR = (uint32_t)LTDC_LIPositionConfig;
   \                     LTDC_LIPConfig: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable17_8  ;; 0x40016840
   \        0x4   0x6008             STR      R0,[R1, #+0]
    327          }
   \        0x6   0x4770             BX       LR               ;; return
    328          
    329          /**
    330            * @brief  reload layers registers with new parameters 
    331            * @param  LTDC_Reload: specifies the type of reload.
    332            *   This parameter can be one of the following values:
    333            *     @arg LTDC_IMReload: Vertical blanking reload.
    334            *     @arg LTDC_VBReload: Immediate reload.  
    335            * @retval None
    336            */
    337          

   \                                 In section .text, align 2, keep-with-next
    338          void LTDC_ReloadConfig(uint32_t LTDC_Reload)
    339          {
    340            /* Check the parameters */
    341            assert_param(IS_LTDC_RELOAD(LTDC_Reload));
    342          
    343            /* Sets the Reload type */
    344            LTDC->SRCR = (uint32_t)LTDC_Reload;
   \                     LTDC_ReloadConfig: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable17_9  ;; 0x40016824
   \        0x4   0x6008             STR      R0,[R1, #+0]
    345          }
   \        0x6   0x4770             BX       LR               ;; return
    346          
    347          
    348          /**
    349            * @brief  Initializes the LTDC Layer according to the specified parameters
    350            *         in the LTDC_LayerStruct.
    351            * @note   This function can be used only when the LTDC is disabled.
    352            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    353            *         one of the following values: LTDC_Layer1, LTDC_Layer2    
    354            * @param  LTDC_LayerStruct: pointer to a LTDC_LayerTypeDef structure that contains
    355            *         the configuration information for the specified LTDC peripheral.
    356            * @retval None
    357            */
    358          

   \                                 In section .text, align 2, keep-with-next
    359          void LTDC_LayerInit(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_Layer_InitTypeDef* LTDC_Layer_InitStruct)
    360          {
   \                     LTDC_LayerInit: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    361          
    362            uint32_t whsppos = 0;
   \        0x2   0x2200             MOVS     R2,#+0
    363            uint32_t wvsppos = 0;
   \        0x4   0x2200             MOVS     R2,#+0
    364            uint32_t dcgreen = 0;
   \        0x6   0x2200             MOVS     R2,#+0
    365            uint32_t dcred = 0;
   \        0x8   0x2200             MOVS     R2,#+0
    366            uint32_t dcalpha = 0;
   \        0xA   0x2200             MOVS     R2,#+0
    367            uint32_t cfbp = 0;
   \        0xC   0x2200             MOVS     R2,#+0
    368          
    369          /* Check the parameters */
    370            assert_param(IS_LTDC_Pixelformat(LTDC_Layer_InitStruct->LTDC_PixelFormat));
    371            assert_param(IS_LTDC_BlendingFactor1(LTDC_Layer_InitStruct->LTDC_BlendingFactor_1));
    372            assert_param(IS_LTDC_BlendingFactor2(LTDC_Layer_InitStruct->LTDC_BlendingFactor_2));
    373            assert_param(IS_LTDC_HCONFIGST(LTDC_Layer_InitStruct->LTDC_HorizontalStart));
    374            assert_param(IS_LTDC_HCONFIGSP(LTDC_Layer_InitStruct->LTDC_HorizontalStop));
    375            assert_param(IS_LTDC_VCONFIGST(LTDC_Layer_InitStruct->LTDC_VerticalStart));
    376            assert_param(IS_LTDC_VCONFIGSP(LTDC_Layer_InitStruct->LTDC_VerticalStop));  
    377            assert_param(IS_LTDC_DEFAULTCOLOR(LTDC_Layer_InitStruct->LTDC_DefaultColorBlue));
    378            assert_param(IS_LTDC_DEFAULTCOLOR(LTDC_Layer_InitStruct->LTDC_DefaultColorGreen));
    379            assert_param(IS_LTDC_DEFAULTCOLOR(LTDC_Layer_InitStruct->LTDC_DefaultColorRed));
    380            assert_param(IS_LTDC_DEFAULTCOLOR(LTDC_Layer_InitStruct->LTDC_DefaultColorAlpha));
    381            assert_param(IS_LTDC_CFBP(LTDC_Layer_InitStruct->LTDC_CFBPitch));
    382            assert_param(IS_LTDC_CFBLL(LTDC_Layer_InitStruct->LTDC_CFBLineLength));
    383            assert_param(IS_LTDC_CFBLNBR(LTDC_Layer_InitStruct->LTDC_CFBLineNumber));
    384          
    385            /* Configures the horizontal start and stop position */
    386            whsppos = LTDC_Layer_InitStruct->LTDC_HorizontalStop << 16;
   \        0xE   0x684A             LDR      R2,[R1, #+4]
   \       0x10   0x0412             LSLS     R2,R2,#+16
    387            LTDC_Layerx->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
   \       0x12   0x6843             LDR      R3,[R0, #+4]
   \       0x14   0xF413 0x4370      ANDS     R3,R3,#0xF000
   \       0x18   0x6043             STR      R3,[R0, #+4]
    388            LTDC_Layerx->WHPCR = (LTDC_Layer_InitStruct->LTDC_HorizontalStart | whsppos);
   \       0x1A   0x680B             LDR      R3,[R1, #+0]
   \       0x1C   0x431A             ORRS     R2,R2,R3
   \       0x1E   0x6042             STR      R2,[R0, #+4]
    389          
    390            /* Configures the vertical start and stop position */
    391            wvsppos = LTDC_Layer_InitStruct->LTDC_VerticalStop << 16;
   \       0x20   0x68CA             LDR      R2,[R1, #+12]
   \       0x22   0x0412             LSLS     R2,R2,#+16
    392            LTDC_Layerx->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
   \       0x24   0x6883             LDR      R3,[R0, #+8]
   \       0x26   0xF413 0x4370      ANDS     R3,R3,#0xF000
   \       0x2A   0x6083             STR      R3,[R0, #+8]
    393            LTDC_Layerx->WVPCR  = (LTDC_Layer_InitStruct->LTDC_VerticalStart | wvsppos);
   \       0x2C   0x688B             LDR      R3,[R1, #+8]
   \       0x2E   0x431A             ORRS     R2,R2,R3
   \       0x30   0x6082             STR      R2,[R0, #+8]
    394          
    395            /* Specifies the pixel format */
    396            LTDC_Layerx->PFCR &= ~(LTDC_LxPFCR_PF);
   \       0x32   0x6902             LDR      R2,[R0, #+16]
   \       0x34   0x08D2             LSRS     R2,R2,#+3
   \       0x36   0x00D2             LSLS     R2,R2,#+3
   \       0x38   0x6102             STR      R2,[R0, #+16]
    397            LTDC_Layerx->PFCR = (LTDC_Layer_InitStruct->LTDC_PixelFormat);
   \       0x3A   0x690A             LDR      R2,[R1, #+16]
   \       0x3C   0x6102             STR      R2,[R0, #+16]
    398          
    399            /* Configures the default color values */
    400            dcgreen = (LTDC_Layer_InitStruct->LTDC_DefaultColorGreen << 8);
   \       0x3E   0x69CA             LDR      R2,[R1, #+28]
   \       0x40   0x0212             LSLS     R2,R2,#+8
    401            dcred = (LTDC_Layer_InitStruct->LTDC_DefaultColorRed << 16);
   \       0x42   0x6A0B             LDR      R3,[R1, #+32]
   \       0x44   0x041B             LSLS     R3,R3,#+16
    402            dcalpha = (LTDC_Layer_InitStruct->LTDC_DefaultColorAlpha << 24);
   \       0x46   0x6A4C             LDR      R4,[R1, #+36]
   \       0x48   0x0624             LSLS     R4,R4,#+24
    403            LTDC_Layerx->DCCR &=  ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
   \       0x4A   0x6985             LDR      R5,[R0, #+24]
   \       0x4C   0x2500             MOVS     R5,#+0
   \       0x4E   0x6185             STR      R5,[R0, #+24]
    404            LTDC_Layerx->DCCR = (LTDC_Layer_InitStruct->LTDC_DefaultColorBlue | dcgreen | \
    405                                  dcred | dcalpha);
   \       0x50   0x698D             LDR      R5,[R1, #+24]
   \       0x52   0x432A             ORRS     R2,R2,R5
   \       0x54   0x431A             ORRS     R2,R3,R2
   \       0x56   0x4322             ORRS     R2,R4,R2
   \       0x58   0x6182             STR      R2,[R0, #+24]
    406          
    407            /* Specifies the constant alpha value */      
    408            LTDC_Layerx->CACR &= ~(LTDC_LxCACR_CONSTA);
   \       0x5A   0x6942             LDR      R2,[R0, #+20]
   \       0x5C   0x0A12             LSRS     R2,R2,#+8
   \       0x5E   0x0212             LSLS     R2,R2,#+8
   \       0x60   0x6142             STR      R2,[R0, #+20]
    409            LTDC_Layerx->CACR = (LTDC_Layer_InitStruct->LTDC_ConstantAlpha);
   \       0x62   0x694A             LDR      R2,[R1, #+20]
   \       0x64   0x6142             STR      R2,[R0, #+20]
    410          
    411            /* Specifies the blending factors */
    412            LTDC_Layerx->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
   \       0x66   0x69C3             LDR      R3,[R0, #+28]
   \       0x68   0x....'....        LDR.W    R2,??DataTable17_10  ;; 0xfffff8f8
   \       0x6C   0x4013             ANDS     R3,R2,R3
   \       0x6E   0x61C3             STR      R3,[R0, #+28]
    413            LTDC_Layerx->BFCR = (LTDC_Layer_InitStruct->LTDC_BlendingFactor_1 | LTDC_Layer_InitStruct->LTDC_BlendingFactor_2);
   \       0x70   0x6A8B             LDR      R3,[R1, #+40]
   \       0x72   0x6ACA             LDR      R2,[R1, #+44]
   \       0x74   0x4313             ORRS     R3,R2,R3
   \       0x76   0x61C3             STR      R3,[R0, #+28]
    414          
    415            /* Configures the color frame buffer start address */
    416            LTDC_Layerx->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
   \       0x78   0x6A82             LDR      R2,[R0, #+40]
   \       0x7A   0x2200             MOVS     R2,#+0
   \       0x7C   0x6282             STR      R2,[R0, #+40]
    417            LTDC_Layerx->CFBAR = (LTDC_Layer_InitStruct->LTDC_CFBStartAdress);
   \       0x7E   0x6B0A             LDR      R2,[R1, #+48]
   \       0x80   0x6282             STR      R2,[R0, #+40]
    418          
    419            /* Configures the color frame buffer pitch in byte */
    420            cfbp = (LTDC_Layer_InitStruct->LTDC_CFBPitch << 16);
   \       0x82   0x6B8A             LDR      R2,[R1, #+56]
   \       0x84   0x0412             LSLS     R2,R2,#+16
    421            LTDC_Layerx->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
   \       0x86   0x6AC3             LDR      R3,[R0, #+44]
   \       0x88   0xF013 0x23E0      ANDS     R3,R3,#0xE000E000
   \       0x8C   0x62C3             STR      R3,[R0, #+44]
    422            LTDC_Layerx->CFBLR  = (LTDC_Layer_InitStruct->LTDC_CFBLineLength | cfbp);
   \       0x8E   0x6B4B             LDR      R3,[R1, #+52]
   \       0x90   0x431A             ORRS     R2,R2,R3
   \       0x92   0x62C2             STR      R2,[R0, #+44]
    423          
    424            /* Configures the frame buffer line number */
    425            LTDC_Layerx->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
   \       0x94   0x6B02             LDR      R2,[R0, #+48]
   \       0x96   0x0AD2             LSRS     R2,R2,#+11
   \       0x98   0x02D2             LSLS     R2,R2,#+11
   \       0x9A   0x6302             STR      R2,[R0, #+48]
    426            LTDC_Layerx->CFBLNR  = (LTDC_Layer_InitStruct->LTDC_CFBLineNumber);
   \       0x9C   0x6BC9             LDR      R1,[R1, #+60]
   \       0x9E   0x6301             STR      R1,[R0, #+48]
    427          
    428          }
   \       0xA0   0xBC30             POP      {R4,R5}
   \       0xA2   0x4770             BX       LR               ;; return
    429          
    430          /**
    431            * @brief  Fills each LTDC_Layer_InitStruct member with its default value.
    432            * @param  LTDC_Layer_InitStruct: pointer to a LTDC_LayerTypeDef structure which will
    433            *         be initialized.
    434            * @retval None
    435            */
    436          

   \                                 In section .text, align 2, keep-with-next
    437          void LTDC_LayerStructInit(LTDC_Layer_InitTypeDef * LTDC_Layer_InitStruct)
    438          {
    439            /*--------------- Reset Layer structure parameters values -------------------*/
    440          
    441            /*!< Initialize the horizontal limit member */
    442            LTDC_Layer_InitStruct->LTDC_HorizontalStart = 0x00;
   \                     LTDC_LayerStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    443            LTDC_Layer_InitStruct->LTDC_HorizontalStop = 0x00;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6041             STR      R1,[R0, #+4]
    444          
    445            /*!< Initialize the vertical limit member */
    446            LTDC_Layer_InitStruct->LTDC_VerticalStart = 0x00;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6081             STR      R1,[R0, #+8]
    447            LTDC_Layer_InitStruct->LTDC_VerticalStop = 0x00;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x60C1             STR      R1,[R0, #+12]
    448          
    449            /*!< Initialize the pixel format member */
    450            LTDC_Layer_InitStruct->LTDC_PixelFormat = LTDC_Pixelformat_ARGB8888;
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x6101             STR      R1,[R0, #+16]
    451          
    452            /*!< Initialize the constant alpha value */
    453            LTDC_Layer_InitStruct->LTDC_ConstantAlpha = 0xFF;
   \       0x14   0x21FF             MOVS     R1,#+255
   \       0x16   0x6141             STR      R1,[R0, #+20]
    454          
    455            /*!< Initialize the default color values */
    456            LTDC_Layer_InitStruct->LTDC_DefaultColorBlue = 0x00;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6181             STR      R1,[R0, #+24]
    457            LTDC_Layer_InitStruct->LTDC_DefaultColorGreen = 0x00;
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x61C1             STR      R1,[R0, #+28]
    458            LTDC_Layer_InitStruct->LTDC_DefaultColorRed = 0x00;
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6201             STR      R1,[R0, #+32]
    459            LTDC_Layer_InitStruct->LTDC_DefaultColorAlpha = 0x00;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x6241             STR      R1,[R0, #+36]
    460          
    461            /*!< Initialize the blending factors */
    462            LTDC_Layer_InitStruct->LTDC_BlendingFactor_1 = LTDC_BlendingFactor1_PAxCA;
   \       0x28   0xF44F 0x61C0      MOV      R1,#+1536
   \       0x2C   0x6281             STR      R1,[R0, #+40]
    463            LTDC_Layer_InitStruct->LTDC_BlendingFactor_2 = LTDC_BlendingFactor2_PAxCA;
   \       0x2E   0x2107             MOVS     R1,#+7
   \       0x30   0x62C1             STR      R1,[R0, #+44]
    464          
    465            /*!< Initialize the frame buffer start address */
    466            LTDC_Layer_InitStruct->LTDC_CFBStartAdress = 0x00;
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x6301             STR      R1,[R0, #+48]
    467          
    468            /*!< Initialize the frame buffer pitch and line length */
    469            LTDC_Layer_InitStruct->LTDC_CFBLineLength = 0x00;
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x6341             STR      R1,[R0, #+52]
    470            LTDC_Layer_InitStruct->LTDC_CFBPitch = 0x00;
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0x6381             STR      R1,[R0, #+56]
    471          
    472            /*!< Initialize the frame buffer line number */
    473            LTDC_Layer_InitStruct->LTDC_CFBLineNumber = 0x00;
   \       0x3E   0x2100             MOVS     R1,#+0
   \       0x40   0x63C1             STR      R1,[R0, #+60]
    474          }
   \       0x42   0x4770             BX       LR               ;; return
    475          
    476          
    477          /**
    478            * @brief  Enables or disables the LTDC_Layer Controller.
    479            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    480            *         one of the following values: LTDC_Layer1, LTDC_Layer2
    481            * @param  NewState: new state of the LTDC_Layer peripheral.
    482            *   This parameter can be: ENABLE or DISABLE.
    483            * @retval None
    484            */
    485          

   \                                 In section .text, align 2, keep-with-next
    486          void LTDC_LayerCmd(LTDC_Layer_TypeDef* LTDC_Layerx, FunctionalState NewState)
    487          {
    488            /* Check the parameters */
    489            assert_param(IS_FUNCTIONAL_STATE(NewState));
    490          
    491            if (NewState != DISABLE)
   \                     LTDC_LayerCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??LTDC_LayerCmd_0
    492            {
    493              /* Enable LTDC_Layer by setting LEN bit */
    494              LTDC_Layerx->CR |= (uint32_t)LTDC_LxCR_LEN;
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0xF051 0x0101      ORRS     R1,R1,#0x1
   \        0xC   0x6001             STR      R1,[R0, #+0]
   \        0xE   0xE003             B.N      ??LTDC_LayerCmd_1
    495            }
    496            else
    497            {
    498              /* Disable LTDC_Layer by clearing LEN bit */
    499              LTDC_Layerx->CR &= ~(uint32_t)LTDC_LxCR_LEN;
   \                     ??LTDC_LayerCmd_0: (+1)
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0x0849             LSRS     R1,R1,#+1
   \       0x14   0x0049             LSLS     R1,R1,#+1
   \       0x16   0x6001             STR      R1,[R0, #+0]
    500            }
    501          }
   \                     ??LTDC_LayerCmd_1: (+1)
   \       0x18   0x4770             BX       LR               ;; return
    502          
    503          
    504          /**
    505            * @brief  Get the current position.
    506            * @param  LTDC_Pos_InitStruct: pointer to a LTDC_PosTypeDef structure that contains
    507            *         the current position.
    508            * @retval None
    509            */
    510          

   \                                 In section .text, align 2, keep-with-next
    511          LTDC_PosTypeDef LTDC_GetPosStatus(void)
    512          {
   \                     LTDC_GetPosStatus: (+1)
   \        0x0   0xB410             PUSH     {R4}
    513            LTDC_PosTypeDef LTDC_Pos_InitStruct;
    514          
    515            LTDC->CPSR &= ~(LTDC_CPSR_CYPOS | LTDC_CPSR_CXPOS);
   \        0x2   0x....             LDR.N    R1,??DataTable17_11  ;; 0x40016844
   \        0x4   0x680C             LDR      R4,[R1, #+0]
   \        0x6   0x2400             MOVS     R4,#+0
   \        0x8   0x600C             STR      R4,[R1, #+0]
    516          
    517            LTDC_Pos_InitStruct.LTDC_POSX = (uint32_t)(LTDC->CPSR >> 16);
   \        0xA   0x680C             LDR      R4,[R1, #+0]
   \        0xC   0x0C24             LSRS     R4,R4,#+16
   \        0xE   0x0022             MOVS     R2,R4
    518            LTDC_Pos_InitStruct.LTDC_POSY = (uint32_t)(LTDC->CPSR & 0xFFFF);
   \       0x10   0x6809             LDR      R1,[R1, #+0]
   \       0x12   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \       0x14   0x000B             MOVS     R3,R1
    519          
    520            return LTDC_Pos_InitStruct;
   \       0x16   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   \       0x1A   0xBC10             POP      {R4}
   \       0x1C   0x4770             BX       LR               ;; return
    521          }
    522          
    523          /**
    524            * @brief  Fills each LTDC_Pos_InitStruct member with its default value.
    525            * @param  LTDC_Pos_InitStruct: pointer to a LTDC_PosTypeDef structure which will
    526            *         be initialized.
    527            * @retval None
    528            */
    529          

   \                                 In section .text, align 2, keep-with-next
    530          void LTDC_PosStructInit(LTDC_PosTypeDef* LTDC_Pos_InitStruct)
    531          {
    532            LTDC_Pos_InitStruct->LTDC_POSX = 0x00;
   \                     LTDC_PosStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    533            LTDC_Pos_InitStruct->LTDC_POSY = 0x00;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6041             STR      R1,[R0, #+4]
    534          }
   \        0x8   0x4770             BX       LR               ;; return
    535          
    536          /**
    537            * @brief  Checks whether the specified LTDC's flag is set or not.
    538            * @param  LTDC_CD: specifies the flag to check.
    539            *   This parameter can be one of the following values:
    540            *     @arg LTDC_CD_VDES: vertical data enable current status.
    541            *     @arg LTDC_CD_HDES: horizontal data enable current status.
    542            *     @arg LTDC_CD_VSYNC:  Vertical Synchronization current status.
    543            *     @arg LTDC_CD_HSYNC:  Horizontal Synchronization current status.
    544            * @retval The new state of LTDC_CD (SET or RESET).
    545            */
    546          

   \                                 In section .text, align 2, keep-with-next
    547          FlagStatus LTDC_GetCDStatus(uint32_t LTDC_CD)
    548          {
    549            FlagStatus bitstatus;
    550          
    551            /* Check the parameters */
    552            assert_param(IS_LTDC_GET_CD(LTDC_CD));
    553          
    554            if ((LTDC->CDSR & LTDC_CD) != (uint32_t)RESET)
   \                     LTDC_GetCDStatus: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable17_12  ;; 0x40016848
   \        0x2   0x6809             LDR      R1,[R1, #+0]
   \        0x4   0x4201             TST      R1,R0
   \        0x6   0xD001             BEQ.N    ??LTDC_GetCDStatus_0
    555            {
    556              bitstatus = SET;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE000             B.N      ??LTDC_GetCDStatus_1
    557            }
    558            else
    559            {
    560              bitstatus = RESET;
   \                     ??LTDC_GetCDStatus_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
    561            }
    562            return bitstatus;
   \                     ??LTDC_GetCDStatus_1: (+1)
   \        0xE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x10   0x4770             BX       LR               ;; return
    563          }
    564          
    565          /**
    566            * @brief  Set and configure the color keying.
    567            * @param  LTDC_colorkeying_InitStruct: pointer to a LTDC_ColorKeying_InitTypeDef 
    568            *         structure that contains the color keying configuration.
    569            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    570            *         one of the following values: LTDC_Layer1, LTDC_Layer2   
    571            * @retval None
    572            */
    573          

   \                                 In section .text, align 2, keep-with-next
    574          void LTDC_ColorKeyingConfig(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_ColorKeying_InitTypeDef* LTDC_colorkeying_InitStruct, FunctionalState NewState)
    575          { 
   \                     LTDC_ColorKeyingConfig: (+1)
   \        0x0   0xB410             PUSH     {R4}
    576            uint32_t ckgreen = 0;
   \        0x2   0x2300             MOVS     R3,#+0
    577            uint32_t ckred = 0;
   \        0x4   0x2300             MOVS     R3,#+0
    578          
    579            /* Check the parameters */
    580            assert_param(IS_FUNCTIONAL_STATE(NewState));
    581            assert_param(IS_LTDC_CKEYING(LTDC_colorkeying_InitStruct->LTDC_ColorKeyBlue));
    582            assert_param(IS_LTDC_CKEYING(LTDC_colorkeying_InitStruct->LTDC_ColorKeyGreen));
    583            assert_param(IS_LTDC_CKEYING(LTDC_colorkeying_InitStruct->LTDC_ColorKeyRed));
    584            
    585            if (NewState != DISABLE)
   \        0x6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \        0x8   0x2A00             CMP      R2,#+0
   \        0xA   0xD012             BEQ.N    ??LTDC_ColorKeyingConfig_0
    586            {
    587              /* Enable LTDC color keying by setting COLKEN bit */
    588              LTDC_Layerx->CR |= (uint32_t)LTDC_LxCR_COLKEN;
   \        0xC   0x6802             LDR      R2,[R0, #+0]
   \        0xE   0xF052 0x0202      ORRS     R2,R2,#0x2
   \       0x12   0x6002             STR      R2,[R0, #+0]
    589              
    590              /* Sets the color keying values */
    591              ckgreen = (LTDC_colorkeying_InitStruct->LTDC_ColorKeyGreen << 8);
   \       0x14   0x684A             LDR      R2,[R1, #+4]
   \       0x16   0x0212             LSLS     R2,R2,#+8
    592              ckred = (LTDC_colorkeying_InitStruct->LTDC_ColorKeyRed << 16);
   \       0x18   0x688B             LDR      R3,[R1, #+8]
   \       0x1A   0x041B             LSLS     R3,R3,#+16
    593              LTDC_Layerx->CKCR  &= ~(LTDC_LxCKCR_CKBLUE | LTDC_LxCKCR_CKGREEN | LTDC_LxCKCR_CKRED);
   \       0x1C   0x68C4             LDR      R4,[R0, #+12]
   \       0x1E   0xF014 0x447F      ANDS     R4,R4,#0xFF000000
   \       0x22   0x60C4             STR      R4,[R0, #+12]
    594              LTDC_Layerx->CKCR |= (LTDC_colorkeying_InitStruct->LTDC_ColorKeyBlue | ckgreen | ckred);
   \       0x24   0x68C4             LDR      R4,[R0, #+12]
   \       0x26   0x6809             LDR      R1,[R1, #+0]
   \       0x28   0x430A             ORRS     R2,R2,R1
   \       0x2A   0x431A             ORRS     R2,R3,R2
   \       0x2C   0x4322             ORRS     R2,R2,R4
   \       0x2E   0x60C2             STR      R2,[R0, #+12]
   \       0x30   0xE003             B.N      ??LTDC_ColorKeyingConfig_1
    595            }
    596            else
    597            {
    598              /* Disable LTDC color keying by clearing COLKEN bit */
    599              LTDC_Layerx->CR &= ~(uint32_t)LTDC_LxCR_COLKEN;
   \                     ??LTDC_ColorKeyingConfig_0: (+1)
   \       0x32   0x6801             LDR      R1,[R0, #+0]
   \       0x34   0xF031 0x0102      BICS     R1,R1,#0x2
   \       0x38   0x6001             STR      R1,[R0, #+0]
    600            }
    601            
    602            /* Reload shadow register */
    603            LTDC->SRCR = LTDC_IMReload;
   \                     ??LTDC_ColorKeyingConfig_1: (+1)
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0x....             LDR.N    R1,??DataTable17_9  ;; 0x40016824
   \       0x3E   0x6008             STR      R0,[R1, #+0]
    604          }
   \       0x40   0xBC10             POP      {R4}
   \       0x42   0x4770             BX       LR               ;; return
    605          
    606          /**
    607            * @brief  Fills each LTDC_colorkeying_InitStruct member with its default value.
    608            * @param  LTDC_colorkeying_InitStruct: pointer to a LTDC_ColorKeying_InitTypeDef structure which will
    609            *         be initialized.
    610            * @retval None
    611            */
    612          

   \                                 In section .text, align 2, keep-with-next
    613          void LTDC_ColorKeyingStructInit(LTDC_ColorKeying_InitTypeDef* LTDC_colorkeying_InitStruct)
    614          {
    615            /*!< Initialize the color keying values */
    616            LTDC_colorkeying_InitStruct->LTDC_ColorKeyBlue = 0x00;
   \                     LTDC_ColorKeyingStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    617            LTDC_colorkeying_InitStruct->LTDC_ColorKeyGreen = 0x00;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6041             STR      R1,[R0, #+4]
    618            LTDC_colorkeying_InitStruct->LTDC_ColorKeyRed = 0x00;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6081             STR      R1,[R0, #+8]
    619          }
   \        0xC   0x4770             BX       LR               ;; return
    620          
    621          
    622          /**
    623            * @brief  Enables or disables CLUT.
    624            * @param  NewState: new state of CLUT.
    625            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    626            *         one of the following values: LTDC_Layer1, LTDC_Layer2  
    627            *   This parameter can be: ENABLE or DISABLE.
    628            * @retval None
    629            */
    630          

   \                                 In section .text, align 2, keep-with-next
    631          void LTDC_CLUTCmd(LTDC_Layer_TypeDef* LTDC_Layerx, FunctionalState NewState)
    632          {
    633            /* Check the parameters */
    634            assert_param(IS_FUNCTIONAL_STATE(NewState));
    635          
    636            if (NewState != DISABLE)
   \                     LTDC_CLUTCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??LTDC_CLUTCmd_0
    637            {
    638              /* Enable CLUT by setting CLUTEN bit */
    639              LTDC_Layerx->CR |= (uint32_t)LTDC_LxCR_CLUTEN;
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0xF051 0x0110      ORRS     R1,R1,#0x10
   \        0xC   0x6001             STR      R1,[R0, #+0]
   \        0xE   0xE003             B.N      ??LTDC_CLUTCmd_1
    640            }
    641            else
    642            {
    643              /* Disable CLUT by clearing CLUTEN bit */
    644              LTDC_Layerx->CR &= ~(uint32_t)LTDC_LxCR_CLUTEN;
   \                     ??LTDC_CLUTCmd_0: (+1)
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0xF031 0x0110      BICS     R1,R1,#0x10
   \       0x16   0x6001             STR      R1,[R0, #+0]
    645            }
    646            
    647            /* Reload shadow register */
    648            LTDC->SRCR = LTDC_IMReload;
   \                     ??LTDC_CLUTCmd_1: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x....             LDR.N    R1,??DataTable17_9  ;; 0x40016824
   \       0x1C   0x6008             STR      R0,[R1, #+0]
    649          }
   \       0x1E   0x4770             BX       LR               ;; return
    650          
    651          /**
    652            * @brief  configure the CLUT.
    653            * @param  LTDC_CLUT_InitStruct: pointer to a LTDC_CLUT_InitTypeDef structure that contains
    654            *         the CLUT configuration.
    655            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    656            *         one of the following values: LTDC_Layer1, LTDC_Layer2   
    657            * @retval None
    658            */
    659          

   \                                 In section .text, align 2, keep-with-next
    660          void LTDC_CLUTInit(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_CLUT_InitTypeDef* LTDC_CLUT_InitStruct)
    661          {  
   \                     LTDC_CLUTInit: (+1)
   \        0x0   0xB410             PUSH     {R4}
    662            uint32_t green = 0;
   \        0x2   0x2200             MOVS     R2,#+0
    663            uint32_t red = 0;
   \        0x4   0x2200             MOVS     R2,#+0
    664            uint32_t clutadd = 0;
   \        0x6   0x2200             MOVS     R2,#+0
    665          
    666            /* Check the parameters */
    667            assert_param(IS_LTDC_CLUTWR(LTDC_CLUT_InitStruct->LTDC_CLUTAdress));
    668            assert_param(IS_LTDC_CLUTWR(LTDC_CLUT_InitStruct->LTDC_RedValue));
    669            assert_param(IS_LTDC_CLUTWR(LTDC_CLUT_InitStruct->LTDC_GreenValue));
    670            assert_param(IS_LTDC_CLUTWR(LTDC_CLUT_InitStruct->LTDC_BlueValue));
    671              
    672            /* Specifies the CLUT address and RGB value */
    673            green = (LTDC_CLUT_InitStruct->LTDC_GreenValue << 8);
   \        0x8   0x688A             LDR      R2,[R1, #+8]
   \        0xA   0x0212             LSLS     R2,R2,#+8
    674            red = (LTDC_CLUT_InitStruct->LTDC_RedValue << 16);
   \        0xC   0x68CB             LDR      R3,[R1, #+12]
   \        0xE   0x041B             LSLS     R3,R3,#+16
    675            clutadd = (LTDC_CLUT_InitStruct->LTDC_CLUTAdress << 24);
   \       0x10   0x680C             LDR      R4,[R1, #+0]
   \       0x12   0x0624             LSLS     R4,R4,#+24
    676            LTDC_Layerx->CLUTWR  = (clutadd | LTDC_CLUT_InitStruct->LTDC_BlueValue | \
    677                                        green | red);
   \       0x14   0x6849             LDR      R1,[R1, #+4]
   \       0x16   0x430C             ORRS     R4,R1,R4
   \       0x18   0x4322             ORRS     R2,R2,R4
   \       0x1A   0x431A             ORRS     R2,R3,R2
   \       0x1C   0x6402             STR      R2,[R0, #+64]
    678          }
   \       0x1E   0xBC10             POP      {R4}
   \       0x20   0x4770             BX       LR               ;; return
    679          
    680          /**
    681            * @brief  Fills each LTDC_CLUT_InitStruct member with its default value.
    682            * @param  LTDC_CLUT_InitStruct: pointer to a LTDC_CLUT_InitTypeDef structure which will
    683            *         be initialized.
    684            * @retval None
    685            */
    686          

   \                                 In section .text, align 2, keep-with-next
    687          void LTDC_CLUTStructInit(LTDC_CLUT_InitTypeDef* LTDC_CLUT_InitStruct)
    688          {
    689            /*!< Initialize the CLUT address and RGB values */
    690            LTDC_CLUT_InitStruct->LTDC_CLUTAdress = 0x00;
   \                     LTDC_CLUTStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    691            LTDC_CLUT_InitStruct->LTDC_BlueValue = 0x00;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6041             STR      R1,[R0, #+4]
    692            LTDC_CLUT_InitStruct->LTDC_GreenValue = 0x00;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6081             STR      R1,[R0, #+8]
    693            LTDC_CLUT_InitStruct->LTDC_RedValue = 0x00;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x60C1             STR      R1,[R0, #+12]
    694          }
   \       0x10   0x4770             BX       LR               ;; return
    695          
    696          
    697          /**
    698            * @brief  reconfigure the layer position.
    699            * @param  OffsetX: horizontal offset from start active width .
    700            * @param  OffsetY: vertical offset from start active height.   
    701            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    702            *         one of the following values: LTDC_Layer1, LTDC_Layer2   
    703            * @retval Reload of the shadow registers values must be applied after layer 
    704            *         position reconfiguration.
    705            */
    706          

   \                                 In section .text, align 2, keep-with-next
    707          void LTDC_LayerPosition(LTDC_Layer_TypeDef* LTDC_Layerx, uint16_t OffsetX, uint16_t OffsetY)
    708          {
   \                     LTDC_LayerPosition: (+1)
   \        0x0   0xB410             PUSH     {R4}
    709            
    710            uint32_t tempreg, temp;
    711            uint32_t horizontal_start;
    712            uint32_t horizontal_stop;
    713            uint32_t vertical_start;
    714            uint32_t vertical_stop;
    715            
    716            LTDC_Layerx->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
   \        0x2   0x6843             LDR      R3,[R0, #+4]
   \        0x4   0xF413 0x4370      ANDS     R3,R3,#0xF000
   \        0x8   0x6043             STR      R3,[R0, #+4]
    717            LTDC_Layerx->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
   \        0xA   0x6883             LDR      R3,[R0, #+8]
   \        0xC   0xF413 0x4370      ANDS     R3,R3,#0xF000
   \       0x10   0x6083             STR      R3,[R0, #+8]
    718            
    719            /* Reconfigures the horizontal and vertical start position */
    720            tempreg = LTDC->BPCR;
   \       0x12   0x....             LDR.N    R3,??DataTable17_2  ;; 0x4001680c
   \       0x14   0x681B             LDR      R3,[R3, #+0]
    721            horizontal_start = (tempreg >> 16) + 1 + OffsetX;
   \       0x16   0x001C             MOVS     R4,R3
   \       0x18   0x0C24             LSRS     R4,R4,#+16
   \       0x1A   0xFA14 0xF481      UXTAH    R4,R4,R1
   \       0x1E   0x1C64             ADDS     R4,R4,#+1
    722            vertical_start = (tempreg & 0xFFFF) + 1 + OffsetY;
   \       0x20   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \       0x22   0xFA13 0xF382      UXTAH    R3,R3,R2
   \       0x26   0x1C5B             ADDS     R3,R3,#+1
    723            
    724            /* Reconfigures the horizontal and vertical stop position */
    725            /* Get the number of byte per pixel */
    726            
    727            tempreg = LTDC_Layerx->PFCR;
   \       0x28   0x6901             LDR      R1,[R0, #+16]
    728            
    729            if (tempreg == LTDC_Pixelformat_ARGB8888)
   \       0x2A   0x2900             CMP      R1,#+0
   \       0x2C   0xD101             BNE.N    ??LTDC_LayerPosition_0
    730            {
    731              temp = 4;
   \       0x2E   0x2204             MOVS     R2,#+4
   \       0x30   0xE00E             B.N      ??LTDC_LayerPosition_1
    732            }
    733            else if (tempreg == LTDC_Pixelformat_RGB888)
   \                     ??LTDC_LayerPosition_0: (+1)
   \       0x32   0x2901             CMP      R1,#+1
   \       0x34   0xD101             BNE.N    ??LTDC_LayerPosition_2
    734            {
    735              temp = 3;
   \       0x36   0x2203             MOVS     R2,#+3
   \       0x38   0xE00A             B.N      ??LTDC_LayerPosition_1
    736            }
    737            else if ((tempreg == LTDC_Pixelformat_ARGB4444) || 
    738                    (tempreg == LTDC_Pixelformat_RGB565)    ||  
    739                    (tempreg == LTDC_Pixelformat_ARGB1555)  ||
    740                    (tempreg == LTDC_Pixelformat_AL88))
   \                     ??LTDC_LayerPosition_2: (+1)
   \       0x3A   0x2904             CMP      R1,#+4
   \       0x3C   0xD005             BEQ.N    ??LTDC_LayerPosition_3
   \       0x3E   0x2902             CMP      R1,#+2
   \       0x40   0xD003             BEQ.N    ??LTDC_LayerPosition_3
   \       0x42   0x2903             CMP      R1,#+3
   \       0x44   0xD001             BEQ.N    ??LTDC_LayerPosition_3
   \       0x46   0x2907             CMP      R1,#+7
   \       0x48   0xD101             BNE.N    ??LTDC_LayerPosition_4
    741            {
    742              temp = 2;  
   \                     ??LTDC_LayerPosition_3: (+1)
   \       0x4A   0x2202             MOVS     R2,#+2
   \       0x4C   0xE000             B.N      ??LTDC_LayerPosition_1
    743            }
    744            else
    745            {
    746              temp = 1;
   \                     ??LTDC_LayerPosition_4: (+1)
   \       0x4E   0x2201             MOVS     R2,#+1
    747            }  
    748              
    749            tempreg = LTDC_Layerx->CFBLR;
   \                     ??LTDC_LayerPosition_1: (+1)
   \       0x50   0x6AC1             LDR      R1,[R0, #+44]
    750            horizontal_stop = (((tempreg & 0x1FFF) - 3)/temp) + horizontal_start - 1;
   \       0x52   0x04C9             LSLS     R1,R1,#+19       ;; ZeroExtS R1,R1,#+19,#+19
   \       0x54   0x0CC9             LSRS     R1,R1,#+19
   \       0x56   0x1EC9             SUBS     R1,R1,#+3
   \       0x58   0xFBB1 0xF2F2      UDIV     R2,R1,R2
   \       0x5C   0x18A2             ADDS     R2,R4,R2
   \       0x5E   0x1E52             SUBS     R2,R2,#+1
    751            
    752            tempreg = LTDC_Layerx->CFBLNR;
   \       0x60   0x6B01             LDR      R1,[R0, #+48]
    753            vertical_stop = (tempreg & 0x7FF) + vertical_start - 1;  
   \       0x62   0x0549             LSLS     R1,R1,#+21       ;; ZeroExtS R1,R1,#+21,#+21
   \       0x64   0x0D49             LSRS     R1,R1,#+21
   \       0x66   0x1859             ADDS     R1,R3,R1
   \       0x68   0x1E49             SUBS     R1,R1,#+1
    754            
    755            LTDC_Layerx->WHPCR = horizontal_start | (horizontal_stop << 16);
   \       0x6A   0xEA54 0x4402      ORRS     R4,R4,R2, LSL #+16
   \       0x6E   0x6044             STR      R4,[R0, #+4]
    756            LTDC_Layerx->WVPCR = vertical_start | (vertical_stop << 16);  
   \       0x70   0xEA53 0x4301      ORRS     R3,R3,R1, LSL #+16
   \       0x74   0x6083             STR      R3,[R0, #+8]
    757          }
   \       0x76   0xBC10             POP      {R4}
   \       0x78   0x4770             BX       LR               ;; return
    758            
    759          /**
    760            * @brief  reconfigure constant alpha.
    761            * @param  ConstantAlpha: constant alpha value.
    762            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    763            *         one of the following values: LTDC_Layer1, LTDC_Layer2    
    764            * @retval Reload of the shadow registers values must be applied after constant 
    765            *         alpha reconfiguration.         
    766            */
    767          

   \                                 In section .text, align 2, keep-with-next
    768          void LTDC_LayerAlpha(LTDC_Layer_TypeDef* LTDC_Layerx, uint8_t ConstantAlpha)
    769          {  
    770            /* reconfigure the constant alpha value */      
    771            LTDC_Layerx->CACR = ConstantAlpha;
   \                     LTDC_LayerAlpha: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x6141             STR      R1,[R0, #+20]
    772          }
   \        0x4   0x4770             BX       LR               ;; return
    773          
    774          /**
    775            * @brief  reconfigure layer address.
    776            * @param  Address: The color frame buffer start address.
    777            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    778            *         one of the following values: LTDC_Layer1, LTDC_Layer2     
    779            * @retval Reload of the shadow registers values must be applied after layer 
    780            *         address reconfiguration.
    781            */
    782          

   \                                 In section .text, align 2, keep-with-next
    783          void LTDC_LayerAddress(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t Address)
    784          {
    785            /* Reconfigures the color frame buffer start address */
    786            LTDC_Layerx->CFBAR = Address;
   \                     LTDC_LayerAddress: (+1)
   \        0x0   0x6281             STR      R1,[R0, #+40]
    787          }
   \        0x2   0x4770             BX       LR               ;; return
    788            
    789          /**
    790            * @brief  reconfigure layer size.
    791            * @param  Width: layer window width.
    792            * @param  Height: layer window height.   
    793            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    794            *         one of the following values: LTDC_Layer1, LTDC_Layer2   
    795            * @retval Reload of the shadow registers values must be applied after layer 
    796            *         size reconfiguration.
    797            */
    798          

   \                                 In section .text, align 2, keep-with-next
    799          void LTDC_LayerSize(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t Width, uint32_t Height)
    800          {
   \                     LTDC_LayerSize: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
    801          
    802            uint8_t temp;
    803            uint32_t tempreg;
    804            uint32_t horizontal_start;
    805            uint32_t horizontal_stop;
    806            uint32_t vertical_start;
    807            uint32_t vertical_stop;  
    808            
    809            tempreg = LTDC_Layerx->PFCR;
   \        0x2   0x6903             LDR      R3,[R0, #+16]
    810            
    811            if (tempreg == LTDC_Pixelformat_ARGB8888)
   \        0x4   0x2B00             CMP      R3,#+0
   \        0x6   0xD101             BNE.N    ??LTDC_LayerSize_0
    812            {
    813              temp = 4;
   \        0x8   0x2304             MOVS     R3,#+4
   \        0xA   0xE00E             B.N      ??LTDC_LayerSize_1
    814            }
    815            else if (tempreg == LTDC_Pixelformat_RGB888)
   \                     ??LTDC_LayerSize_0: (+1)
   \        0xC   0x2B01             CMP      R3,#+1
   \        0xE   0xD101             BNE.N    ??LTDC_LayerSize_2
    816            {
    817              temp = 3;
   \       0x10   0x2303             MOVS     R3,#+3
   \       0x12   0xE00A             B.N      ??LTDC_LayerSize_1
    818            }
    819            else if ((tempreg == LTDC_Pixelformat_ARGB4444) || \
    820                    (tempreg == LTDC_Pixelformat_RGB565)    || \
    821                    (tempreg == LTDC_Pixelformat_ARGB1555)  || \
    822                    (tempreg == LTDC_Pixelformat_AL88))
   \                     ??LTDC_LayerSize_2: (+1)
   \       0x14   0x2B04             CMP      R3,#+4
   \       0x16   0xD005             BEQ.N    ??LTDC_LayerSize_3
   \       0x18   0x2B02             CMP      R3,#+2
   \       0x1A   0xD003             BEQ.N    ??LTDC_LayerSize_3
   \       0x1C   0x2B03             CMP      R3,#+3
   \       0x1E   0xD001             BEQ.N    ??LTDC_LayerSize_3
   \       0x20   0x2B07             CMP      R3,#+7
   \       0x22   0xD101             BNE.N    ??LTDC_LayerSize_4
    823            {
    824              temp = 2;  
   \                     ??LTDC_LayerSize_3: (+1)
   \       0x24   0x2302             MOVS     R3,#+2
   \       0x26   0xE000             B.N      ??LTDC_LayerSize_1
    825            }
    826            else
    827            {
    828              temp = 1;
   \                     ??LTDC_LayerSize_4: (+1)
   \       0x28   0x2301             MOVS     R3,#+1
    829            }
    830          
    831            /* update horizontal and vertical stop */
    832            tempreg = LTDC_Layerx->WHPCR;
   \                     ??LTDC_LayerSize_1: (+1)
   \       0x2A   0x6844             LDR      R4,[R0, #+4]
    833            horizontal_start = (tempreg & 0x1FFF);
   \       0x2C   0x04E4             LSLS     R4,R4,#+19       ;; ZeroExtS R4,R4,#+19,#+19
   \       0x2E   0x0CE4             LSRS     R4,R4,#+19
    834            horizontal_stop = Width + horizontal_start - 1;  
   \       0x30   0x1866             ADDS     R6,R4,R1
   \       0x32   0x1E76             SUBS     R6,R6,#+1
    835          
    836            tempreg = LTDC_Layerx->WVPCR;
   \       0x34   0x6885             LDR      R5,[R0, #+8]
    837            vertical_start = (tempreg & 0x1FFF);
   \       0x36   0x04ED             LSLS     R5,R5,#+19       ;; ZeroExtS R5,R5,#+19,#+19
   \       0x38   0x0CED             LSRS     R5,R5,#+19
    838            vertical_stop = Height + vertical_start - 1;  
   \       0x3A   0x18AF             ADDS     R7,R5,R2
   \       0x3C   0x1E7F             SUBS     R7,R7,#+1
    839            
    840            LTDC_Layerx->WHPCR = horizontal_start | (horizontal_stop << 16);
   \       0x3E   0xEA54 0x4406      ORRS     R4,R4,R6, LSL #+16
   \       0x42   0x6044             STR      R4,[R0, #+4]
    841            LTDC_Layerx->WVPCR = vertical_start | (vertical_stop << 16);  
   \       0x44   0xEA55 0x4507      ORRS     R5,R5,R7, LSL #+16
   \       0x48   0x6085             STR      R5,[R0, #+8]
    842          
    843            /* Reconfigures the color frame buffer pitch in byte */
    844            LTDC_Layerx->CFBLR  = ((Width * temp) << 16) | ((Width * temp) + 3);  
   \       0x4A   0x001C             MOVS     R4,R3
   \       0x4C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x4E   0xFB04 0xF401      MUL      R4,R4,R1
   \       0x52   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x54   0x4359             MULS     R1,R3,R1
   \       0x56   0x1CC9             ADDS     R1,R1,#+3
   \       0x58   0xEA51 0x4104      ORRS     R1,R1,R4, LSL #+16
   \       0x5C   0x62C1             STR      R1,[R0, #+44]
    845          
    846            /* Reconfigures the frame buffer line number */
    847            LTDC_Layerx->CFBLNR  = Height;  
   \       0x5E   0x6302             STR      R2,[R0, #+48]
    848            
    849          }
   \       0x60   0xBCF0             POP      {R4-R7}
   \       0x62   0x4770             BX       LR               ;; return
    850          
    851          /**
    852            * @brief  reconfigure layer pixel format.
    853            * @param  PixelFormat: reconfigure the pixel format, this parameter can be 
    854            *         one of the following values:@ref LTDC_Pixelformat.   
    855            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    856            *         one of the following values: LTDC_Layer1, LTDC_Layer2   
    857            * @retval Reload of the shadow registers values must be applied after layer 
    858            *         pixel format reconfiguration.
    859            */
    860          

   \                                 In section .text, align 2, keep-with-next
    861          void LTDC_LayerPixelFormat(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t PixelFormat)
    862          {
   \                     LTDC_LayerPixelFormat: (+1)
   \        0x0   0xB410             PUSH     {R4}
    863          
    864            uint8_t temp;
    865            uint32_t tempreg;
    866            
    867            tempreg = LTDC_Layerx->PFCR;
   \        0x2   0x6902             LDR      R2,[R0, #+16]
    868            
    869            if (tempreg == LTDC_Pixelformat_ARGB8888)
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD101             BNE.N    ??LTDC_LayerPixelFormat_0
    870            {
    871              temp = 4;
   \        0x8   0x2204             MOVS     R2,#+4
   \        0xA   0xE00E             B.N      ??LTDC_LayerPixelFormat_1
    872            }
    873            else if (tempreg == LTDC_Pixelformat_RGB888)
   \                     ??LTDC_LayerPixelFormat_0: (+1)
   \        0xC   0x2A01             CMP      R2,#+1
   \        0xE   0xD101             BNE.N    ??LTDC_LayerPixelFormat_2
    874            {
    875              temp = 3;
   \       0x10   0x2203             MOVS     R2,#+3
   \       0x12   0xE00A             B.N      ??LTDC_LayerPixelFormat_1
    876            }
    877            else if ((tempreg == LTDC_Pixelformat_ARGB4444) || \
    878                    (tempreg == LTDC_Pixelformat_RGB565)    || \
    879                    (tempreg == LTDC_Pixelformat_ARGB1555)  || \
    880                    (tempreg == LTDC_Pixelformat_AL88))  
   \                     ??LTDC_LayerPixelFormat_2: (+1)
   \       0x14   0x2A04             CMP      R2,#+4
   \       0x16   0xD005             BEQ.N    ??LTDC_LayerPixelFormat_3
   \       0x18   0x2A02             CMP      R2,#+2
   \       0x1A   0xD003             BEQ.N    ??LTDC_LayerPixelFormat_3
   \       0x1C   0x2A03             CMP      R2,#+3
   \       0x1E   0xD001             BEQ.N    ??LTDC_LayerPixelFormat_3
   \       0x20   0x2A07             CMP      R2,#+7
   \       0x22   0xD101             BNE.N    ??LTDC_LayerPixelFormat_4
    881            {
    882              temp = 2;  
   \                     ??LTDC_LayerPixelFormat_3: (+1)
   \       0x24   0x2202             MOVS     R2,#+2
   \       0x26   0xE000             B.N      ??LTDC_LayerPixelFormat_1
    883            }
    884            else
    885            {
    886              temp = 1;
   \                     ??LTDC_LayerPixelFormat_4: (+1)
   \       0x28   0x2201             MOVS     R2,#+1
    887            }
    888            
    889            tempreg = (LTDC_Layerx->CFBLR >> 16);
   \                     ??LTDC_LayerPixelFormat_1: (+1)
   \       0x2A   0x6AC3             LDR      R3,[R0, #+44]
   \       0x2C   0x0C1B             LSRS     R3,R3,#+16
    890            tempreg = (tempreg / temp); 
   \       0x2E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x30   0xFBB3 0xF3F2      UDIV     R3,R3,R2
    891            
    892            if (PixelFormat == LTDC_Pixelformat_ARGB8888)
   \       0x34   0x2900             CMP      R1,#+0
   \       0x36   0xD101             BNE.N    ??LTDC_LayerPixelFormat_5
    893            {
    894              temp = 4;
   \       0x38   0x2204             MOVS     R2,#+4
   \       0x3A   0xE00E             B.N      ??LTDC_LayerPixelFormat_6
    895            }
    896            else if (PixelFormat == LTDC_Pixelformat_RGB888)
   \                     ??LTDC_LayerPixelFormat_5: (+1)
   \       0x3C   0x2901             CMP      R1,#+1
   \       0x3E   0xD101             BNE.N    ??LTDC_LayerPixelFormat_7
    897            {
    898              temp = 3;
   \       0x40   0x2203             MOVS     R2,#+3
   \       0x42   0xE00A             B.N      ??LTDC_LayerPixelFormat_6
    899            }
    900            else if ((PixelFormat == LTDC_Pixelformat_ARGB4444) || \
    901                    (PixelFormat == LTDC_Pixelformat_RGB565)    || \
    902                    (PixelFormat == LTDC_Pixelformat_ARGB1555)  || \
    903                    (PixelFormat == LTDC_Pixelformat_AL88))
   \                     ??LTDC_LayerPixelFormat_7: (+1)
   \       0x44   0x2904             CMP      R1,#+4
   \       0x46   0xD005             BEQ.N    ??LTDC_LayerPixelFormat_8
   \       0x48   0x2902             CMP      R1,#+2
   \       0x4A   0xD003             BEQ.N    ??LTDC_LayerPixelFormat_8
   \       0x4C   0x2903             CMP      R1,#+3
   \       0x4E   0xD001             BEQ.N    ??LTDC_LayerPixelFormat_8
   \       0x50   0x2907             CMP      R1,#+7
   \       0x52   0xD101             BNE.N    ??LTDC_LayerPixelFormat_9
    904            {
    905              temp = 2;  
   \                     ??LTDC_LayerPixelFormat_8: (+1)
   \       0x54   0x2202             MOVS     R2,#+2
   \       0x56   0xE000             B.N      ??LTDC_LayerPixelFormat_6
    906            }
    907            else
    908            {
    909              temp = 1;
   \                     ??LTDC_LayerPixelFormat_9: (+1)
   \       0x58   0x2201             MOVS     R2,#+1
    910            }
    911            
    912            /* Reconfigures the color frame buffer pitch in byte */
    913            LTDC_Layerx->CFBLR  = ((tempreg * temp) << 16) | ((tempreg * temp) + 3);  
   \                     ??LTDC_LayerPixelFormat_6: (+1)
   \       0x5A   0x0014             MOVS     R4,R2
   \       0x5C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x5E   0xFB04 0xF403      MUL      R4,R4,R3
   \       0x62   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x64   0xFB02 0xF203      MUL      R2,R2,R3
   \       0x68   0x1CD2             ADDS     R2,R2,#+3
   \       0x6A   0xEA52 0x4204      ORRS     R2,R2,R4, LSL #+16
   \       0x6E   0x62C2             STR      R2,[R0, #+44]
    914          
    915            /* Reconfigures the color frame buffer start address */
    916            LTDC_Layerx->PFCR = PixelFormat;
   \       0x70   0x6101             STR      R1,[R0, #+16]
    917              
    918          }
   \       0x72   0xBC10             POP      {R4}
   \       0x74   0x4770             BX       LR               ;; return
    919              
    920          /**
    921            * @}
    922            */
    923          
    924          /** @defgroup LTDC_Group2 Interrupts and flags management functions
    925           *  @brief   Interrupts and flags management functions
    926           *
    927          @verbatim
    928           ===============================================================================
    929                      ##### Interrupts and flags management functions #####
    930           ===============================================================================
    931          
    932              [..] This section provides functions allowing to configure the LTDC Interrupts 
    933                   and to get the status and clear flags and Interrupts pending bits.
    934            
    935              [..] The LTDC provides 4 Interrupts sources and 4 Flags
    936              
    937              *** Flags ***
    938              =============
    939              [..]
    940                (+) LTDC_FLAG_LI:   Line Interrupt flag.
    941                (+) LTDC_FLAG_FU:   FIFO Underrun Interrupt flag.
    942                (+) LTDC_FLAG_TERR: Transfer Error Interrupt flag.
    943                (+) LTDC_FLAG_RR:   Register Reload interrupt flag.
    944                
    945              *** Interrupts ***
    946              ==================
    947              [..]
    948                (+) LTDC_IT_LI: Line Interrupt is generated when a programmed line 
    949                                is reached. The line interrupt position is programmed in 
    950                                the LTDC_LIPR register.
    951                (+) LTDC_IT_FU: FIFO Underrun interrupt is generated when a pixel is requested 
    952                                from an empty layer FIFO
    953                (+) LTDC_IT_TERR: Transfer Error interrupt is generated when an AHB bus 
    954                                  error occurs during data transfer.
    955                (+) LTDC_IT_RR: Register Reload interrupt is generated when the shadow 
    956                                registers reload was performed during the vertical blanking 
    957                                period.
    958                         
    959          @endverbatim
    960            * @{
    961            */
    962          
    963          /**
    964            * @brief  Enables or disables the specified LTDC's interrupts.
    965            * @param  LTDC_IT: specifies the LTDC interrupts sources to be enabled or disabled.
    966            *   This parameter can be any combination of the following values:
    967            *     @arg LTDC_IT_LI: Line Interrupt Enable.
    968            *     @arg LTDC_IT_FU: FIFO Underrun Interrupt Enable.
    969            *     @arg LTDC_IT_TERR: Transfer Error Interrupt Enable.
    970            *     @arg LTDC_IT_RR: Register Reload interrupt enable.  
    971            * @param NewState: new state of the specified LTDC interrupts.
    972            *   This parameter can be: ENABLE or DISABLE.
    973            * @retval None
    974            */

   \                                 In section .text, align 2, keep-with-next
    975          void LTDC_ITConfig(uint32_t LTDC_IT, FunctionalState NewState)
    976          {
    977            /* Check the parameters */
    978            assert_param(IS_LTDC_IT(LTDC_IT));
    979            assert_param(IS_FUNCTIONAL_STATE(NewState));
    980          
    981            if (NewState != DISABLE)
   \                     LTDC_ITConfig: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??LTDC_ITConfig_0
    982            {
    983              LTDC->IER |= LTDC_IT;
   \        0x6   0x....             LDR.N    R1,??DataTable17_13  ;; 0x40016834
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0x4310             ORRS     R0,R0,R2
   \        0xC   0x6008             STR      R0,[R1, #+0]
   \        0xE   0xE004             B.N      ??LTDC_ITConfig_1
    984            }
    985            else
    986            {
    987              LTDC->IER &= (uint32_t)~LTDC_IT;
   \                     ??LTDC_ITConfig_0: (+1)
   \       0x10   0x....             LDR.N    R1,??DataTable17_13  ;; 0x40016834
   \       0x12   0x680A             LDR      R2,[R1, #+0]
   \       0x14   0xEA32 0x0000      BICS     R0,R2,R0
   \       0x18   0x6008             STR      R0,[R1, #+0]
    988            }
    989          }
   \                     ??LTDC_ITConfig_1: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
    990          
    991          /**
    992            * @brief  Checks whether the specified LTDC's flag is set or not.
    993            * @param  LTDC_FLAG: specifies the flag to check.
    994            *   This parameter can be one of the following values:
    995            *     @arg LTDC_FLAG_LI:    Line Interrupt flag.
    996            *     @arg LTDC_FLAG_FU:   FIFO Underrun Interrupt flag.
    997            *     @arg LTDC_FLAG_TERR: Transfer Error Interrupt flag.
    998            *     @arg LTDC_FLAG_RR:   Register Reload interrupt flag.
    999            * @retval The new state of LTDC_FLAG (SET or RESET).
   1000            */

   \                                 In section .text, align 2, keep-with-next
   1001          FlagStatus LTDC_GetFlagStatus(uint32_t LTDC_FLAG)
   1002          {
   1003            FlagStatus bitstatus = RESET;
   \                     LTDC_GetFlagStatus: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   1004          
   1005            /* Check the parameters */
   1006            assert_param(IS_LTDC_FLAG(LTDC_FLAG));
   1007          
   1008            if ((LTDC->ISR & LTDC_FLAG) != (uint32_t)RESET)
   \        0x2   0x....             LDR.N    R1,??DataTable17_14  ;; 0x40016838
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0x4201             TST      R1,R0
   \        0x8   0xD001             BEQ.N    ??LTDC_GetFlagStatus_0
   1009            {
   1010              bitstatus = SET;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??LTDC_GetFlagStatus_1
   1011            }
   1012            else
   1013            {
   1014              bitstatus = RESET;
   \                     ??LTDC_GetFlagStatus_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   1015            }
   1016            return bitstatus;
   \                     ??LTDC_GetFlagStatus_1: (+1)
   \       0x10   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x12   0x4770             BX       LR               ;; return
   1017          }
   1018          
   1019          /**
   1020            * @brief  Clears the LTDC's pending flags.
   1021            * @param  LTDC_FLAG: specifies the flag to clear.
   1022            *   This parameter can be any combination of the following values:
   1023            *     @arg LTDC_FLAG_LI:    Line Interrupt flag.
   1024            *     @arg LTDC_FLAG_FU:   FIFO Underrun Interrupt flag.
   1025            *     @arg LTDC_FLAG_TERR: Transfer Error Interrupt flag.
   1026            *     @arg LTDC_FLAG_RR:   Register Reload interrupt flag.  
   1027            * @retval None
   1028            */

   \                                 In section .text, align 2, keep-with-next
   1029          void LTDC_ClearFlag(uint32_t LTDC_FLAG)
   1030          {
   1031            /* Check the parameters */
   1032            assert_param(IS_LTDC_FLAG(LTDC_FLAG));
   1033          
   1034            /* Clear the corresponding LTDC flag */
   1035            LTDC->ICR = (uint32_t)LTDC_FLAG;
   \                     LTDC_ClearFlag: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable17_15  ;; 0x4001683c
   \        0x2   0x6008             STR      R0,[R1, #+0]
   1036          }
   \        0x4   0x4770             BX       LR               ;; return
   1037          
   1038          /**
   1039            * @brief  Checks whether the specified LTDC's interrupt has occurred or not.
   1040            * @param  LTDC_IT: specifies the LTDC interrupts sources to check.
   1041            *   This parameter can be one of the following values:
   1042            *     @arg LTDC_IT_LI:    Line Interrupt Enable.
   1043            *     @arg LTDC_IT_FU:   FIFO Underrun Interrupt Enable.
   1044            *     @arg LTDC_IT_TERR: Transfer Error Interrupt Enable.
   1045            *     @arg LTDC_IT_RR:   Register Reload interrupt Enable.
   1046            * @retval The new state of the LTDC_IT (SET or RESET).
   1047            */

   \                                 In section .text, align 2, keep-with-next
   1048          ITStatus LTDC_GetITStatus(uint32_t LTDC_IT)
   1049          {
   1050            ITStatus bitstatus = RESET;
   \                     LTDC_GetITStatus: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   1051          
   1052            /* Check the parameters */
   1053            assert_param(IS_LTDC_IT(LTDC_IT));
   1054          
   1055            if ((LTDC->ISR & LTDC_IT) != (uint32_t)RESET)
   \        0x2   0x....             LDR.N    R1,??DataTable17_14  ;; 0x40016838
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0x4201             TST      R1,R0
   \        0x8   0xD001             BEQ.N    ??LTDC_GetITStatus_0
   1056            {
   1057              bitstatus = SET;
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0xE000             B.N      ??LTDC_GetITStatus_1
   1058            }
   1059            else
   1060            {
   1061              bitstatus = RESET;
   \                     ??LTDC_GetITStatus_0: (+1)
   \        0xE   0x2100             MOVS     R1,#+0
   1062            }
   1063          
   1064            if (((LTDC->IER & LTDC_IT) != (uint32_t)RESET) && (bitstatus != (uint32_t)RESET))
   \                     ??LTDC_GetITStatus_1: (+1)
   \       0x10   0x....             LDR.N    R2,??DataTable17_13  ;; 0x40016834
   \       0x12   0x6812             LDR      R2,[R2, #+0]
   \       0x14   0x4202             TST      R2,R0
   \       0x16   0xD004             BEQ.N    ??LTDC_GetITStatus_2
   \       0x18   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x1A   0x2900             CMP      R1,#+0
   \       0x1C   0xD001             BEQ.N    ??LTDC_GetITStatus_2
   1065            {
   1066              bitstatus = SET;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xE000             B.N      ??LTDC_GetITStatus_3
   1067            }
   1068            else
   1069            {
   1070              bitstatus = RESET;
   \                     ??LTDC_GetITStatus_2: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   1071            }
   1072            return bitstatus;
   \                     ??LTDC_GetITStatus_3: (+1)
   \       0x24   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x26   0x4770             BX       LR               ;; return
   1073          }
   1074          
   1075          
   1076          /**
   1077            * @brief  Clears the LTDC's interrupt pending bits.
   1078            * @param  LTDC_IT: specifies the interrupt pending bit to clear.
   1079            *   This parameter can be any combination of the following values:
   1080            *     @arg LTDC_IT_LIE:    Line Interrupt.
   1081            *     @arg LTDC_IT_FUIE:   FIFO Underrun Interrupt.
   1082            *     @arg LTDC_IT_TERRIE: Transfer Error Interrupt.
   1083            *     @arg LTDC_IT_RRIE:   Register Reload interrupt.
   1084            * @retval None
   1085            */

   \                                 In section .text, align 2, keep-with-next
   1086          void LTDC_ClearITPendingBit(uint32_t LTDC_IT)
   1087          {
   1088            /* Check the parameters */
   1089            assert_param(IS_LTDC_IT(LTDC_IT));
   1090          
   1091            /* Clear the corresponding LTDC Interrupt */
   1092            LTDC->ICR = (uint32_t)LTDC_IT;
   \                     LTDC_ClearITPendingBit: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable17_15  ;; 0x4001683c
   \        0x2   0x6008             STR      R0,[R1, #+0]
   1093          }
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0xF000'F800        DC32     0xf000f800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0x4001'6808        DC32     0x40016808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \        0x0   0x4001'680C        DC32     0x4001680c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \        0x0   0x4001'6810        DC32     0x40016810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \        0x0   0x4001'6814        DC32     0x40016814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \        0x0   0x4001'6818        DC32     0x40016818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \        0x0   0x0FFE'888F        DC32     0xffe888f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \        0x0   0x4001'682C        DC32     0x4001682c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \        0x0   0x4001'6840        DC32     0x40016840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \        0x0   0x4001'6824        DC32     0x40016824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \        0x0   0xFFFF'F8F8        DC32     0xfffff8f8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \        0x0   0x4001'6844        DC32     0x40016844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \        0x0   0x4001'6848        DC32     0x40016848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \        0x0   0x4001'6834        DC32     0x40016834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \        0x0   0x4001'6838        DC32     0x40016838

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \        0x0   0x4001'683C        DC32     0x4001683c
   1094          /**
   1095            * @}
   1096            */
   1097          
   1098          /**
   1099            * @}
   1100            */ 
   1101          
   1102          /**
   1103            * @}
   1104            */ 
   1105          
   1106          /**
   1107            * @}
   1108            */ 
   1109          
   1110          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   LTDC_CLUTCmd
       4   LTDC_CLUTInit
       0   LTDC_CLUTStructInit
       0   LTDC_ClearFlag
       0   LTDC_ClearITPendingBit
       0   LTDC_Cmd
       4   LTDC_ColorKeyingConfig
       0   LTDC_ColorKeyingStructInit
       8   LTDC_DeInit
         8   -> RCC_APB2PeriphResetCmd
       0   LTDC_DitherCmd
       0   LTDC_GetCDStatus
       0   LTDC_GetFlagStatus
       0   LTDC_GetITStatus
       4   LTDC_GetPosStatus
      16   LTDC_GetRGBWidth
       0   LTDC_ITConfig
       8   LTDC_Init
       0   LTDC_LIPConfig
       0   LTDC_LayerAddress
       0   LTDC_LayerAlpha
       0   LTDC_LayerCmd
       8   LTDC_LayerInit
       4   LTDC_LayerPixelFormat
       4   LTDC_LayerPosition
      16   LTDC_LayerSize
       0   LTDC_LayerStructInit
       0   LTDC_PosStructInit
       0   LTDC_RGBStructInit
       0   LTDC_ReloadConfig
       0   LTDC_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
      32  LTDC_CLUTCmd
      34  LTDC_CLUTInit
      18  LTDC_CLUTStructInit
       6  LTDC_ClearFlag
       6  LTDC_ClearITPendingBit
      34  LTDC_Cmd
      68  LTDC_ColorKeyingConfig
      14  LTDC_ColorKeyingStructInit
      24  LTDC_DeInit
      34  LTDC_DitherCmd
      18  LTDC_GetCDStatus
      20  LTDC_GetFlagStatus
      40  LTDC_GetITStatus
      30  LTDC_GetPosStatus
      54  LTDC_GetRGBWidth
      28  LTDC_ITConfig
     184  LTDC_Init
       8  LTDC_LIPConfig
       4  LTDC_LayerAddress
       6  LTDC_LayerAlpha
      26  LTDC_LayerCmd
     164  LTDC_LayerInit
     118  LTDC_LayerPixelFormat
     122  LTDC_LayerPosition
     100  LTDC_LayerSize
      68  LTDC_LayerStructInit
      10  LTDC_PosStructInit
      14  LTDC_RGBStructInit
       8  LTDC_ReloadConfig
      62  LTDC_StructInit

 
 1'418 bytes in section .text
 
 1'418 bytes of CODE memory

Errors: none
Warnings: none
