###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.2.214/W32 for ARM         26/Apr/2021  17:53:44
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  E:\STM32Project\Cubli-with-STM32F429\Cubli\User\src\pwm.c
#    Command line =
#        -f C:\Users\LABPC1~1\AppData\Local\Temp\EW50A0.tmp
#        (E:\STM32Project\Cubli-with-STM32F429\Cubli\User\src\pwm.c -D
#        USE_STDPERIPH_DRIVER -D STM32F429_439xx -lC
#        E:\STM32Project\Cubli-with-STM32F429\Cubli\Debug\List -o
#        E:\STM32Project\Cubli-with-STM32F429\Cubli\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "D:\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        E:\STM32Project\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        E:\STM32Project\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\
#        -I
#        E:\STM32Project\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\iar\
#        -I
#        E:\STM32Project\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        E:\STM32Project\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\
#        -I E:\STM32Project\Cubli-with-STM32F429\Cubli\user\inc\ -I
#        E:\STM32Project\Cubli-with-STM32F429\Cubli\user\src\ -Ol
#        --use_c++_inline -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        E:\STM32Project\Cubli-with-STM32F429\Cubli\Debug\List\pwm.lst
#    Object file  =  E:\STM32Project\Cubli-with-STM32F429\Cubli\Debug\Obj\pwm.o
#
###############################################################################

E:\STM32Project\Cubli-with-STM32F429\Cubli\User\src\pwm.c
      1          #include "pwm.h"
      2          /*=========================================================
      3          
      4          
      5          TIM1 pwm PA8、PA9、PA10、PA11
      6          
      7          =========================================================*/
      8          

   \                                 In section .text, align 2, keep-with-next
      9          void TM1_PWM_Init(void){
   \                     TM1_PWM_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB08A             SUB      SP,SP,#+40
     10              GPIO_InitTypeDef GPIO_InitStruct;
     11              RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x....'....        BL       RCC_AHB1PeriphClockCmd
     12              /* Alternating functions for pins 原本在PB*/
     13              GPIO_PinAFConfig(GPIOA, GPIO_PinSource8, GPIO_AF_TIM1);  // chl_1
   \        0xC   0x....'....        LDR.W    R4,??DataTable6  ;; 0x40020000
   \       0x10   0x2201             MOVS     R2,#+1
   \       0x12   0x2108             MOVS     R1,#+8
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x....'....        BL       GPIO_PinAFConfig
     14              GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_TIM1);  // chl_2
   \       0x1A   0x2201             MOVS     R2,#+1
   \       0x1C   0x2109             MOVS     R1,#+9
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x....'....        BL       GPIO_PinAFConfig
     15              GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_TIM1);  // chl_3
   \       0x24   0x2201             MOVS     R2,#+1
   \       0x26   0x210A             MOVS     R1,#+10
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x....'....        BL       GPIO_PinAFConfig
     16          //    GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_TIM1);  // chl_4
     17              
     18              GPIO_InitStruct.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10;// | GPIO_Pin_11;
   \       0x2E   0xF44F 0x60E0      MOV      R0,#+1792
   \       0x32   0x9000             STR      R0,[SP, #+0]
     19              GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF88D 0x0006      STRB     R0,[SP, #+6]
     20              GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xF88D 0x0007      STRB     R0,[SP, #+7]
     21              GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
   \       0x40   0x2002             MOVS     R0,#+2
   \       0x42   0xF88D 0x0004      STRB     R0,[SP, #+4]
     22              GPIO_InitStruct.GPIO_Speed = GPIO_Speed_100MHz;
   \       0x46   0x2003             MOVS     R0,#+3
   \       0x48   0xF88D 0x0005      STRB     R0,[SP, #+5]
     23              GPIO_Init(GPIOA, &GPIO_InitStruct);
   \       0x4C   0x4669             MOV      R1,SP
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x....'....        BL       GPIO_Init
     24              //Initialize TIM1
     25              TIM_TimeBaseInitTypeDef TIM_BaseStruct;
     26              RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
   \       0x54   0x2101             MOVS     R1,#+1
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0x....'....        BL       RCC_APB2PeriphClockCmd
     27              TIM_BaseStruct.TIM_Period=20000-1;//PWM_frequency = timer_tick_frequency / (TIM_Period + 1) ==> TIM_Period = timer_tick_frequency / PWM_frequency - 1
   \       0x5C   0xF644 0x601F      MOVW     R0,#+19999
   \       0x60   0x9008             STR      R0,[SP, #+32]
     28              TIM_BaseStruct.TIM_Prescaler =180-1;//timer_tick_frequency = Timer_default_frequency / (prescaller_set + 1) 
   \       0x62   0x20B3             MOVS     R0,#+179
   \       0x64   0xF8AD 0x001C      STRH     R0,[SP, #+28]
     29              TIM_BaseStruct.TIM_CounterMode = TIM_CounterMode_Up;
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xF8AD 0x001E      STRH     R0,[SP, #+30]
     30              TIM_BaseStruct.TIM_ClockDivision=TIM_CKD_DIV1;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xF8AD 0x0024      STRH     R0,[SP, #+36]
     31              TIM_BaseStruct.TIM_RepetitionCounter=0;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xF88D 0x0026      STRB     R0,[SP, #+38]
     32              TIM_TimeBaseInit(TIM1, &TIM_BaseStruct);
   \       0x7A   0x....'....        LDR.W    R4,??DataTable6_1  ;; 0x40010000
   \       0x7E   0xA907             ADD      R1,SP,#+28
   \       0x80   0x0020             MOVS     R0,R4
   \       0x82   0x....'....        BL       TIM_TimeBaseInit
     33              
     34              TIM_OCInitTypeDef TIM_OCStruct;
     35              TIM_OCStruct.TIM_OCMode = TIM_OCMode_PWM1;
   \       0x86   0x2060             MOVS     R0,#+96
   \       0x88   0xF8AD 0x0008      STRH     R0,[SP, #+8]
     36              TIM_OCStruct.TIM_OutputState = TIM_OutputState_Enable;
   \       0x8C   0x2001             MOVS     R0,#+1
   \       0x8E   0xF8AD 0x000A      STRH     R0,[SP, #+10]
     37              TIM_OCStruct.TIM_OCPolarity  = TIM_OCPolarity_High;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0xF8AD 0x0014      STRH     R0,[SP, #+20]
     38              /*pulse_length = ((TIM_Period + 1) * DutyCycle) / 100 - 1
     39              25% duty cycle:      pulse_length = ((8399 + 1) * 25) / 100 - 1 = 2099
     40              50% duty cycle:      pulse_length = ((8399 + 1) * 50) / 100 - 1 = 4199
     41              75% duty cycle:      pulse_length = ((8399 + 1) * 75) / 100 - 1 = 6299
     42              100% duty cycle:    pulse_length = ((8399 + 1) * 100) / 100 - 1 = 8399*/
     43              TIM_OCStruct.TIM_Pulse=0;
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0x9004             STR      R0,[SP, #+16]
     44              TIM_OC1Init(TIM1, &TIM_OCStruct);
   \       0x9C   0xA902             ADD      R1,SP,#+8
   \       0x9E   0x0020             MOVS     R0,R4
   \       0xA0   0x....'....        BL       TIM_OC1Init
     45              TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
   \       0xA4   0x2108             MOVS     R1,#+8
   \       0xA6   0x0020             MOVS     R0,R4
   \       0xA8   0x....'....        BL       TIM_OC1PreloadConfig
     46              //
     47              TIM_OCStruct.TIM_Pulse=0;
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0x9004             STR      R0,[SP, #+16]
     48              TIM_OC2Init(TIM1, &TIM_OCStruct);
   \       0xB0   0xA902             ADD      R1,SP,#+8
   \       0xB2   0x0020             MOVS     R0,R4
   \       0xB4   0x....'....        BL       TIM_OC2Init
     49              TIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Enable);
   \       0xB8   0x2108             MOVS     R1,#+8
   \       0xBA   0x0020             MOVS     R0,R4
   \       0xBC   0x....'....        BL       TIM_OC2PreloadConfig
     50              //  
     51              TIM_OCStruct.TIM_Pulse=0;
   \       0xC0   0x2000             MOVS     R0,#+0
   \       0xC2   0x9004             STR      R0,[SP, #+16]
     52              TIM_OC3Init(TIM1, &TIM_OCStruct);
   \       0xC4   0xA902             ADD      R1,SP,#+8
   \       0xC6   0x0020             MOVS     R0,R4
   \       0xC8   0x....'....        BL       TIM_OC3Init
     53              TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);
   \       0xCC   0x2108             MOVS     R1,#+8
   \       0xCE   0x0020             MOVS     R0,R4
   \       0xD0   0x....'....        BL       TIM_OC3PreloadConfig
     54              //  
     55          //    TIM_OCStruct.TIM_Pulse=0;
     56          //    TIM_OC4Init(TIM1, &TIM_OCStruct);
     57          //    TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);
     58              
     59              TIM_Cmd(TIM1,ENABLE);
   \       0xD4   0x2101             MOVS     R1,#+1
   \       0xD6   0x0020             MOVS     R0,R4
   \       0xD8   0x....'....        BL       TIM_Cmd
     60              TIM_CtrlPWMOutputs(TIM1,ENABLE);
   \       0xDC   0x2101             MOVS     R1,#+1
   \       0xDE   0x0020             MOVS     R0,R4
   \       0xE0   0x....'....        BL       TIM_CtrlPWMOutputs
     61          }
   \       0xE4   0xB00A             ADD      SP,SP,#+40
   \       0xE6   0xBD10             POP      {R4,PC}          ;; return
     62          
     63          /*=========================================================
     64          
     65          
     66          TIM2 pwm PA0、PA1、PA2、PA3
     67          
     68          =========================================================*/
     69          
     70          //void TM2_PWM_Init(void){
     71          //    GPIO_InitTypeDef GPIO_InitStruct;
     72          //    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
     73          //    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
     74          //    /* Alternating functions for pins 原本在PB*/
     75          //    //  GPIO_PinAFConfig(GPIOA, GPIO_PinSource0, GPIO_AF_TIM2);  // chl_1
     76          //    //  GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_TIM2);  // chl_2
     77          //    //  GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_TIM2);  // chl_3
     78          //    //  GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_TIM2);  // chl_4
     79          //    
     80          //    GPIO_PinAFConfig(GPIOA, GPIO_PinSource15, GPIO_AF_TIM2);  // chl_1
     81          ////    GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_TIM2);  // chl_3
     82          ////    GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_TIM2);  // chl_4
     83          //    
     84          //    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_15;//; | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;
     85          //    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
     86          //    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
     87          //    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
     88          //    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
     89          //    GPIO_Init(GPIOA, &GPIO_InitStruct);
     90          //    
     91          ////    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
     92          ////    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
     93          ////    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
     94          ////    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
     95          ////    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
     96          ////    GPIO_Init(GPIOB, &GPIO_InitStruct);
     97          //    //Initialize TIM2
     98          //    TIM_TimeBaseInitTypeDef TIM_BaseStruct;
     99          //    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
    100          //    TIM_BaseStruct.TIM_Prescaler =90-1;//timer_tick_frequency = Timer_default_frequency / (prescaller_set + 1) 
    101          //    TIM_BaseStruct.TIM_CounterMode = TIM_CounterMode_Up;
    102          //    TIM_BaseStruct.TIM_Period=20000-1;//PWM_frequency = timer_tick_frequency / (TIM_Period + 1) ==> TIM_Period = timer_tick_frequency / PWM_frequency - 1
    103          //    TIM_BaseStruct.TIM_ClockDivision=TIM_CKD_DIV1;
    104          //    TIM_BaseStruct.TIM_RepetitionCounter=0;
    105          //    TIM_TimeBaseInit(TIM2, &TIM_BaseStruct);
    106          //    
    107          //    TIM_OCInitTypeDef TIM_OCStruct;
    108          //    TIM_OCStruct.TIM_OCMode = TIM_OCMode_PWM1;
    109          //    TIM_OCStruct.TIM_OutputState = TIM_OutputState_Enable;
    110          //    TIM_OCStruct.TIM_OCPolarity  = TIM_OCPolarity_High;
    111          //    /*pulse_length = ((TIM_Period + 1) * DutyCycle) / 100 - 1
    112          //    25% duty cycle:      pulse_length = ((8399 + 1) * 25) / 100 - 1 = 2099
    113          //    50% duty cycle:      pulse_length = ((8399 + 1) * 50) / 100 - 1 = 4199
    114          //    75% duty cycle:      pulse_length = ((8399 + 1) * 75) / 100 - 1 = 6299
    115          //    100% duty cycle:    pulse_length = ((8399 + 1) * 100) / 100 - 1 = 8399*/
    116          //    TIM_OCStruct.TIM_Pulse=0;
    117          //    TIM_OC1Init(TIM2, &TIM_OCStruct);
    118          //    TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable);
    119          //    //  //  
    120          //    //  TIM_OCStruct.TIM_Pulse=0;
    121          //    //  TIM_OC2Init(TIM2, &TIM_OCStruct);
    122          //    //  TIM_OC2PreloadConfig(TIM2, TIM_OCPreload_Enable);
    123          //    //  
    124          //    TIM_OCStruct.TIM_Pulse=0;
    125          //    TIM_OC3Init(TIM2, &TIM_OCStruct);
    126          //    TIM_OC3PreloadConfig(TIM2, TIM_OCPreload_Enable);
    127          //    //  
    128          //    TIM_OCStruct.TIM_Pulse=0;
    129          //    TIM_OC4Init(TIM2, &TIM_OCStruct);
    130          //    TIM_OC4PreloadConfig(TIM2, TIM_OCPreload_Enable);
    131          //    
    132          //    TIM_Cmd(TIM2,ENABLE);
    133          //}
    134          /*=========================================================
    135          
    136          
    137          TIM3 pwm PC6、PC7、PC8、PC9
    138          
    139          =========================================================*/
    140          
    141          //void TM3_PWM_Init(void){
    142          //  GPIO_InitTypeDef GPIO_InitStruct;
    143          //  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    144          //  /* Alternating functions for pins 原本在PC 6 7 8 9*/
    145          //  GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_TIM3);
    146          //  GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_TIM3);
    147          //  /*PB 
    148          //  // tim3 ch3、4 at PB GPIO_Pin_0  GPIO_Pin_1;
    149          //  GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_TIM3);
    150          //  GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_TIM3);
    151          //  */
    152          //  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;//GPIO_Pin_8 | GPIO_Pin_9
    153          //  GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
    154          //  GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
    155          //  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
    156          //  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_100MHz;
    157          //  GPIO_Init(GPIOC, &GPIO_InitStruct);
    158          //  
    159          //  //Initialize TIM3
    160          //  TIM_TimeBaseInitTypeDef TIM_BaseStruct;
    161          //  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);
    162          //  TIM_BaseStruct.TIM_Prescaler =0;//timer_tick_frequency = Timer_default_frequency / (prescaller_set + 1) 
    163          //  TIM_BaseStruct.TIM_CounterMode = TIM_CounterMode_Up;
    164          //  TIM_BaseStruct.TIM_Period=8399;//PWM_frequency = timer_tick_frequency / (TIM_Period + 1) ==> TIM_Period = timer_tick_frequency / PWM_frequency - 1
    165          //  TIM_BaseStruct.TIM_ClockDivision=TIM_CKD_DIV1;
    166          //  TIM_BaseStruct.TIM_RepetitionCounter=0;
    167          //  TIM_TimeBaseInit(TIM3, &TIM_BaseStruct);
    168          //  TIM_Cmd(TIM3,ENABLE);
    169          //  
    170          //  //Initialize PWM
    171          //  TIM_OCInitTypeDef TIM_OCStruct;
    172          //  /* PWM mode 2 = Clear on compare match */
    173          //  /* PWM mode 1 = Set on compare match */
    174          //  TIM_OCStruct.TIM_OCMode = TIM_OCMode_PWM2;
    175          //  TIM_OCStruct.TIM_OutputState = TIM_OutputState_Enable;
    176          //  TIM_OCStruct.TIM_OCPolarity  = TIM_OCPolarity_High;
    177          //  /*pulse_length = ((TIM_Period + 1) * DutyCycle) / 100 - 1
    178          //  25% duty cycle:      pulse_length = ((8399 + 1) * 25) / 100 - 1 = 2099
    179          //  50% duty cycle:      pulse_length = ((8399 + 1) * 50) / 100 - 1 = 4199
    180          //  75% duty cycle:      pulse_length = ((8399 + 1) * 75) / 100 - 1 = 6299
    181          //  100% duty cycle:    pulse_length = ((8399 + 1) * 100) / 100 - 1 = 8399*/
    182          //  TIM_OCStruct.TIM_Pulse=2099;
    183          //  TIM_OC1Init(TIM3, &TIM_OCStruct);
    184          //  TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable);
    185          //  
    186          //  TIM_OCStruct.TIM_Pulse=4199;
    187          //  TIM_OC2Init(TIM3, &TIM_OCStruct);
    188          //  TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable);
    189          //  
    190          //  /*TIM_OCStruct.TIM_Pulse=6299;
    191          //  TIM_OC3Init(TIM3, &TIM_OCStruct);
    192          //  TIM_OC3PreloadConfig(TIM3, TIM_OCPreload_Enable);
    193          //  
    194          //  TIM_OCStruct.TIM_Pulse=8399;
    195          //  TIM_OC4Init(TIM3, &TIM_OCStruct);
    196          //  TIM_OC4PreloadConfig(TIM3, TIM_OCPreload_Enable);*/
    197          //}
    198          
    199          /*=========================================================
    200          
    201          
    202          TIM4 pwm PB6、PB7、PB8、PB9 or PD12、PD13、PD14、PD15
    203          
    204          =========================================================*/
    205          //
    206          //void TM4_PWM_Init(void){
    207          //  GPIO_InitTypeDef GPIO_InitStruct;
    208          //  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    209          //  /* Alternating functions for pins 原本在PB*/
    210          //  GPIO_PinAFConfig(GPIOD, GPIO_PinSource12, GPIO_AF_TIM4);
    211          //  GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_TIM4);
    212          //  /*
    213          //  GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_TIM4);
    214          //  GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_TIM4);
    215          //  */
    216          //  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13;// | GPIO_Pin_14 | GPIO_Pin_15;
    217          //  GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
    218          //  GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
    219          //  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
    220          //  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_100MHz;
    221          //  GPIO_Init(GPIOD, &GPIO_InitStruct);
    222          //  //Initialize TIM4
    223          //  TIM_TimeBaseInitTypeDef TIM_BaseStruct;
    224          //  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4,ENABLE);
    225          //  TIM_BaseStruct.TIM_Prescaler =0;//timer_tick_frequency = Timer_default_frequency / (prescaller_set + 1) 
    226          //  TIM_BaseStruct.TIM_CounterMode = TIM_CounterMode_Up;
    227          //  TIM_BaseStruct.TIM_Period=8399;//PWM_frequency = timer_tick_frequency / (TIM_Period + 1) ==> TIM_Period = timer_tick_frequency / PWM_frequency - 1
    228          //  TIM_BaseStruct.TIM_ClockDivision=TIM_CKD_DIV1;
    229          //  TIM_BaseStruct.TIM_RepetitionCounter=0;
    230          //  TIM_TimeBaseInit(TIM4, &TIM_BaseStruct);
    231          //  TIM_Cmd(TIM4,ENABLE);
    232          //  TIM_OCInitTypeDef TIM_OCStruct;
    233          //  /* PWM mode 2 = Clear on compare match */
    234          //  /* PWM mode 1 = Set on compare match */
    235          //  TIM_OCStruct.TIM_OCMode = TIM_OCMode_PWM2;
    236          //  TIM_OCStruct.TIM_OutputState = TIM_OutputState_Enable;
    237          //  TIM_OCStruct.TIM_OCPolarity  = TIM_OCPolarity_High;
    238          //  /*pulse_length = ((TIM_Period + 1) * DutyCycle) / 100 - 1
    239          //  25% duty cycle:      pulse_length = ((8399 + 1) * 25) / 100 - 1 = 2099
    240          //  50% duty cycle:      pulse_length = ((8399 + 1) * 50) / 100 - 1 = 4199
    241          //  75% duty cycle:      pulse_length = ((8399 + 1) * 75) / 100 - 1 = 6299
    242          //  100% duty cycle:    pulse_length = ((8399 + 1) * 100) / 100 - 1 = 8399*/
    243          //  TIM_OCStruct.TIM_Pulse=2099;
    244          //  TIM_OC1Init(TIM4, &TIM_OCStruct);
    245          //  TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
    246          //  
    247          //  TIM_OCStruct.TIM_Pulse=4199;
    248          //  TIM_OC2Init(TIM4, &TIM_OCStruct);
    249          //  TIM_OC2PreloadConfig(TIM4, TIM_OCPreload_Enable);
    250          //  
    251          //  /*TIM_OCStruct.TIM_Pulse=6299;
    252          //  TIM_OC3Init(TIM4, &TIM_OCStruct);
    253          //  TIM_OC3PreloadConfig(TIM4, TIM_OCPreload_Enable);
    254          //  
    255          //  TIM_OCStruct.TIM_Pulse=8399;
    256          //  TIM_OC4Init(TIM4, &TIM_OCStruct);
    257          //  TIM_OC4PreloadConfig(TIM4, TIM_OCPreload_Enable);*/
    258          //}
    259          
    260          
    261          /*=========================================================
    262          
    263          
    264          TIM5 pwm PA0、PA1、PA2、PA3
    265          
    266          =========================================================*/
    267          
    268          //void TM5_PWM_Init(void){
    269          //  GPIO_InitTypeDef GPIO_InitStruct;
    270          //  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    271          //  /* Alternating functions for pins 原本在PB*/
    272          //  GPIO_PinAFConfig(GPIOA, GPIO_PinSource0, GPIO_AF_TIM5);
    273          //  GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_TIM5);
    274          //  GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_TIM5);
    275          ////  GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_TIM5);
    276          //  
    277          //  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2;// | GPIO_Pin_3;
    278          //  GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
    279          //  GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
    280          //  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
    281          //  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_100MHz;
    282          //  GPIO_Init(GPIOA, &GPIO_InitStruct);
    283          //  //Initialize TIM5
    284          //  TIM_TimeBaseInitTypeDef TIM_BaseStruct;
    285          //  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5,ENABLE);
    286          //  TIM_BaseStruct.TIM_Prescaler =0;//timer_tick_frequency = Timer_default_frequency / (prescaller_set + 1) 
    287          //  TIM_BaseStruct.TIM_CounterMode = TIM_CounterMode_Up;
    288          //  TIM_BaseStruct.TIM_Period=9000-1;//PWM_frequency = timer_tick_frequency / (TIM_Period + 1) ==> TIM_Period = timer_tick_frequency / PWM_frequency - 1
    289          //  TIM_BaseStruct.TIM_ClockDivision=TIM_CKD_DIV1;
    290          //  TIM_BaseStruct.TIM_RepetitionCounter=0;
    291          //  TIM_TimeBaseInit(TIM5, &TIM_BaseStruct);
    292          //  
    293          //  TIM_OCInitTypeDef TIM_OCStruct;
    294          //  TIM_OCStruct.TIM_OCMode = TIM_OCMode_PWM2;
    295          //  TIM_OCStruct.TIM_OutputState = TIM_OutputState_Enable;
    296          //  TIM_OCStruct.TIM_OCPolarity  = TIM_OCPolarity_High;
    297          //  /*pulse_length = ((TIM_Period + 1) * DutyCycle) / 100 - 1
    298          //  25% duty cycle:      pulse_length = ((8399 + 1) * 25) / 100 - 1 = 2099
    299          //  50% duty cycle:      pulse_length = ((8399 + 1) * 50) / 100 - 1 = 4199
    300          //  75% duty cycle:      pulse_length = ((8399 + 1) * 75) / 100 - 1 = 6299
    301          //  100% duty cycle:    pulse_length = ((8399 + 1) * 100) / 100 - 1 = 8399*/
    302          //  TIM_OCStruct.TIM_Pulse=0;
    303          //  TIM_OC1Init(TIM5, &TIM_OCStruct);
    304          //  TIM_OC1PreloadConfig(TIM5, TIM_OCPreload_Enable);
    305          //  
    306          //  TIM_OCStruct.TIM_Pulse=0;
    307          //  TIM_OC2Init(TIM5, &TIM_OCStruct);
    308          //  TIM_OC2PreloadConfig(TIM5, TIM_OCPreload_Enable);
    309          //  //  
    310          //  TIM_OCStruct.TIM_Pulse=0;
    311          //  TIM_OC3Init(TIM5, &TIM_OCStruct);
    312          //  TIM_OC3PreloadConfig(TIM5, TIM_OCPreload_Enable);
    313          //  
    314          ////  TIM_OCStruct.TIM_Pulse=0;
    315          ////  TIM_OC4Init(TIM5, &TIM_OCStruct);
    316          ////  TIM_OC4PreloadConfig(TIM5, TIM_OCPreload_Enable);
    317          //  TIM_Cmd(TIM5,ENABLE);
    318          //}*/
    319          
    320          /*=========================================================
    321          
    322          
    323          TIM8 pwm PC6、PC7、PC8
    324          
    325          =========================================================*/
    326          

   \                                 In section .text, align 2, keep-with-next
    327          void TM8_PWM_Init(void){
   \                     TM8_PWM_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB08A             SUB      SP,SP,#+40
    328              GPIO_InitTypeDef GPIO_InitStructure;
    329              RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC,ENABLE);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2004             MOVS     R0,#+4
   \        0x8   0x....'....        BL       RCC_AHB1PeriphClockCmd
    330              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xF88D 0x0004      STRB     R0,[SP, #+4]
    331              GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xF88D 0x0006      STRB     R0,[SP, #+6]
    332              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8;// | GPIO_Pin_9;
   \       0x18   0xF44F 0x70E0      MOV      R0,#+448
   \       0x1C   0x9000             STR      R0,[SP, #+0]
    333              GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xF88D 0x0007      STRB     R0,[SP, #+7]
    334              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \       0x24   0x2003             MOVS     R0,#+3
   \       0x26   0xF88D 0x0005      STRB     R0,[SP, #+5]
    335              GPIO_Init(GPIOC,&GPIO_InitStructure);
   \       0x2A   0x....'....        LDR.W    R4,??DataTable6_2  ;; 0x40020800
   \       0x2E   0x4669             MOV      R1,SP
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x....'....        BL       GPIO_Init
    336              
    337              GPIO_PinAFConfig(GPIOC,GPIO_PinSource6,GPIO_AF_TIM8);
   \       0x36   0x2203             MOVS     R2,#+3
   \       0x38   0x2106             MOVS     R1,#+6
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0x....'....        BL       GPIO_PinAFConfig
    338              GPIO_PinAFConfig(GPIOC,GPIO_PinSource7,GPIO_AF_TIM8);
   \       0x40   0x2203             MOVS     R2,#+3
   \       0x42   0x2107             MOVS     R1,#+7
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x....'....        BL       GPIO_PinAFConfig
    339              GPIO_PinAFConfig(GPIOC,GPIO_PinSource8,GPIO_AF_TIM8);
   \       0x4A   0x2203             MOVS     R2,#+3
   \       0x4C   0x2108             MOVS     R1,#+8
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x....'....        BL       GPIO_PinAFConfig
    340              //  GPIO_PinAFConfig(GPIOC,GPIO_PinSource9,GPIO_AF_TIM8);
    341              RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8,ENABLE);
   \       0x54   0x2101             MOVS     R1,#+1
   \       0x56   0x2002             MOVS     R0,#+2
   \       0x58   0x....'....        BL       RCC_APB2PeriphClockCmd
    342              //时基初始化
    343              TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    344              TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; //死区控制用。
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0xF8AD 0x0024      STRH     R0,[SP, #+36]
    345              TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;  //计数器方向
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xF8AD 0x001E      STRH     R0,[SP, #+30]
    346              TIM_TimeBaseInitStructure.TIM_Prescaler = 1;   //Timer clock = sysclock /(TIM_Prescaler+1) = 180M
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    347              TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xF88D 0x0026      STRB     R0,[SP, #+38]
    348              TIM_TimeBaseInitStructure.TIM_Period = 9000 - 1;    //Period = (TIM counter clock / TIM output clock) - 1 = 10K
   \       0x74   0xF242 0x3027      MOVW     R0,#+8999
   \       0x78   0x9008             STR      R0,[SP, #+32]
    349              TIM_TimeBaseInit(TIM8,&TIM_TimeBaseInitStructure);
   \       0x7A   0x....'....        LDR.W    R4,??DataTable6_3  ;; 0x40010400
   \       0x7E   0xA907             ADD      R1,SP,#+28
   \       0x80   0x0020             MOVS     R0,R4
   \       0x82   0x....'....        BL       TIM_TimeBaseInit
    350              
    351              
    352              TIM_OCInitTypeDef TIM_OCInitStructure;
    353              TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;
   \       0x86   0x2070             MOVS     R0,#+112
   \       0x88   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    354              TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
   \       0x8C   0x2001             MOVS     R0,#+1
   \       0x8E   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    355              TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
   \       0x92   0x2004             MOVS     R0,#+4
   \       0x94   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    356              
    357              TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    358              TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCPolarity_High;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0xF8AD 0x0016      STRH     R0,[SP, #+22]
    359              TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
   \       0xA4   0xF44F 0x7080      MOV      R0,#+256
   \       0xA8   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    360              TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Reset;
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0xF8AD 0x001A      STRH     R0,[SP, #+26]
    361              
    362              TIM_OCInitStructure.TIM_Pulse = 0;
   \       0xB2   0x2000             MOVS     R0,#+0
   \       0xB4   0x9004             STR      R0,[SP, #+16]
    363              TIM_OC1Init(TIM8,&TIM_OCInitStructure);
   \       0xB6   0xA902             ADD      R1,SP,#+8
   \       0xB8   0x0020             MOVS     R0,R4
   \       0xBA   0x....'....        BL       TIM_OC1Init
    364              
    365              TIM_OCInitStructure.TIM_Pulse = 0;
   \       0xBE   0x2000             MOVS     R0,#+0
   \       0xC0   0x9004             STR      R0,[SP, #+16]
    366              TIM_OC2Init(TIM8,&TIM_OCInitStructure);
   \       0xC2   0xA902             ADD      R1,SP,#+8
   \       0xC4   0x0020             MOVS     R0,R4
   \       0xC6   0x....'....        BL       TIM_OC2Init
    367              
    368              TIM_OCInitStructure.TIM_Pulse = 0;
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0x9004             STR      R0,[SP, #+16]
    369              TIM_OC3Init(TIM8,&TIM_OCInitStructure);
   \       0xCE   0xA902             ADD      R1,SP,#+8
   \       0xD0   0x0020             MOVS     R0,R4
   \       0xD2   0x....'....        BL       TIM_OC3Init
    370              
    371              //  TIM_OCInitStructure.TIM_Pulse = 2400;
    372              //  TIM_OC4Init(TIM8,&TIM_OCInitStructure);
    373              
    374              TIM_Cmd(TIM8,ENABLE);
   \       0xD6   0x2101             MOVS     R1,#+1
   \       0xD8   0x0020             MOVS     R0,R4
   \       0xDA   0x....'....        BL       TIM_Cmd
    375              TIM_CtrlPWMOutputs(TIM8,ENABLE);
   \       0xDE   0x2101             MOVS     R1,#+1
   \       0xE0   0x0020             MOVS     R0,R4
   \       0xE2   0x....'....        BL       TIM_CtrlPWMOutputs
    376          }
   \       0xE6   0xB00A             ADD      SP,SP,#+40
   \       0xE8   0xBD10             POP      {R4,PC}          ;; return
    377          
    378          /*=========================================================
    379          TIM2 EncoderInterface pwm PA2、PA3
    380          TIM3 EncoderInterface pwm PA6、PA7
    381          TIM4 EncoderInterface pwm PB6、PB7
    382          =========================================================*/

   \                                 In section .text, align 2, keep-with-next
    383          int read_Encoder(int encoder_num){
   \                     read_Encoder: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    384              int Encoder = 0;
   \        0x2   0x2000             MOVS     R0,#+0
    385              switch(encoder_num){
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD004             BEQ.N    ??read_Encoder_0
   \        0x8   0xD314             BCC.N    ??read_Encoder_1
   \        0xA   0x2903             CMP      R1,#+3
   \        0xC   0xD00D             BEQ.N    ??read_Encoder_2
   \        0xE   0xD306             BCC.N    ??read_Encoder_3
   \       0x10   0xE010             B.N      ??read_Encoder_1
    386              case 1:
    387                  Encoder = (short)TIM2->CNT;//因為設定是65535所以用short來將逆向的馬達計數轉為負號
   \                     ??read_Encoder_0: (+1)
   \       0x12   0x....             LDR.N    R1,??DataTable6_4  ;; 0x40000024
   \       0x14   0x6808             LDR      R0,[R1, #+0]
   \       0x16   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
    388                  TIM2->CNT = 0;
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0x600A             STR      R2,[R1, #+0]
    389                  break;
   \       0x1C   0xE00A             B.N      ??read_Encoder_1
    390              case 2:
    391                  Encoder = (short)TIM3->CNT;
   \                     ??read_Encoder_3: (+1)
   \       0x1E   0x....             LDR.N    R1,??DataTable6_5  ;; 0x40000424
   \       0x20   0x6808             LDR      R0,[R1, #+0]
   \       0x22   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
    392                  TIM3->CNT = 0;
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0x600A             STR      R2,[R1, #+0]
    393                  break;
   \       0x28   0xE004             B.N      ??read_Encoder_1
    394              case 3:
    395                  Encoder = (short)TIM4->CNT;
   \                     ??read_Encoder_2: (+1)
   \       0x2A   0x....             LDR.N    R1,??DataTable6_6  ;; 0x40000824
   \       0x2C   0x6808             LDR      R0,[R1, #+0]
   \       0x2E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
    396                  TIM4->CNT = 0;
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x600A             STR      R2,[R1, #+0]
    397                  break;
    398              }
    399              return Encoder;
   \                     ??read_Encoder_1: (+1)
   \       0x34   0x4770             BX       LR               ;; return
    400          }
    401          //TIM1 EncoderInterface unuse

   \                                 In section .text, align 2, keep-with-next
    402          void TIM1_EncoderInterface_Init(void) {
   \                     TIM1_EncoderInterface_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    403              GPIO_InitTypeDef GPIO_InitStructure;
    404              RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x....'....        BL       RCC_APB2PeriphClockCmd
    405              // GPIOB Clock Enable
    406              RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x....'....        BL       RCC_AHB1PeriphClockCmd
    407              // Initalize PB5 (TIM1 Ch1) and PB6 (TIM1 Ch2)
    408              GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_8 | GPIO_Pin_9;
   \       0x14   0xF44F 0x7040      MOV      R0,#+768
   \       0x18   0x9000             STR      R0,[SP, #+0]
    409              GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_AF;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    410              GPIO_InitStructure.GPIO_Speed   = GPIO_Speed_100MHz;    // GPIO_High_Speed
   \       0x20   0x2003             MOVS     R0,#+3
   \       0x22   0xF88D 0x0005      STRB     R0,[SP, #+5]
    411              GPIO_InitStructure.GPIO_OType   = GPIO_OType_PP;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xF88D 0x0006      STRB     R0,[SP, #+6]
    412              GPIO_InitStructure.GPIO_PuPd    = GPIO_PuPd_UP;         // Weak Pull-up for safety during startup
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xF88D 0x0007      STRB     R0,[SP, #+7]
    413              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \       0x32   0x....             LDR.N    R4,??DataTable6  ;; 0x40020000
   \       0x34   0x4669             MOV      R1,SP
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x....'....        BL       GPIO_Init
    414              // Assign Alternate Functions to pins
    415              GPIO_PinAFConfig(GPIOA, GPIO_PinSource8, GPIO_AF_TIM1);
   \       0x3C   0x2201             MOVS     R2,#+1
   \       0x3E   0x2108             MOVS     R1,#+8
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x....'....        BL       GPIO_PinAFConfig
    416              GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_TIM1);
   \       0x46   0x2201             MOVS     R2,#+1
   \       0x48   0x2109             MOVS     R1,#+9
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x....'....        BL       GPIO_PinAFConfig
    417              
    418              TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    419              TIM_TimeBaseInitStructure.TIM_Period =65535;  //reload value
   \       0x50   0xF64F 0x70FF      MOVW     R0,#+65535
   \       0x54   0x9003             STR      R0,[SP, #+12]
    420              TIM_TimeBaseInitStructure.TIM_Prescaler=0;  //無分頻
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    421              TIM_TimeBaseInitStructure.TIM_ClockDivision = 0;
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    422              TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up; //向上計數
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    423              TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1; 
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    424              TIM_TimeBaseInit(TIM1, &TIM_TimeBaseInitStructure);
   \       0x6E   0x....             LDR.N    R4,??DataTable6_1  ;; 0x40010000
   \       0x70   0xA902             ADD      R1,SP,#+8
   \       0x72   0x0020             MOVS     R0,R4
   \       0x74   0x....'....        BL       TIM_TimeBaseInit
    425              
    426              TIM_ICInitTypeDef TIM_ICInitStructure;
    427              TIM_EncoderInterfaceConfig(TIM1, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising ,TIM_ICPolarity_Rising); // 四分頻stm讀取encoder設置
   \       0x78   0x2300             MOVS     R3,#+0
   \       0x7A   0x2200             MOVS     R2,#+0
   \       0x7C   0x2103             MOVS     R1,#+3
   \       0x7E   0x0020             MOVS     R0,R4
   \       0x80   0x....'....        BL       TIM_EncoderInterfaceConfig
    428              TIM_ICStructInit(&TIM_ICInitStructure); 
   \       0x84   0xA805             ADD      R0,SP,#+20
   \       0x86   0x....'....        BL       TIM_ICStructInit
    429              TIM_ICInitStructure.TIM_ICFilter = 10;//濾波器值(從第10個訊號後才開始計數)
   \       0x8A   0x200A             MOVS     R0,#+10
   \       0x8C   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    430              TIM_ICInit(TIM1, &TIM_ICInitStructure);
   \       0x90   0xA905             ADD      R1,SP,#+20
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0x....'....        BL       TIM_ICInit
    431              
    432              TIM_ClearFlag(TIM1, TIM_FLAG_Update);//清除TIM1的更新旗標
   \       0x98   0x2101             MOVS     R1,#+1
   \       0x9A   0x0020             MOVS     R0,R4
   \       0x9C   0x....'....        BL       TIM_ClearFlag
    433              TIM_ITConfig(TIM1, TIM_IT_Update, ENABLE);//運行更新
   \       0xA0   0x2201             MOVS     R2,#+1
   \       0xA2   0x2101             MOVS     R1,#+1
   \       0xA4   0x0020             MOVS     R0,R4
   \       0xA6   0x....'....        BL       TIM_ITConfig
    434              
    435              //  NVIC_InitTypeDef NVIC_InitStructure;    
    436              //  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);           
    437              //  
    438              //  NVIC_InitStructure.NVIC_IRQChannel = TIM1_IRQn;    
    439              //  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;               
    440              //  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    441              //  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;            
    442              //  NVIC_Init(&NVIC_InitStructure);
    443              TIM_SetCounter(TIM1,0); //TIM1->CNT=0
   \       0xAA   0x2100             MOVS     R1,#+0
   \       0xAC   0x0020             MOVS     R0,R4
   \       0xAE   0x....'....        BL       TIM_SetCounter
    444              TIM_Cmd(TIM1, ENABLE); 
   \       0xB2   0x2101             MOVS     R1,#+1
   \       0xB4   0x0020             MOVS     R0,R4
   \       0xB6   0x....'....        BL       TIM_Cmd
    445          }
   \       0xBA   0xB008             ADD      SP,SP,#+32
   \       0xBC   0xBD10             POP      {R4,PC}          ;; return
    446          //TIM2EncoderInterface

   \                                 In section .text, align 2, keep-with-next
    447          void TIM2_EncoderInterface_Init(void) {
   \                     TIM2_EncoderInterface_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    448              GPIO_InitTypeDef GPIO_InitStructure;
    449              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x....'....        BL       RCC_APB1PeriphClockCmd
    450              // GPIOB Clock Enable
    451              RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x....'....        BL       RCC_AHB1PeriphClockCmd
    452              RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0x....'....        BL       RCC_AHB1PeriphClockCmd
    453              // Initalize PA2 (TIM2 Ch3) and PA3 (TIM2 Ch4)
    454              GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_5;
   \       0x1C   0x2020             MOVS     R0,#+32
   \       0x1E   0x9000             STR      R0,[SP, #+0]
    455              GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_AF;
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xF88D 0x0004      STRB     R0,[SP, #+4]
    456              GPIO_InitStructure.GPIO_Speed   = GPIO_Speed_100MHz;    // GPIO_High_Speed
   \       0x26   0x2003             MOVS     R0,#+3
   \       0x28   0xF88D 0x0005      STRB     R0,[SP, #+5]
    457              GPIO_InitStructure.GPIO_OType   = GPIO_OType_PP;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xF88D 0x0006      STRB     R0,[SP, #+6]
    458              GPIO_InitStructure.GPIO_PuPd    = GPIO_PuPd_UP;         // Weak Pull-up for safety during startup
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xF88D 0x0007      STRB     R0,[SP, #+7]
    459              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \       0x38   0x....             LDR.N    R4,??DataTable6  ;; 0x40020000
   \       0x3A   0x4669             MOV      R1,SP
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0x....'....        BL       GPIO_Init
    460              
    461              GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_3;
   \       0x42   0x2008             MOVS     R0,#+8
   \       0x44   0x9000             STR      R0,[SP, #+0]
    462              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \       0x46   0x....             LDR.N    R5,??DataTable6_7  ;; 0x40020400
   \       0x48   0x4669             MOV      R1,SP
   \       0x4A   0x0028             MOVS     R0,R5
   \       0x4C   0x....'....        BL       GPIO_Init
    463              
    464              // Assign Alternate Functions to pins
    465              GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_TIM2);
   \       0x50   0x2201             MOVS     R2,#+1
   \       0x52   0x2105             MOVS     R1,#+5
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0x....'....        BL       GPIO_PinAFConfig
    466              GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_TIM2);
   \       0x5A   0x2201             MOVS     R2,#+1
   \       0x5C   0x2103             MOVS     R1,#+3
   \       0x5E   0x0028             MOVS     R0,R5
   \       0x60   0x....'....        BL       GPIO_PinAFConfig
    467              
    468              TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    469              TIM_TimeBaseInitStructure.TIM_Period =65535;  //reload value
   \       0x64   0xF64F 0x70FF      MOVW     R0,#+65535
   \       0x68   0x9003             STR      R0,[SP, #+12]
    470              TIM_TimeBaseInitStructure.TIM_Prescaler=0;  //無分頻
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    471              TIM_TimeBaseInitStructure.TIM_ClockDivision = 0;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    472              TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up; //向上計數
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    473              TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1; 
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    474              TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure);
   \       0x82   0xA902             ADD      R1,SP,#+8
   \       0x84   0xF05F 0x4080      MOVS     R0,#+1073741824
   \       0x88   0x....'....        BL       TIM_TimeBaseInit
    475              
    476              
    477              TIM_ICInitTypeDef TIM_ICInitStructure;
    478              TIM_EncoderInterfaceConfig(TIM2, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising ,TIM_ICPolarity_Rising); // 四分頻stm讀取encoder設置
   \       0x8C   0x2300             MOVS     R3,#+0
   \       0x8E   0x2200             MOVS     R2,#+0
   \       0x90   0x2103             MOVS     R1,#+3
   \       0x92   0xF05F 0x4080      MOVS     R0,#+1073741824
   \       0x96   0x....'....        BL       TIM_EncoderInterfaceConfig
    479              TIM_ICStructInit(&TIM_ICInitStructure); 
   \       0x9A   0xA805             ADD      R0,SP,#+20
   \       0x9C   0x....'....        BL       TIM_ICStructInit
    480              TIM_ICInitStructure.TIM_ICFilter = 10;//濾波器值(從第10個訊號後才開始計數)
   \       0xA0   0x200A             MOVS     R0,#+10
   \       0xA2   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    481              TIM_ICInit(TIM2, &TIM_ICInitStructure);
   \       0xA6   0xA905             ADD      R1,SP,#+20
   \       0xA8   0xF05F 0x4080      MOVS     R0,#+1073741824
   \       0xAC   0x....'....        BL       TIM_ICInit
    482              
    483              TIM_ClearFlag(TIM2, TIM_FLAG_Update);//清除TIM3的更新旗標
   \       0xB0   0x2101             MOVS     R1,#+1
   \       0xB2   0xF05F 0x4080      MOVS     R0,#+1073741824
   \       0xB6   0x....'....        BL       TIM_ClearFlag
    484              TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);//運行更新
   \       0xBA   0x2201             MOVS     R2,#+1
   \       0xBC   0x2101             MOVS     R1,#+1
   \       0xBE   0xF05F 0x4080      MOVS     R0,#+1073741824
   \       0xC2   0x....'....        BL       TIM_ITConfig
    485              //IM3定時器
    486              
    487              //  NVIC_InitTypeDef NVIC_InitStructure;    
    488              //  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);           
    489              //  
    490              //  NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;    
    491              //  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;               
    492              //  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    493              //  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;            
    494              //  NVIC_Init(&NVIC_InitStructure);
    495              TIM_SetCounter(TIM2,0); //TIM3->CNT=0
   \       0xC6   0x2100             MOVS     R1,#+0
   \       0xC8   0xF05F 0x4080      MOVS     R0,#+1073741824
   \       0xCC   0x....'....        BL       TIM_SetCounter
    496              TIM_Cmd(TIM2, ENABLE);  
   \       0xD0   0x2101             MOVS     R1,#+1
   \       0xD2   0xF05F 0x4080      MOVS     R0,#+1073741824
   \       0xD6   0x....'....        BL       TIM_Cmd
    497          }
   \       0xDA   0xB009             ADD      SP,SP,#+36
   \       0xDC   0xBD30             POP      {R4,R5,PC}       ;; return
    498          //TIM3EncoderInterface

   \                                 In section .text, align 2, keep-with-next
    499          void TIM3_EncoderInterface_Init(void) {
   \                     TIM3_EncoderInterface_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    500              GPIO_InitTypeDef GPIO_InitStructure;
    501              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2002             MOVS     R0,#+2
   \        0x8   0x....'....        BL       RCC_APB1PeriphClockCmd
    502              // GPIOB Clock Enable
    503              RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x....'....        BL       RCC_AHB1PeriphClockCmd
    504              // Initalize PB6 (TIM4 Ch1) and PB7 (TIM4 Ch2)
    505              GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_6 | GPIO_Pin_7;
   \       0x14   0x20C0             MOVS     R0,#+192
   \       0x16   0x9000             STR      R0,[SP, #+0]
    506              GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_AF;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    507              GPIO_InitStructure.GPIO_Speed   = GPIO_Speed_100MHz;    // GPIO_High_Speed
   \       0x1E   0x2003             MOVS     R0,#+3
   \       0x20   0xF88D 0x0005      STRB     R0,[SP, #+5]
    508              GPIO_InitStructure.GPIO_OType   = GPIO_OType_PP;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xF88D 0x0006      STRB     R0,[SP, #+6]
    509              GPIO_InitStructure.GPIO_PuPd    = GPIO_PuPd_UP;         // Weak Pull-up for safety during startup
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xF88D 0x0007      STRB     R0,[SP, #+7]
    510              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \       0x30   0x....             LDR.N    R4,??DataTable6  ;; 0x40020000
   \       0x32   0x4669             MOV      R1,SP
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x....'....        BL       GPIO_Init
    511              
    512              // Assign Alternate Functions to pins
    513              GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_TIM3);
   \       0x3A   0x2202             MOVS     R2,#+2
   \       0x3C   0x2106             MOVS     R1,#+6
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x....'....        BL       GPIO_PinAFConfig
    514              GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_TIM3);
   \       0x44   0x2202             MOVS     R2,#+2
   \       0x46   0x2107             MOVS     R1,#+7
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x....'....        BL       GPIO_PinAFConfig
    515              
    516              TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    517              TIM_TimeBaseInitStructure.TIM_Period =65535;  //reload value
   \       0x4E   0xF64F 0x70FF      MOVW     R0,#+65535
   \       0x52   0x9003             STR      R0,[SP, #+12]
    518              TIM_TimeBaseInitStructure.TIM_Prescaler=0;  //無分頻
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    519              TIM_TimeBaseInitStructure.TIM_ClockDivision = 0;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    520              TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up; //向上計數
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    521              TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1; 
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    522              TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStructure);
   \       0x6C   0x....             LDR.N    R4,??DataTable6_8  ;; 0x40000400
   \       0x6E   0xA902             ADD      R1,SP,#+8
   \       0x70   0x0020             MOVS     R0,R4
   \       0x72   0x....'....        BL       TIM_TimeBaseInit
    523              
    524              
    525              TIM_ICInitTypeDef TIM_ICInitStructure;
    526              TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising ,TIM_ICPolarity_Rising); // 四分頻stm讀取encoder設置
   \       0x76   0x2300             MOVS     R3,#+0
   \       0x78   0x2200             MOVS     R2,#+0
   \       0x7A   0x2103             MOVS     R1,#+3
   \       0x7C   0x0020             MOVS     R0,R4
   \       0x7E   0x....'....        BL       TIM_EncoderInterfaceConfig
    527              TIM_ICStructInit(&TIM_ICInitStructure); 
   \       0x82   0xA805             ADD      R0,SP,#+20
   \       0x84   0x....'....        BL       TIM_ICStructInit
    528              TIM_ICInitStructure.TIM_ICFilter = 10;//濾波器值(從第10個訊號後才開始計數)
   \       0x88   0x200A             MOVS     R0,#+10
   \       0x8A   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    529              TIM_ICInit(TIM3, &TIM_ICInitStructure);
   \       0x8E   0xA905             ADD      R1,SP,#+20
   \       0x90   0x0020             MOVS     R0,R4
   \       0x92   0x....'....        BL       TIM_ICInit
    530              
    531              TIM_ClearFlag(TIM3, TIM_FLAG_Update);//清除TIM3的更新旗標
   \       0x96   0x2101             MOVS     R1,#+1
   \       0x98   0x0020             MOVS     R0,R4
   \       0x9A   0x....'....        BL       TIM_ClearFlag
    532              TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);//運行更新
   \       0x9E   0x2201             MOVS     R2,#+1
   \       0xA0   0x2101             MOVS     R1,#+1
   \       0xA2   0x0020             MOVS     R0,R4
   \       0xA4   0x....'....        BL       TIM_ITConfig
    533              //IM3定時器
    534              TIM_SetCounter(TIM3,0); //TIM3->CNT=0
   \       0xA8   0x2100             MOVS     R1,#+0
   \       0xAA   0x0020             MOVS     R0,R4
   \       0xAC   0x....'....        BL       TIM_SetCounter
    535              TIM_Cmd(TIM3, ENABLE); 
   \       0xB0   0x2101             MOVS     R1,#+1
   \       0xB2   0x0020             MOVS     R0,R4
   \       0xB4   0x....'....        BL       TIM_Cmd
    536          }
   \       0xB8   0xB008             ADD      SP,SP,#+32
   \       0xBA   0xBD10             POP      {R4,PC}          ;; return
    537          //TIM4 EncoderInterface

   \                                 In section .text, align 2, keep-with-next
    538          void TIM4_EncoderInterface_Init(void) {
   \                     TIM4_EncoderInterface_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    539              GPIO_InitTypeDef GPIO_InitStructure;
    540              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2004             MOVS     R0,#+4
   \        0x8   0x....'....        BL       RCC_APB1PeriphClockCmd
    541              // GPIOB Clock Enable
    542              RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0x....'....        BL       RCC_AHB1PeriphClockCmd
    543              // Initalize PB14 (TIM4 Ch1) and PB15 (TIM4 Ch2)
    544              GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_6 | GPIO_Pin_7;
   \       0x14   0x20C0             MOVS     R0,#+192
   \       0x16   0x9000             STR      R0,[SP, #+0]
    545              GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_AF;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    546              GPIO_InitStructure.GPIO_Speed   = GPIO_Speed_100MHz;    // GPIO_High_Speed
   \       0x1E   0x2003             MOVS     R0,#+3
   \       0x20   0xF88D 0x0005      STRB     R0,[SP, #+5]
    547              GPIO_InitStructure.GPIO_OType   = GPIO_OType_PP;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xF88D 0x0006      STRB     R0,[SP, #+6]
    548              GPIO_InitStructure.GPIO_PuPd    = GPIO_PuPd_UP;         // Weak Pull-up for safety during startup
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xF88D 0x0007      STRB     R0,[SP, #+7]
    549              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \       0x30   0x....             LDR.N    R4,??DataTable6_7  ;; 0x40020400
   \       0x32   0x4669             MOV      R1,SP
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x....'....        BL       GPIO_Init
    550              
    551              // Assign Alternate Functions to pins
    552              GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_TIM4);
   \       0x3A   0x2202             MOVS     R2,#+2
   \       0x3C   0x2106             MOVS     R1,#+6
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x....'....        BL       GPIO_PinAFConfig
    553              GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_TIM4);
   \       0x44   0x2202             MOVS     R2,#+2
   \       0x46   0x2107             MOVS     R1,#+7
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x....'....        BL       GPIO_PinAFConfig
    554              
    555              TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    556              TIM_TimeBaseInitStructure.TIM_Period =65535;  //reload value
   \       0x4E   0xF64F 0x70FF      MOVW     R0,#+65535
   \       0x52   0x9003             STR      R0,[SP, #+12]
    557              TIM_TimeBaseInitStructure.TIM_Prescaler=0;  //無分頻
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    558              TIM_TimeBaseInitStructure.TIM_ClockDivision = 0;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    559              TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up; //向上計數
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    560              TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1; 
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    561              TIM_TimeBaseInit(TIM4, &TIM_TimeBaseInitStructure);
   \       0x6C   0x....             LDR.N    R4,??DataTable6_9  ;; 0x40000800
   \       0x6E   0xA902             ADD      R1,SP,#+8
   \       0x70   0x0020             MOVS     R0,R4
   \       0x72   0x....'....        BL       TIM_TimeBaseInit
    562              
    563              
    564              TIM_ICInitTypeDef TIM_ICInitStructure;
    565              TIM_EncoderInterfaceConfig(TIM4, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising ,TIM_ICPolarity_Rising); // 四分頻stm讀取encoder設置
   \       0x76   0x2300             MOVS     R3,#+0
   \       0x78   0x2200             MOVS     R2,#+0
   \       0x7A   0x2103             MOVS     R1,#+3
   \       0x7C   0x0020             MOVS     R0,R4
   \       0x7E   0x....'....        BL       TIM_EncoderInterfaceConfig
    566              TIM_ICStructInit(&TIM_ICInitStructure); 
   \       0x82   0xA805             ADD      R0,SP,#+20
   \       0x84   0x....'....        BL       TIM_ICStructInit
    567              TIM_ICInitStructure.TIM_ICFilter = 10;//濾波器值(從第10個訊號後才開始計數)
   \       0x88   0x200A             MOVS     R0,#+10
   \       0x8A   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    568              TIM_ICInit(TIM4, &TIM_ICInitStructure);
   \       0x8E   0xA905             ADD      R1,SP,#+20
   \       0x90   0x0020             MOVS     R0,R4
   \       0x92   0x....'....        BL       TIM_ICInit
    569              
    570              TIM_ClearFlag(TIM4, TIM_FLAG_Update);//清除TIM4的更新旗標
   \       0x96   0x2101             MOVS     R1,#+1
   \       0x98   0x0020             MOVS     R0,R4
   \       0x9A   0x....'....        BL       TIM_ClearFlag
    571              TIM_ITConfig(TIM4, TIM_IT_Update, ENABLE);//運行更新
   \       0x9E   0x2201             MOVS     R2,#+1
   \       0xA0   0x2101             MOVS     R1,#+1
   \       0xA2   0x0020             MOVS     R0,R4
   \       0xA4   0x....'....        BL       TIM_ITConfig
    572              //IM3定時器
    573              
    574              //  NVIC_InitTypeDef NVIC_InitStructure;    
    575              //  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);           
    576              //  
    577              //  NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;    
    578              //  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;               
    579              //  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    580              //  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;            
    581              //  NVIC_Init(&NVIC_InitStructure);
    582              TIM_SetCounter(TIM4,0); //TIM4->CNT=0
   \       0xA8   0x2100             MOVS     R1,#+0
   \       0xAA   0x0020             MOVS     R0,R4
   \       0xAC   0x....'....        BL       TIM_SetCounter
    583              TIM_Cmd(TIM4, ENABLE); 
   \       0xB0   0x2101             MOVS     R1,#+1
   \       0xB2   0x0020             MOVS     R0,R4
   \       0xB4   0x....'....        BL       TIM_Cmd
    584          }
   \       0xB8   0xB008             ADD      SP,SP,#+32
   \       0xBA   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x4002'0000        DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x4001'0000        DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x4002'0800        DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x4001'0400        DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x4000'0024        DC32     0x40000024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x4000'0424        DC32     0x40000424

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \        0x0   0x4000'0824        DC32     0x40000824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \        0x0   0x4002'0400        DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \        0x0   0x4000'0400        DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \        0x0   0x4000'0800        DC32     0x40000800

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   TIM1_EncoderInterface_Init
        40   -> GPIO_Init
        40   -> GPIO_PinAFConfig
        40   -> RCC_AHB1PeriphClockCmd
        40   -> RCC_APB2PeriphClockCmd
        40   -> TIM_ClearFlag
        40   -> TIM_Cmd
        40   -> TIM_EncoderInterfaceConfig
        40   -> TIM_ICInit
        40   -> TIM_ICStructInit
        40   -> TIM_ITConfig
        40   -> TIM_SetCounter
        40   -> TIM_TimeBaseInit
      48   TIM2_EncoderInterface_Init
        48   -> GPIO_Init
        48   -> GPIO_PinAFConfig
        48   -> RCC_AHB1PeriphClockCmd
        48   -> RCC_APB1PeriphClockCmd
        48   -> TIM_ClearFlag
        48   -> TIM_Cmd
        48   -> TIM_EncoderInterfaceConfig
        48   -> TIM_ICInit
        48   -> TIM_ICStructInit
        48   -> TIM_ITConfig
        48   -> TIM_SetCounter
        48   -> TIM_TimeBaseInit
      40   TIM3_EncoderInterface_Init
        40   -> GPIO_Init
        40   -> GPIO_PinAFConfig
        40   -> RCC_AHB1PeriphClockCmd
        40   -> RCC_APB1PeriphClockCmd
        40   -> TIM_ClearFlag
        40   -> TIM_Cmd
        40   -> TIM_EncoderInterfaceConfig
        40   -> TIM_ICInit
        40   -> TIM_ICStructInit
        40   -> TIM_ITConfig
        40   -> TIM_SetCounter
        40   -> TIM_TimeBaseInit
      40   TIM4_EncoderInterface_Init
        40   -> GPIO_Init
        40   -> GPIO_PinAFConfig
        40   -> RCC_AHB1PeriphClockCmd
        40   -> RCC_APB1PeriphClockCmd
        40   -> TIM_ClearFlag
        40   -> TIM_Cmd
        40   -> TIM_EncoderInterfaceConfig
        40   -> TIM_ICInit
        40   -> TIM_ICStructInit
        40   -> TIM_ITConfig
        40   -> TIM_SetCounter
        40   -> TIM_TimeBaseInit
      48   TM1_PWM_Init
        48   -> GPIO_Init
        48   -> GPIO_PinAFConfig
        48   -> RCC_AHB1PeriphClockCmd
        48   -> RCC_APB2PeriphClockCmd
        48   -> TIM_Cmd
        48   -> TIM_CtrlPWMOutputs
        48   -> TIM_OC1Init
        48   -> TIM_OC1PreloadConfig
        48   -> TIM_OC2Init
        48   -> TIM_OC2PreloadConfig
        48   -> TIM_OC3Init
        48   -> TIM_OC3PreloadConfig
        48   -> TIM_TimeBaseInit
      48   TM8_PWM_Init
        48   -> GPIO_Init
        48   -> GPIO_PinAFConfig
        48   -> RCC_AHB1PeriphClockCmd
        48   -> RCC_APB2PeriphClockCmd
        48   -> TIM_Cmd
        48   -> TIM_CtrlPWMOutputs
        48   -> TIM_OC1Init
        48   -> TIM_OC2Init
        48   -> TIM_OC3Init
        48   -> TIM_TimeBaseInit
       0   read_Encoder


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
     190  TIM1_EncoderInterface_Init
     222  TIM2_EncoderInterface_Init
     188  TIM3_EncoderInterface_Init
     188  TIM4_EncoderInterface_Init
     232  TM1_PWM_Init
     234  TM8_PWM_Init
      54  read_Encoder

 
 1'348 bytes in section .text
 
 1'348 bytes of CODE memory

Errors: none
Warnings: none
