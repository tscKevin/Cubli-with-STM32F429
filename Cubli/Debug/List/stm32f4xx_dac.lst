###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.2.214/W32 for ARM         10/Jul/2020  15:12:05
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c
#    Command line =
#        -f C:\Users\Evan\AppData\Local\Temp\EWE20C.tmp
#        (E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c
#        -D USE_STDPERIPH_DRIVER -D STM32F429_439xx -lC
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List
#        -o
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "D:\IAR
#        Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\iar\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\User\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\User\src\
#        -Ol --use_c++_inline -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List\stm32f4xx_dac.lst
#    Object file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj\stm32f4xx_dac.o
#
###############################################################################

E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_dac.c
      4            * @author  MCD Application Team
      5            * @version V1.8.0
      6            * @date    04-November-2016
      7             * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Digital-to-Analog Converter (DAC) peripheral: 
      9            *           + DAC channels configuration: trigger, output buffer, data format
     10            *           + DMA management      
     11            *           + Interrupts and flags management
     12            *
     13           @verbatim      
     14           ===============================================================================
     15                                ##### DAC Peripheral features #####
     16           ===============================================================================
     17              [..]        
     18                *** DAC Channels ***
     19                ====================  
     20              [..]  
     21              The device integrates two 12-bit Digital Analog Converters that can 
     22              be used independently or simultaneously (dual mode):
     23                (#) DAC channel1 with DAC_OUT1 (PA4) as output
     24                (#) DAC channel2 with DAC_OUT2 (PA5) as output
     25            
     26                *** DAC Triggers ***
     27                ====================
     28              [..]
     29              Digital to Analog conversion can be non-triggered using DAC_Trigger_None
     30              and DAC_OUT1/DAC_OUT2 is available once writing to DHRx register 
     31              using DAC_SetChannel1Data() / DAC_SetChannel2Data() functions.
     32              [..] 
     33              Digital to Analog conversion can be triggered by:
     34                (#) External event: EXTI Line 9 (any GPIOx_Pin9) using DAC_Trigger_Ext_IT9.
     35                    The used pin (GPIOx_Pin9) must be configured in input mode.
     36            
     37                (#) Timers TRGO: TIM2, TIM4, TIM5, TIM6, TIM7 and TIM8 
     38                    (DAC_Trigger_T2_TRGO, DAC_Trigger_T4_TRGO...)
     39                    The timer TRGO event should be selected using TIM_SelectOutputTrigger()
     40            
     41                (#) Software using DAC_Trigger_Software
     42            
     43                *** DAC Buffer mode feature ***
     44                =============================== 
     45                [..] 
     46                Each DAC channel integrates an output buffer that can be used to 
     47                reduce the output impedance, and to drive external loads directly
     48                without having to add an external operational amplifier.
     49                To enable, the output buffer use  
     50                DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
     51                [..]           
     52                (@) Refer to the device datasheet for more details about output 
     53                    impedance value with and without output buffer.
     54                      
     55                 *** DAC wave generation feature ***
     56                 =================================== 
     57                 [..]     
     58                 Both DAC channels can be used to generate
     59                   (#) Noise wave using DAC_WaveGeneration_Noise
     60                   (#) Triangle wave using DAC_WaveGeneration_Triangle
     61                    
     62                    -@-  Wave generation can be disabled using DAC_WaveGeneration_None
     63            
     64                 *** DAC data format ***
     65                 =======================
     66                 [..]   
     67                 The DAC data format can be:
     68                   (#) 8-bit right alignment using DAC_Align_8b_R
     69                   (#) 12-bit left alignment using DAC_Align_12b_L
     70                   (#) 12-bit right alignment using DAC_Align_12b_R
     71            
     72                 *** DAC data value to voltage correspondence ***  
     73                 ================================================ 
     74                 [..] 
     75                 The analog output voltage on each DAC channel pin is determined
     76                 by the following equation: 
     77                 DAC_OUTx = VREF+ * DOR / 4095
     78                 with  DOR is the Data Output Register
     79                    VEF+ is the input voltage reference (refer to the device datasheet)
     80                  e.g. To set DAC_OUT1 to 0.7V, use
     81                    DAC_SetChannel1Data(DAC_Align_12b_R, 868);
     82                    Assuming that VREF+ = 3.3V, DAC_OUT1 = (3.3 * 868) / 4095 = 0.7V
     83            
     84                 *** DMA requests  ***
     85                 =====================
     86                 [..]    
     87                 A DMA1 request can be generated when an external trigger (but not
     88                 a software trigger) occurs if DMA1 requests are enabled using
     89                 DAC_DMACmd()
     90                 [..]
     91                 DMA1 requests are mapped as following:
     92                   (#) DAC channel1 : mapped on DMA1 Stream5 channel7 which must be 
     93                       already configured
     94                   (#) DAC channel2 : mapped on DMA1 Stream6 channel7 which must be 
     95                       already configured
     96            
     97                
     98                                ##### How to use this driver #####
     99           ===============================================================================
    100              [..]          
    101                (+) DAC APB clock must be enabled to get write access to DAC
    102                    registers using
    103                    RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE)
    104                (+) Configure DAC_OUTx (DAC_OUT1: PA4, DAC_OUT2: PA5) in analog mode.
    105                (+) Configure the DAC channel using DAC_Init() function
    106                (+) Enable the DAC channel using DAC_Cmd() function
    107             
    108           @endverbatim    
    109            ******************************************************************************
    110            * @attention
    111            *
    112            * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
    113            *
    114            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    115            * You may not use this file except in compliance with the License.
    116            * You may obtain a copy of the License at:
    117            *
    118            *        http://www.st.com/software_license_agreement_liberty_v2
    119            *
    120            * Unless required by applicable law or agreed to in writing, software 
    121            * distributed under the License is distributed on an "AS IS" BASIS, 
    122            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    123            * See the License for the specific language governing permissions and
    124            * limitations under the License.
    125            *
    126            ******************************************************************************  
    127            */ 
    128          
    129          
    130          /* Includes ------------------------------------------------------------------*/
    131          #include "stm32f4xx_dac.h"
    132          #include "stm32f4xx_rcc.h"
    133          
    134          /** @addtogroup STM32F4xx_StdPeriph_Driver
    135            * @{
    136            */
    137          
    138          /** @defgroup DAC 
    139            * @brief DAC driver modules
    140            * @{
    141            */ 
    142          
    143          /* Private typedef -----------------------------------------------------------*/
    144          /* Private define ------------------------------------------------------------*/
    145          
    146          /* CR register Mask */
    147          #define CR_CLEAR_MASK              ((uint32_t)0x00000FFE)
    148          
    149          /* DAC Dual Channels SWTRIG masks */
    150          #define DUAL_SWTRIG_SET            ((uint32_t)0x00000003)
    151          #define DUAL_SWTRIG_RESET          ((uint32_t)0xFFFFFFFC)
    152          
    153          /* DHR registers offsets */
    154          #define DHR12R1_OFFSET             ((uint32_t)0x00000008)
    155          #define DHR12R2_OFFSET             ((uint32_t)0x00000014)
    156          #define DHR12RD_OFFSET             ((uint32_t)0x00000020)
    157          
    158          /* DOR register offset */
    159          #define DOR_OFFSET                 ((uint32_t)0x0000002C)
    160          
    161          /* Private macro -------------------------------------------------------------*/
    162          /* Private variables ---------------------------------------------------------*/
    163          /* Private function prototypes -----------------------------------------------*/
    164          /* Private functions ---------------------------------------------------------*/
    165          
    166          /** @defgroup DAC_Private_Functions
    167            * @{
    168            */
    169          
    170          /** @defgroup DAC_Group1 DAC channels configuration
    171           *  @brief   DAC channels configuration: trigger, output buffer, data format 
    172           *
    173          @verbatim   
    174           ===============================================================================
    175             ##### DAC channels configuration: trigger, output buffer, data format #####
    176           ===============================================================================  
    177          
    178          @endverbatim
    179            * @{
    180            */
    181          
    182          /**
    183            * @brief  Deinitializes the DAC peripheral registers to their default reset values.
    184            * @param  None
    185            * @retval None
    186            */

   \                                 In section .text, align 2, keep-with-next
    187          void DAC_DeInit(void)
    188          {
   \                     DAC_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    189            /* Enable DAC reset state */
    190            RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0xF05F 0x5000      MOVS     R0,#+536870912
   \        0x8   0x....'....        BL       RCC_APB1PeriphResetCmd
    191            /* Release DAC from reset state */
    192            RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0xF05F 0x5000      MOVS     R0,#+536870912
   \       0x12   0x....'....        BL       RCC_APB1PeriphResetCmd
    193          }
   \       0x16   0xBD01             POP      {R0,PC}          ;; return
    194          
    195          /**
    196            * @brief  Initializes the DAC peripheral according to the specified parameters
    197            *         in the DAC_InitStruct.
    198            * @param  DAC_Channel: the selected DAC channel. 
    199            *          This parameter can be one of the following values:
    200            *            @arg DAC_Channel_1: DAC Channel1 selected
    201            *            @arg DAC_Channel_2: DAC Channel2 selected
    202            * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that contains
    203            *         the configuration information for the  specified DAC channel.
    204            * @retval None
    205            */

   \                                 In section .text, align 2, keep-with-next
    206          void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
    207          {
   \                     DAC_Init: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    208            uint32_t tmpreg1 = 0, tmpreg2 = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2200             MOVS     R2,#+0
    209          
    210            /* Check the DAC parameters */
    211            assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
    212            assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
    213            assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
    214            assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
    215          
    216          /*---------------------------- DAC CR Configuration --------------------------*/
    217            /* Get the DAC CR value */
    218            tmpreg1 = DAC->CR;
   \        0x6   0x....             LDR.N    R5,??DataTable15  ;; 0x40007400
   \        0x8   0x682B             LDR      R3,[R5, #+0]
    219            /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
    220            tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
   \        0xA   0xF640 0x72FE      MOVW     R2,#+4094
   \        0xE   0x4082             LSLS     R2,R2,R0
   \       0x10   0x4393             BICS     R3,R3,R2
    221            /* Configure for the selected DAC channel: buffer output, trigger, 
    222               wave generation, mask/amplitude for wave generation */
    223            /* Set TSELx and TENx bits according to DAC_Trigger value */
    224            /* Set WAVEx bits according to DAC_WaveGeneration value */
    225            /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
    226            /* Set BOFFx bit according to DAC_OutputBuffer value */   
    227            tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
    228                       DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
    229                       DAC_InitStruct->DAC_OutputBuffer);
   \       0x12   0x680C             LDR      R4,[R1, #+0]
   \       0x14   0x684A             LDR      R2,[R1, #+4]
   \       0x16   0x4314             ORRS     R4,R2,R4
   \       0x18   0x688A             LDR      R2,[R1, #+8]
   \       0x1A   0x4314             ORRS     R4,R2,R4
   \       0x1C   0x68C9             LDR      R1,[R1, #+12]
   \       0x1E   0x430C             ORRS     R4,R1,R4
    230            /* Calculate CR register value depending on DAC_Channel */
    231            tmpreg1 |= tmpreg2 << DAC_Channel;
   \       0x20   0xFA14 0xF000      LSLS     R0,R4,R0
   \       0x24   0x4318             ORRS     R0,R0,R3
    232            /* Write to DAC CR */
    233            DAC->CR = tmpreg1;
   \       0x26   0x6028             STR      R0,[R5, #+0]
    234          }
   \       0x28   0xBC30             POP      {R4,R5}
   \       0x2A   0x4770             BX       LR               ;; return
    235          
    236          /**
    237            * @brief  Fills each DAC_InitStruct member with its default value.
    238            * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure which will 
    239            *         be initialized.
    240            * @retval None
    241            */

   \                                 In section .text, align 2, keep-with-next
    242          void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
    243          {
    244          /*--------------- Reset DAC init structure parameters values -----------------*/
    245            /* Initialize the DAC_Trigger member */
    246            DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
   \                     DAC_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    247            /* Initialize the DAC_WaveGeneration member */
    248            DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6041             STR      R1,[R0, #+4]
    249            /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
    250            DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6081             STR      R1,[R0, #+8]
    251            /* Initialize the DAC_OutputBuffer member */
    252            DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x60C1             STR      R1,[R0, #+12]
    253          }
   \       0x10   0x4770             BX       LR               ;; return
    254          
    255          /**
    256            * @brief  Enables or disables the specified DAC channel.
    257            * @param  DAC_Channel: The selected DAC channel. 
    258            *          This parameter can be one of the following values:
    259            *            @arg DAC_Channel_1: DAC Channel1 selected
    260            *            @arg DAC_Channel_2: DAC Channel2 selected
    261            * @param  NewState: new state of the DAC channel. 
    262            *          This parameter can be: ENABLE or DISABLE.
    263            * @note   When the DAC channel is enabled the trigger source can no more be modified.
    264            * @retval None
    265            */

   \                                 In section .text, align 2, keep-with-next
    266          void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
    267          {
    268            /* Check the parameters */
    269            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    270            assert_param(IS_FUNCTIONAL_STATE(NewState));
    271          
    272            if (NewState != DISABLE)
   \                     DAC_Cmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD007             BEQ.N    ??DAC_Cmd_0
    273            {
    274              /* Enable the selected DAC channel */
    275              DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
   \        0x6   0x....             LDR.N    R1,??DataTable15  ;; 0x40007400
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0x2301             MOVS     R3,#+1
   \        0xC   0xFA13 0xF000      LSLS     R0,R3,R0
   \       0x10   0x4310             ORRS     R0,R0,R2
   \       0x12   0x6008             STR      R0,[R1, #+0]
   \       0x14   0xE007             B.N      ??DAC_Cmd_1
    276            }
    277            else
    278            {
    279              /* Disable the selected DAC channel */
    280              DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
   \                     ??DAC_Cmd_0: (+1)
   \       0x16   0x....             LDR.N    R1,??DataTable15  ;; 0x40007400
   \       0x18   0x680A             LDR      R2,[R1, #+0]
   \       0x1A   0x2301             MOVS     R3,#+1
   \       0x1C   0xFA13 0xF000      LSLS     R0,R3,R0
   \       0x20   0xEA32 0x0000      BICS     R0,R2,R0
   \       0x24   0x6008             STR      R0,[R1, #+0]
    281            }
    282          }
   \                     ??DAC_Cmd_1: (+1)
   \       0x26   0x4770             BX       LR               ;; return
    283          
    284          /**
    285            * @brief  Enables or disables the selected DAC channel software trigger.
    286            * @param  DAC_Channel: The selected DAC channel. 
    287            *          This parameter can be one of the following values:
    288            *            @arg DAC_Channel_1: DAC Channel1 selected
    289            *            @arg DAC_Channel_2: DAC Channel2 selected
    290            * @param  NewState: new state of the selected DAC channel software trigger.
    291            *          This parameter can be: ENABLE or DISABLE.
    292            * @retval None
    293            */

   \                                 In section .text, align 2, keep-with-next
    294          void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
    295          {
    296            /* Check the parameters */
    297            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    298            assert_param(IS_FUNCTIONAL_STATE(NewState));
    299          
    300            if (NewState != DISABLE)
   \                     DAC_SoftwareTriggerCmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD008             BEQ.N    ??DAC_SoftwareTriggerCmd_0
    301            {
    302              /* Enable software trigger for the selected DAC channel */
    303              DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
   \        0x6   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40007404
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0x2301             MOVS     R3,#+1
   \        0xC   0x0900             LSRS     R0,R0,#+4
   \        0xE   0xFA13 0xF000      LSLS     R0,R3,R0
   \       0x12   0x4310             ORRS     R0,R0,R2
   \       0x14   0x6008             STR      R0,[R1, #+0]
   \       0x16   0xE008             B.N      ??DAC_SoftwareTriggerCmd_1
    304            }
    305            else
    306            {
    307              /* Disable software trigger for the selected DAC channel */
    308              DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
   \                     ??DAC_SoftwareTriggerCmd_0: (+1)
   \       0x18   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40007404
   \       0x1A   0x680A             LDR      R2,[R1, #+0]
   \       0x1C   0x2301             MOVS     R3,#+1
   \       0x1E   0x0900             LSRS     R0,R0,#+4
   \       0x20   0xFA13 0xF000      LSLS     R0,R3,R0
   \       0x24   0xEA32 0x0000      BICS     R0,R2,R0
   \       0x28   0x6008             STR      R0,[R1, #+0]
    309            }
    310          }
   \                     ??DAC_SoftwareTriggerCmd_1: (+1)
   \       0x2A   0x4770             BX       LR               ;; return
    311          
    312          /**
    313            * @brief  Enables or disables simultaneously the two DAC channels software triggers.
    314            * @param  NewState: new state of the DAC channels software triggers.
    315            *          This parameter can be: ENABLE or DISABLE.
    316            * @retval None
    317            */

   \                                 In section .text, align 2, keep-with-next
    318          void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
    319          {
    320            /* Check the parameters */
    321            assert_param(IS_FUNCTIONAL_STATE(NewState));
    322          
    323            if (NewState != DISABLE)
   \                     DAC_DualSoftwareTriggerCmd: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD005             BEQ.N    ??DAC_DualSoftwareTriggerCmd_0
    324            {
    325              /* Enable software trigger for both DAC channels */
    326              DAC->SWTRIGR |= DUAL_SWTRIG_SET;
   \        0x6   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40007404
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0xF051 0x0103      ORRS     R1,R1,#0x3
   \        0xE   0x6001             STR      R1,[R0, #+0]
   \       0x10   0xE004             B.N      ??DAC_DualSoftwareTriggerCmd_1
    327            }
    328            else
    329            {
    330              /* Disable software trigger for both DAC channels */
    331              DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
   \                     ??DAC_DualSoftwareTriggerCmd_0: (+1)
   \       0x12   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40007404
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0x0889             LSRS     R1,R1,#+2
   \       0x18   0x0089             LSLS     R1,R1,#+2
   \       0x1A   0x6001             STR      R1,[R0, #+0]
    332            }
    333          }
   \                     ??DAC_DualSoftwareTriggerCmd_1: (+1)
   \       0x1C   0x4770             BX       LR               ;; return
    334          
    335          /**
    336            * @brief  Enables or disables the selected DAC channel wave generation.
    337            * @param  DAC_Channel: The selected DAC channel. 
    338            *          This parameter can be one of the following values:
    339            *            @arg DAC_Channel_1: DAC Channel1 selected
    340            *            @arg DAC_Channel_2: DAC Channel2 selected
    341            * @param  DAC_Wave: specifies the wave type to enable or disable.
    342            *          This parameter can be one of the following values:
    343            *            @arg DAC_Wave_Noise: noise wave generation
    344            *            @arg DAC_Wave_Triangle: triangle wave generation
    345            * @param  NewState: new state of the selected DAC channel wave generation.
    346            *          This parameter can be: ENABLE or DISABLE.  
    347            * @retval None
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
    350          {
    351            /* Check the parameters */
    352            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    353            assert_param(IS_DAC_WAVE(DAC_Wave)); 
    354            assert_param(IS_FUNCTIONAL_STATE(NewState));
    355          
    356            if (NewState != DISABLE)
   \                     DAC_WaveGenerationCmd: (+1)
   \        0x0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD006             BEQ.N    ??DAC_WaveGenerationCmd_0
    357            {
    358              /* Enable the selected wave generation for the selected DAC channel */
    359              DAC->CR |= DAC_Wave << DAC_Channel;
   \        0x6   0x....             LDR.N    R2,??DataTable15  ;; 0x40007400
   \        0x8   0x6813             LDR      R3,[R2, #+0]
   \        0xA   0xFA11 0xF000      LSLS     R0,R1,R0
   \        0xE   0x4318             ORRS     R0,R0,R3
   \       0x10   0x6010             STR      R0,[R2, #+0]
   \       0x12   0xE006             B.N      ??DAC_WaveGenerationCmd_1
    360            }
    361            else
    362            {
    363              /* Disable the selected wave generation for the selected DAC channel */
    364              DAC->CR &= ~(DAC_Wave << DAC_Channel);
   \                     ??DAC_WaveGenerationCmd_0: (+1)
   \       0x14   0x....             LDR.N    R2,??DataTable15  ;; 0x40007400
   \       0x16   0x6813             LDR      R3,[R2, #+0]
   \       0x18   0xFA11 0xF000      LSLS     R0,R1,R0
   \       0x1C   0xEA33 0x0000      BICS     R0,R3,R0
   \       0x20   0x6010             STR      R0,[R2, #+0]
    365            }
    366          }
   \                     ??DAC_WaveGenerationCmd_1: (+1)
   \       0x22   0x4770             BX       LR               ;; return
    367          
    368          /**
    369            * @brief  Set the specified data holding register value for DAC channel1.
    370            * @param  DAC_Align: Specifies the data alignment for DAC channel1.
    371            *          This parameter can be one of the following values:
    372            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    373            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    374            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    375            * @param  Data: Data to be loaded in the selected data holding register.
    376            * @retval None
    377            */

   \                                 In section .text, align 2, keep-with-next
    378          void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
    379          {  
   \                     DAC_SetChannel1Data: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
    380            __IO uint32_t tmp = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x9200             STR      R2,[SP, #+0]
    381            
    382            /* Check the parameters */
    383            assert_param(IS_DAC_ALIGN(DAC_Align));
    384            assert_param(IS_DAC_DATA(Data));
    385            
    386            tmp = (uint32_t)DAC_BASE; 
   \        0x6   0x....             LDR.N    R2,??DataTable15  ;; 0x40007400
   \        0x8   0x9200             STR      R2,[SP, #+0]
    387            tmp += DHR12R1_OFFSET + DAC_Align;
   \        0xA   0x9A00             LDR      R2,[SP, #+0]
   \        0xC   0x3008             ADDS     R0,R0,#+8
   \        0xE   0x1880             ADDS     R0,R0,R2
   \       0x10   0x9000             STR      R0,[SP, #+0]
    388          
    389            /* Set the DAC channel1 selected data holding register */
    390            *(__IO uint32_t *) tmp = Data;
   \       0x12   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \       0x14   0x9800             LDR      R0,[SP, #+0]
   \       0x16   0x6001             STR      R1,[R0, #+0]
    391          }
   \       0x18   0xB001             ADD      SP,SP,#+4
   \       0x1A   0x4770             BX       LR               ;; return
    392          
    393          /**
    394            * @brief  Set the specified data holding register value for DAC channel2.
    395            * @param  DAC_Align: Specifies the data alignment for DAC channel2.
    396            *          This parameter can be one of the following values:
    397            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    398            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    399            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    400            * @param  Data: Data to be loaded in the selected data holding register.
    401            * @retval None
    402            */

   \                                 In section .text, align 2, keep-with-next
    403          void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
    404          {
   \                     DAC_SetChannel2Data: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
    405            __IO uint32_t tmp = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x9200             STR      R2,[SP, #+0]
    406          
    407            /* Check the parameters */
    408            assert_param(IS_DAC_ALIGN(DAC_Align));
    409            assert_param(IS_DAC_DATA(Data));
    410            
    411            tmp = (uint32_t)DAC_BASE;
   \        0x6   0x....             LDR.N    R2,??DataTable15  ;; 0x40007400
   \        0x8   0x9200             STR      R2,[SP, #+0]
    412            tmp += DHR12R2_OFFSET + DAC_Align;
   \        0xA   0x9A00             LDR      R2,[SP, #+0]
   \        0xC   0x3014             ADDS     R0,R0,#+20
   \        0xE   0x1880             ADDS     R0,R0,R2
   \       0x10   0x9000             STR      R0,[SP, #+0]
    413          
    414            /* Set the DAC channel2 selected data holding register */
    415            *(__IO uint32_t *)tmp = Data;
   \       0x12   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \       0x14   0x9800             LDR      R0,[SP, #+0]
   \       0x16   0x6001             STR      R1,[R0, #+0]
    416          }
   \       0x18   0xB001             ADD      SP,SP,#+4
   \       0x1A   0x4770             BX       LR               ;; return
    417          
    418          /**
    419            * @brief  Set the specified data holding register value for dual channel DAC.
    420            * @param  DAC_Align: Specifies the data alignment for dual channel DAC.
    421            *          This parameter can be one of the following values:
    422            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    423            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    424            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    425            * @param  Data2: Data for DAC Channel2 to be loaded in the selected data holding register.
    426            * @param  Data1: Data for DAC Channel1 to be loaded in the selected data  holding register.
    427            * @note   In dual mode, a unique register access is required to write in both
    428            *          DAC channels at the same time.
    429            * @retval None
    430            */

   \                                 In section .text, align 2, keep-with-next
    431          void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
    432          {
    433            uint32_t data = 0, tmp = 0;
   \                     DAC_SetDualChannelData: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x2300             MOVS     R3,#+0
    434            
    435            /* Check the parameters */
    436            assert_param(IS_DAC_ALIGN(DAC_Align));
    437            assert_param(IS_DAC_DATA(Data1));
    438            assert_param(IS_DAC_DATA(Data2));
    439            
    440            /* Calculate and set dual DAC data holding register value */
    441            if (DAC_Align == DAC_Align_8b_R)
   \        0x4   0x2808             CMP      R0,#+8
   \        0x6   0xD104             BNE.N    ??DAC_SetDualChannelData_0
    442            {
    443              data = ((uint32_t)Data2 << 8) | Data1; 
   \        0x8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \        0xA   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \        0xC   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \       0x10   0xE003             B.N      ??DAC_SetDualChannelData_1
    444            }
    445            else
    446            {
    447              data = ((uint32_t)Data2 << 16) | Data1;
   \                     ??DAC_SetDualChannelData_0: (+1)
   \       0x12   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \       0x14   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \       0x16   0xEA52 0x4201      ORRS     R2,R2,R1, LSL #+16
    448            }
    449            
    450            tmp = (uint32_t)DAC_BASE;
   \                     ??DAC_SetDualChannelData_1: (+1)
   \       0x1A   0x....             LDR.N    R1,??DataTable15  ;; 0x40007400
    451            tmp += DHR12RD_OFFSET + DAC_Align;
   \       0x1C   0x3020             ADDS     R0,R0,#+32
   \       0x1E   0x1840             ADDS     R0,R0,R1
    452          
    453            /* Set the dual DAC selected data holding register */
    454            *(__IO uint32_t *)tmp = data;
   \       0x20   0x6002             STR      R2,[R0, #+0]
    455          }
   \       0x22   0x4770             BX       LR               ;; return
    456          
    457          /**
    458            * @brief  Returns the last data output value of the selected DAC channel.
    459            * @param  DAC_Channel: The selected DAC channel. 
    460            *          This parameter can be one of the following values:
    461            *            @arg DAC_Channel_1: DAC Channel1 selected
    462            *            @arg DAC_Channel_2: DAC Channel2 selected
    463            * @retval The selected DAC channel data output value.
    464            */

   \                                 In section .text, align 2, keep-with-next
    465          uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
    466          {
   \                     DAC_GetDataOutputValue: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
    467            __IO uint32_t tmp = 0;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x9100             STR      R1,[SP, #+0]
    468            
    469            /* Check the parameters */
    470            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    471            
    472            tmp = (uint32_t) DAC_BASE ;
   \        0x6   0x....             LDR.N    R1,??DataTable15  ;; 0x40007400
   \        0x8   0x9100             STR      R1,[SP, #+0]
    473            tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
   \        0xA   0x9900             LDR      R1,[SP, #+0]
   \        0xC   0x0880             LSRS     R0,R0,#+2
   \        0xE   0x302C             ADDS     R0,R0,#+44
   \       0x10   0x1840             ADDS     R0,R0,R1
   \       0x12   0x9000             STR      R0,[SP, #+0]
    474            
    475            /* Returns the DAC channel data output register value */
    476            return (uint16_t) (*(__IO uint32_t*) tmp);
   \       0x14   0x9800             LDR      R0,[SP, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x1A   0xB001             ADD      SP,SP,#+4
   \       0x1C   0x4770             BX       LR               ;; return
    477          }
    478          /**
    479            * @}
    480            */
    481          
    482          /** @defgroup DAC_Group2 DMA management functions
    483           *  @brief   DMA management functions
    484           *
    485          @verbatim   
    486           ===============================================================================
    487                                 ##### DMA management functions #####
    488           ===============================================================================  
    489          
    490          @endverbatim
    491            * @{
    492            */
    493          
    494          /**
    495            * @brief  Enables or disables the specified DAC channel DMA request.
    496            * @note   When enabled DMA1 is generated when an external trigger (EXTI Line9,
    497            *         TIM2, TIM4, TIM5, TIM6, TIM7 or TIM8  but not a software trigger) occurs.
    498            * @param  DAC_Channel: The selected DAC channel. 
    499            *          This parameter can be one of the following values:
    500            *            @arg DAC_Channel_1: DAC Channel1 selected
    501            *            @arg DAC_Channel_2: DAC Channel2 selected
    502            * @param  NewState: new state of the selected DAC channel DMA request.
    503            *          This parameter can be: ENABLE or DISABLE.
    504            * @note   The DAC channel1 is mapped on DMA1 Stream 5 channel7 which must be
    505            *          already configured.
    506            * @note   The DAC channel2 is mapped on DMA1 Stream 6 channel7 which must be
    507            *          already configured.    
    508            * @retval None
    509            */

   \                                 In section .text, align 2, keep-with-next
    510          void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
    511          {
    512            /* Check the parameters */
    513            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    514            assert_param(IS_FUNCTIONAL_STATE(NewState));
    515          
    516            if (NewState != DISABLE)
   \                     DAC_DMACmd: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD008             BEQ.N    ??DAC_DMACmd_0
    517            {
    518              /* Enable the selected DAC channel DMA request */
    519              DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
   \        0x6   0x....             LDR.N    R1,??DataTable15  ;; 0x40007400
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0xF44F 0x5380      MOV      R3,#+4096
   \        0xE   0xFA13 0xF000      LSLS     R0,R3,R0
   \       0x12   0x4310             ORRS     R0,R0,R2
   \       0x14   0x6008             STR      R0,[R1, #+0]
   \       0x16   0xE008             B.N      ??DAC_DMACmd_1
    520            }
    521            else
    522            {
    523              /* Disable the selected DAC channel DMA request */
    524              DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
   \                     ??DAC_DMACmd_0: (+1)
   \       0x18   0x....             LDR.N    R1,??DataTable15  ;; 0x40007400
   \       0x1A   0x680A             LDR      R2,[R1, #+0]
   \       0x1C   0xF44F 0x5380      MOV      R3,#+4096
   \       0x20   0xFA13 0xF000      LSLS     R0,R3,R0
   \       0x24   0xEA32 0x0000      BICS     R0,R2,R0
   \       0x28   0x6008             STR      R0,[R1, #+0]
    525            }
    526          }
   \                     ??DAC_DMACmd_1: (+1)
   \       0x2A   0x4770             BX       LR               ;; return
    527          /**
    528            * @}
    529            */
    530          
    531          /** @defgroup DAC_Group3 Interrupts and flags management functions
    532           *  @brief   Interrupts and flags management functions
    533           *
    534          @verbatim   
    535           ===============================================================================
    536                       ##### Interrupts and flags management functions #####
    537           ===============================================================================  
    538          
    539          @endverbatim
    540            * @{
    541            */
    542          
    543          /**
    544            * @brief  Enables or disables the specified DAC interrupts.
    545            * @param  DAC_Channel: The selected DAC channel. 
    546            *          This parameter can be one of the following values:
    547            *            @arg DAC_Channel_1: DAC Channel1 selected
    548            *            @arg DAC_Channel_2: DAC Channel2 selected
    549            * @param  DAC_IT: specifies the DAC interrupt sources to be enabled or disabled. 
    550            *          This parameter can be the following values:
    551            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
    552            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    553            *         acknowledgement for the first external trigger is received (first request).
    554            * @param  NewState: new state of the specified DAC interrupts.
    555            *          This parameter can be: ENABLE or DISABLE.
    556            * @retval None
    557            */ 

   \                                 In section .text, align 2, keep-with-next
    558          void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
    559          {
    560            /* Check the parameters */
    561            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    562            assert_param(IS_FUNCTIONAL_STATE(NewState));
    563            assert_param(IS_DAC_IT(DAC_IT)); 
    564          
    565            if (NewState != DISABLE)
   \                     DAC_ITConfig: (+1)
   \        0x0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD006             BEQ.N    ??DAC_ITConfig_0
    566            {
    567              /* Enable the selected DAC interrupts */
    568              DAC->CR |=  (DAC_IT << DAC_Channel);
   \        0x6   0x....             LDR.N    R2,??DataTable15  ;; 0x40007400
   \        0x8   0x6813             LDR      R3,[R2, #+0]
   \        0xA   0xFA11 0xF000      LSLS     R0,R1,R0
   \        0xE   0x4318             ORRS     R0,R0,R3
   \       0x10   0x6010             STR      R0,[R2, #+0]
   \       0x12   0xE006             B.N      ??DAC_ITConfig_1
    569            }
    570            else
    571            {
    572              /* Disable the selected DAC interrupts */
    573              DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
   \                     ??DAC_ITConfig_0: (+1)
   \       0x14   0x....             LDR.N    R2,??DataTable15  ;; 0x40007400
   \       0x16   0x6813             LDR      R3,[R2, #+0]
   \       0x18   0xFA11 0xF000      LSLS     R0,R1,R0
   \       0x1C   0xEA33 0x0000      BICS     R0,R3,R0
   \       0x20   0x6010             STR      R0,[R2, #+0]
    574            }
    575          }
   \                     ??DAC_ITConfig_1: (+1)
   \       0x22   0x4770             BX       LR               ;; return
    576          
    577          /**
    578            * @brief  Checks whether the specified DAC flag is set or not.
    579            * @param  DAC_Channel: The selected DAC channel. 
    580            *          This parameter can be one of the following values:
    581            *            @arg DAC_Channel_1: DAC Channel1 selected
    582            *            @arg DAC_Channel_2: DAC Channel2 selected
    583            * @param  DAC_FLAG: specifies the flag to check. 
    584            *          This parameter can be only of the following value:
    585            *            @arg DAC_FLAG_DMAUDR: DMA underrun flag
    586            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    587            *         acknowledgement for the first external trigger is received (first request).
    588            * @retval The new state of DAC_FLAG (SET or RESET).
    589            */

   \                                 In section .text, align 2, keep-with-next
    590          FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
    591          {
    592            FlagStatus bitstatus = RESET;
   \                     DAC_GetFlagStatus: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
    593            /* Check the parameters */
    594            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    595            assert_param(IS_DAC_FLAG(DAC_FLAG));
    596          
    597            /* Check the status of the specified DAC flag */
    598            if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
   \        0x2   0x....             LDR.N    R2,??DataTable15_2  ;; 0x40007434
   \        0x4   0x6812             LDR      R2,[R2, #+0]
   \        0x6   0xFA11 0xF000      LSLS     R0,R1,R0
   \        0xA   0x4202             TST      R2,R0
   \        0xC   0xD001             BEQ.N    ??DAC_GetFlagStatus_0
    599            {
    600              /* DAC_FLAG is set */
    601              bitstatus = SET;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xE000             B.N      ??DAC_GetFlagStatus_1
    602            }
    603            else
    604            {
    605              /* DAC_FLAG is reset */
    606              bitstatus = RESET;
   \                     ??DAC_GetFlagStatus_0: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
    607            }
    608            /* Return the DAC_FLAG status */
    609            return  bitstatus;
   \                     ??DAC_GetFlagStatus_1: (+1)
   \       0x14   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x16   0x4770             BX       LR               ;; return
    610          }
    611          
    612          /**
    613            * @brief  Clears the DAC channel's pending flags.
    614            * @param  DAC_Channel: The selected DAC channel. 
    615            *          This parameter can be one of the following values:
    616            *            @arg DAC_Channel_1: DAC Channel1 selected
    617            *            @arg DAC_Channel_2: DAC Channel2 selected
    618            * @param  DAC_FLAG: specifies the flag to clear. 
    619            *          This parameter can be of the following value:
    620            *            @arg DAC_FLAG_DMAUDR: DMA underrun flag 
    621            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    622            *         acknowledgement for the first external trigger is received (first request).                           
    623            * @retval None
    624            */

   \                                 In section .text, align 2, keep-with-next
    625          void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
    626          {
    627            /* Check the parameters */
    628            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    629            assert_param(IS_DAC_FLAG(DAC_FLAG));
    630          
    631            /* Clear the selected DAC flags */
    632            DAC->SR = (DAC_FLAG << DAC_Channel);
   \                     DAC_ClearFlag: (+1)
   \        0x0   0xFA11 0xF000      LSLS     R0,R1,R0
   \        0x4   0x....             LDR.N    R1,??DataTable15_2  ;; 0x40007434
   \        0x6   0x6008             STR      R0,[R1, #+0]
    633          }
   \        0x8   0x4770             BX       LR               ;; return
    634          
    635          /**
    636            * @brief  Checks whether the specified DAC interrupt has occurred or not.
    637            * @param  DAC_Channel: The selected DAC channel. 
    638            *          This parameter can be one of the following values:
    639            *            @arg DAC_Channel_1: DAC Channel1 selected
    640            *            @arg DAC_Channel_2: DAC Channel2 selected
    641            * @param  DAC_IT: specifies the DAC interrupt source to check. 
    642            *          This parameter can be the following values:
    643            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
    644            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    645            *         acknowledgement for the first external trigger is received (first request).
    646            * @retval The new state of DAC_IT (SET or RESET).
    647            */

   \                                 In section .text, align 2, keep-with-next
    648          ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
    649          {
    650            ITStatus bitstatus = RESET;
   \                     DAC_GetITStatus: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
    651            uint32_t enablestatus = 0;
   \        0x2   0x2200             MOVS     R2,#+0
    652            
    653            /* Check the parameters */
    654            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    655            assert_param(IS_DAC_IT(DAC_IT));
    656          
    657            /* Get the DAC_IT enable bit status */
    658            enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
   \        0x4   0x....             LDR.N    R2,??DataTable15  ;; 0x40007400
   \        0x6   0x6812             LDR      R2,[R2, #+0]
   \        0x8   0xFA11 0xF300      LSLS     R3,R1,R0
   \        0xC   0x401A             ANDS     R2,R3,R2
    659            
    660            /* Check the status of the specified DAC interrupt */
    661            if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
   \        0xE   0x....             LDR.N    R3,??DataTable15_2  ;; 0x40007434
   \       0x10   0x681B             LDR      R3,[R3, #+0]
   \       0x12   0xFA11 0xF000      LSLS     R0,R1,R0
   \       0x16   0x4203             TST      R3,R0
   \       0x18   0xD003             BEQ.N    ??DAC_GetITStatus_0
   \       0x1A   0x2A00             CMP      R2,#+0
   \       0x1C   0xD001             BEQ.N    ??DAC_GetITStatus_0
    662            {
    663              /* DAC_IT is set */
    664              bitstatus = SET;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xE000             B.N      ??DAC_GetITStatus_1
    665            }
    666            else
    667            {
    668              /* DAC_IT is reset */
    669              bitstatus = RESET;
   \                     ??DAC_GetITStatus_0: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
    670            }
    671            /* Return the DAC_IT status */
    672            return  bitstatus;
   \                     ??DAC_GetITStatus_1: (+1)
   \       0x24   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x26   0x4770             BX       LR               ;; return
    673          }
    674          
    675          /**
    676            * @brief  Clears the DAC channel's interrupt pending bits.
    677            * @param  DAC_Channel: The selected DAC channel. 
    678            *          This parameter can be one of the following values:
    679            *            @arg DAC_Channel_1: DAC Channel1 selected
    680            *            @arg DAC_Channel_2: DAC Channel2 selected
    681            * @param  DAC_IT: specifies the DAC interrupt pending bit to clear.
    682            *          This parameter can be the following values:
    683            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                         
    684            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    685            *         acknowledgement for the first external trigger is received (first request).                           
    686            * @retval None
    687            */

   \                                 In section .text, align 2, keep-with-next
    688          void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
    689          {
    690            /* Check the parameters */
    691            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    692            assert_param(IS_DAC_IT(DAC_IT)); 
    693          
    694            /* Clear the selected DAC interrupt pending bits */
    695            DAC->SR = (DAC_IT << DAC_Channel);
   \                     DAC_ClearITPendingBit: (+1)
   \        0x0   0xFA11 0xF000      LSLS     R0,R1,R0
   \        0x4   0x....             LDR.N    R1,??DataTable15_2  ;; 0x40007434
   \        0x6   0x6008             STR      R0,[R1, #+0]
    696          }
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x4000'7400        DC32     0x40007400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x4000'7404        DC32     0x40007404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0x4000'7434        DC32     0x40007434
    697          
    698          /**
    699            * @}
    700            */
    701          
    702          /**
    703            * @}
    704            */
    705          
    706          /**
    707            * @}
    708            */
    709          
    710          /**
    711            * @}
    712            */
    713          
    714          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DAC_ClearFlag
       0   DAC_ClearITPendingBit
       0   DAC_Cmd
       0   DAC_DMACmd
       8   DAC_DeInit
         8   -> RCC_APB1PeriphResetCmd
       0   DAC_DualSoftwareTriggerCmd
       4   DAC_GetDataOutputValue
       0   DAC_GetFlagStatus
       0   DAC_GetITStatus
       0   DAC_ITConfig
       8   DAC_Init
       4   DAC_SetChannel1Data
       4   DAC_SetChannel2Data
       0   DAC_SetDualChannelData
       0   DAC_SoftwareTriggerCmd
       0   DAC_StructInit
       0   DAC_WaveGenerationCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
      10  DAC_ClearFlag
      10  DAC_ClearITPendingBit
      40  DAC_Cmd
      44  DAC_DMACmd
      24  DAC_DeInit
      30  DAC_DualSoftwareTriggerCmd
      30  DAC_GetDataOutputValue
      24  DAC_GetFlagStatus
      40  DAC_GetITStatus
      36  DAC_ITConfig
      44  DAC_Init
      28  DAC_SetChannel1Data
      28  DAC_SetChannel2Data
      36  DAC_SetDualChannelData
      44  DAC_SoftwareTriggerCmd
      18  DAC_StructInit
      36  DAC_WaveGenerationCmd

 
 534 bytes in section .text
 
 534 bytes of CODE memory

Errors: none
Warnings: none
