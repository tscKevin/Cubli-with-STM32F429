###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.2.214/W32 for ARM         10/Jul/2020  15:12:05
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp_aes.c
#    Command line =
#        -f C:\Users\Evan\AppData\Local\Temp\EWDF4A.tmp
#        (E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp_aes.c
#        -D USE_STDPERIPH_DRIVER -D STM32F429_439xx -lC
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List
#        -o
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "D:\IAR
#        Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\iar\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\User\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\User\src\
#        -Ol --use_c++_inline -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List\stm32f4xx_cryp_aes.lst
#    Object file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj\stm32f4xx_cryp_aes.o
#
###############################################################################

E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp_aes.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_cryp_aes.c
      4            * @author  MCD Application Team
      5            * @version V1.8.0
      6            * @date    04-November-2016
      7            * @brief   This file provides high level functions to encrypt and decrypt an 
      8            *          input message using AES in ECB/CBC/CTR/GCM/CCM modes.
      9            *          It uses the stm32f4xx_cryp.c/.h drivers to access the STM32F4xx CRYP
     10            *          peripheral.
     11            *          AES-ECB/CBC/CTR/GCM/CCM modes are available on STM32F437x Devices.
     12            *          For STM32F41xx Devices, only AES-ECB/CBC/CTR modes are available.
     13            *
     14          @verbatim
     15           ===================================================================
     16                            ##### How to use this driver #####
     17           ===================================================================
     18           [..]
     19             (#) Enable The CRYP controller clock using 
     20                RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_CRYP, ENABLE); function.
     21            
     22             (#) Encrypt and decrypt using AES in ECB Mode using CRYP_AES_ECB() function.
     23            
     24             (#) Encrypt and decrypt using AES in CBC Mode using CRYP_AES_CBC() function.
     25            
     26             (#) Encrypt and decrypt using AES in CTR Mode using CRYP_AES_CTR() function.
     27          
     28             (#) Encrypt and decrypt using AES in GCM Mode using CRYP_AES_GCM() function.
     29             
     30             (#) Encrypt and decrypt using AES in CCM Mode using CRYP_AES_CCM() function.
     31               
     32          @endverbatim
     33            *
     34            ******************************************************************************
     35            * @attention
     36            *
     37            * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
     38            *
     39            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     40            * You may not use this file except in compliance with the License.
     41            * You may obtain a copy of the License at:
     42            *
     43            *        http://www.st.com/software_license_agreement_liberty_v2
     44            *
     45            * Unless required by applicable law or agreed to in writing, software 
     46            * distributed under the License is distributed on an "AS IS" BASIS, 
     47            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     48            * See the License for the specific language governing permissions and
     49            * limitations under the License.
     50            *
     51            ******************************************************************************  
     52            */
     53          
     54          /* Includes ------------------------------------------------------------------*/
     55          #include "stm32f4xx_cryp.h"
     56          
     57          /** @addtogroup STM32F4xx_StdPeriph_Driver
     58            * @{
     59            */
     60          
     61          /** @defgroup CRYP 
     62            * @brief CRYP driver modules
     63            * @{
     64            */
     65          
     66          /* Private typedef -----------------------------------------------------------*/
     67          /* Private define ------------------------------------------------------------*/
     68          #define AESBUSY_TIMEOUT    ((uint32_t) 0x00010000)
     69          
     70          /* Private macro -------------------------------------------------------------*/
     71          /* Private variables ---------------------------------------------------------*/
     72          /* Private function prototypes -----------------------------------------------*/
     73          /* Private functions ---------------------------------------------------------*/
     74          
     75          /** @defgroup CRYP_Private_Functions
     76            * @{
     77            */ 
     78          
     79          /** @defgroup CRYP_Group6 High Level AES functions
     80           *  @brief   High Level AES functions 
     81           *
     82          @verbatim   
     83           ===============================================================================
     84                                 ##### High Level AES functions #####
     85           ===============================================================================
     86          
     87          @endverbatim
     88            * @{
     89            */
     90          
     91          /**
     92            * @brief  Encrypt and decrypt using AES in ECB Mode
     93            * @param  Mode: encryption or decryption Mode.
     94            *          This parameter can be one of the following values:
     95            *            @arg MODE_ENCRYPT: Encryption
     96            *            @arg MODE_DECRYPT: Decryption
     97            * @param  Key: Key used for AES algorithm.
     98            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
     99            * @param  Input: pointer to the Input buffer.
    100            * @param  Ilength: length of the Input buffer, must be a multiple of 16.
    101            * @param  Output: pointer to the returned buffer.
    102            * @retval An ErrorStatus enumeration value:
    103            *          - SUCCESS: Operation done
    104            *          - ERROR: Operation failed
    105            */

   \                                 In section .text, align 2, keep-with-next
    106          ErrorStatus CRYP_AES_ECB(uint8_t Mode, uint8_t* Key, uint16_t Keysize,
    107                                   uint8_t* Input, uint32_t Ilength, uint8_t* Output)
    108          {
   \                     CRYP_AES_ECB: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4691             MOV      R9,R2
   \        0xC   0x001D             MOVS     R5,R3
   \        0xE   0x9E15             LDR      R6,[SP, #+84]
    109            CRYP_InitTypeDef AES_CRYP_InitStructure;
    110            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
    111            __IO uint32_t counter = 0;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x9000             STR      R0,[SP, #+0]
    112            uint32_t busystatus = 0;
   \       0x14   0x2000             MOVS     R0,#+0
    113            ErrorStatus status = SUCCESS;
   \       0x16   0x2401             MOVS     R4,#+1
    114            uint32_t keyaddr    = (uint32_t)Key;
    115            uint32_t inputaddr  = (uint32_t)Input;
    116            uint32_t outputaddr = (uint32_t)Output;
    117            uint32_t i = 0;
   \       0x18   0x2000             MOVS     R0,#+0
    118          
    119            /* Crypto structures initialisation*/
    120            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \       0x1A   0xA805             ADD      R0,SP,#+20
   \       0x1C   0x....'....        BL       CRYP_KeyStructInit
    121          
    122            switch(Keysize)
   \       0x20   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \       0x24   0xF1B9 0x0F80      CMP      R9,#+128
   \       0x28   0xD006             BEQ.N    ??CRYP_AES_ECB_0
   \       0x2A   0xF1B9 0x0FC0      CMP      R9,#+192
   \       0x2E   0xD01C             BEQ.N    ??CRYP_AES_ECB_1
   \       0x30   0xF5B9 0x7F80      CMP      R9,#+256
   \       0x34   0xD03F             BEQ.N    ??CRYP_AES_ECB_2
   \       0x36   0xE070             B.N      ??CRYP_AES_ECB_3
    123            {
    124              case 128:
    125              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_ECB_0: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x9004             STR      R0,[SP, #+16]
    126              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \       0x3C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x40   0xBA00             REV      R0,R0
   \       0x42   0x9009             STR      R0,[SP, #+36]
    127              keyaddr+=4;
   \       0x44   0xF118 0x0804      ADDS     R8,R8,#+4
    128              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \       0x48   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x4C   0xBA00             REV      R0,R0
   \       0x4E   0x900A             STR      R0,[SP, #+40]
    129              keyaddr+=4;
   \       0x50   0xF118 0x0804      ADDS     R8,R8,#+4
    130              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \       0x54   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x58   0xBA00             REV      R0,R0
   \       0x5A   0x900B             STR      R0,[SP, #+44]
    131              keyaddr+=4;
   \       0x5C   0xF118 0x0804      ADDS     R8,R8,#+4
    132              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \       0x60   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x64   0xBA00             REV      R0,R0
   \       0x66   0x900C             STR      R0,[SP, #+48]
    133              break;
   \       0x68   0xE057             B.N      ??CRYP_AES_ECB_4
    134              case 192:
    135              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_ECB_1: (+1)
   \       0x6A   0xF44F 0x7080      MOV      R0,#+256
   \       0x6E   0x9004             STR      R0,[SP, #+16]
    136              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \       0x70   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x74   0xBA00             REV      R0,R0
   \       0x76   0x9007             STR      R0,[SP, #+28]
    137              keyaddr+=4;
   \       0x78   0xF118 0x0804      ADDS     R8,R8,#+4
    138              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \       0x7C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x80   0xBA00             REV      R0,R0
   \       0x82   0x9008             STR      R0,[SP, #+32]
    139              keyaddr+=4;
   \       0x84   0xF118 0x0804      ADDS     R8,R8,#+4
    140              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \       0x88   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x8C   0xBA00             REV      R0,R0
   \       0x8E   0x9009             STR      R0,[SP, #+36]
    141              keyaddr+=4;
   \       0x90   0xF118 0x0804      ADDS     R8,R8,#+4
    142              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \       0x94   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x98   0xBA00             REV      R0,R0
   \       0x9A   0x900A             STR      R0,[SP, #+40]
    143              keyaddr+=4;
   \       0x9C   0xF118 0x0804      ADDS     R8,R8,#+4
    144              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \       0xA0   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xA4   0xBA00             REV      R0,R0
   \       0xA6   0x900B             STR      R0,[SP, #+44]
    145              keyaddr+=4;
   \       0xA8   0xF118 0x0804      ADDS     R8,R8,#+4
    146              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \       0xAC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xB0   0xBA00             REV      R0,R0
   \       0xB2   0x900C             STR      R0,[SP, #+48]
    147              break;
   \       0xB4   0xE031             B.N      ??CRYP_AES_ECB_4
    148              case 256:
    149              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_ECB_2: (+1)
   \       0xB6   0xF44F 0x7000      MOV      R0,#+512
   \       0xBA   0x9004             STR      R0,[SP, #+16]
    150              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \       0xBC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xC0   0xBA00             REV      R0,R0
   \       0xC2   0x9005             STR      R0,[SP, #+20]
    151              keyaddr+=4;
   \       0xC4   0xF118 0x0804      ADDS     R8,R8,#+4
    152              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \       0xC8   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xCC   0xBA00             REV      R0,R0
   \       0xCE   0x9006             STR      R0,[SP, #+24]
    153              keyaddr+=4;
   \       0xD0   0xF118 0x0804      ADDS     R8,R8,#+4
    154              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \       0xD4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xD8   0xBA00             REV      R0,R0
   \       0xDA   0x9007             STR      R0,[SP, #+28]
    155              keyaddr+=4;
   \       0xDC   0xF118 0x0804      ADDS     R8,R8,#+4
    156              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \       0xE0   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xE4   0xBA00             REV      R0,R0
   \       0xE6   0x9008             STR      R0,[SP, #+32]
    157              keyaddr+=4;
   \       0xE8   0xF118 0x0804      ADDS     R8,R8,#+4
    158              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \       0xEC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xF0   0xBA00             REV      R0,R0
   \       0xF2   0x9009             STR      R0,[SP, #+36]
    159              keyaddr+=4;
   \       0xF4   0xF118 0x0804      ADDS     R8,R8,#+4
    160              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \       0xF8   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xFC   0xBA00             REV      R0,R0
   \       0xFE   0x900A             STR      R0,[SP, #+40]
    161              keyaddr+=4;
   \      0x100   0xF118 0x0804      ADDS     R8,R8,#+4
    162              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \      0x104   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x108   0xBA00             REV      R0,R0
   \      0x10A   0x900B             STR      R0,[SP, #+44]
    163              keyaddr+=4;
   \      0x10C   0xF118 0x0804      ADDS     R8,R8,#+4
    164              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \      0x110   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x114   0xBA00             REV      R0,R0
   \      0x116   0x900C             STR      R0,[SP, #+48]
    165              break;
   \      0x118   0xE7FF             B.N      ??CRYP_AES_ECB_4
    166              default:
    167              break;
    168            }
    169          
    170            /*------------------ AES Decryption ------------------*/
    171            if(Mode == MODE_DECRYPT) /* AES decryption */
   \                     ??CRYP_AES_ECB_3: (+1)
   \                     ??CRYP_AES_ECB_4: (+1)
   \      0x11A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \      0x11C   0x2F00             CMP      R7,#+0
   \      0x11E   0xD123             BNE.N    ??CRYP_AES_ECB_5
    172            {
    173              /* Flush IN/OUT FIFOs */
    174              CRYP_FIFOFlush();
   \      0x120   0x....'....        BL       CRYP_FIFOFlush
    175          
    176              /* Crypto Init for Key preparation for decryption process */
    177              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \      0x124   0x2004             MOVS     R0,#+4
   \      0x126   0x9001             STR      R0,[SP, #+4]
    178              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
   \      0x128   0x2038             MOVS     R0,#+56
   \      0x12A   0x9002             STR      R0,[SP, #+8]
    179              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
   \      0x12C   0x2000             MOVS     R0,#+0
   \      0x12E   0x9003             STR      R0,[SP, #+12]
    180              CRYP_Init(&AES_CRYP_InitStructure);
   \      0x130   0xA801             ADD      R0,SP,#+4
   \      0x132   0x....'....        BL       CRYP_Init
    181          
    182              /* Key Initialisation */
    183              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \      0x136   0xA805             ADD      R0,SP,#+20
   \      0x138   0x....'....        BL       CRYP_KeyInit
    184          
    185              /* Enable Crypto processor */
    186              CRYP_Cmd(ENABLE);
   \      0x13C   0x2001             MOVS     R0,#+1
   \      0x13E   0x....'....        BL       CRYP_Cmd
    187          
    188              /* wait until the Busy flag is RESET */
    189              do
    190              {
    191                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_ECB_6: (+1)
   \      0x142   0x2010             MOVS     R0,#+16
   \      0x144   0x....'....        BL       CRYP_GetFlagStatus
    192                counter++;
   \      0x148   0x9900             LDR      R1,[SP, #+0]
   \      0x14A   0x1C49             ADDS     R1,R1,#+1
   \      0x14C   0x9100             STR      R1,[SP, #+0]
    193              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \      0x14E   0x9900             LDR      R1,[SP, #+0]
   \      0x150   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x154   0xD001             BEQ.N    ??CRYP_AES_ECB_7
   \      0x156   0x2800             CMP      R0,#+0
   \      0x158   0xD1F3             BNE.N    ??CRYP_AES_ECB_6
    194          
    195              if (busystatus != RESET)
   \                     ??CRYP_AES_ECB_7: (+1)
   \      0x15A   0x2800             CMP      R0,#+0
   \      0x15C   0xD001             BEQ.N    ??CRYP_AES_ECB_8
    196             {
    197                 status = ERROR;
   \      0x15E   0x2400             MOVS     R4,#+0
   \      0x160   0xE007             B.N      ??CRYP_AES_ECB_9
    198              }
    199              else
    200              {
    201                /* Crypto Init for decryption process */  
    202                AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \                     ??CRYP_AES_ECB_8: (+1)
   \      0x162   0x2004             MOVS     R0,#+4
   \      0x164   0x9001             STR      R0,[SP, #+4]
   \      0x166   0xE004             B.N      ??CRYP_AES_ECB_9
    203              }
    204            }
    205            /*------------------ AES Encryption ------------------*/
    206            else /* AES encryption */
    207            {
    208          
    209              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \                     ??CRYP_AES_ECB_5: (+1)
   \      0x168   0xA805             ADD      R0,SP,#+20
   \      0x16A   0x....'....        BL       CRYP_KeyInit
    210          
    211              /* Crypto Init for Encryption process */
    212              AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
   \      0x16E   0x2000             MOVS     R0,#+0
   \      0x170   0x9001             STR      R0,[SP, #+4]
    213            }
    214          
    215            AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_ECB;
   \                     ??CRYP_AES_ECB_9: (+1)
   \      0x172   0x2020             MOVS     R0,#+32
   \      0x174   0x9002             STR      R0,[SP, #+8]
    216            AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \      0x176   0x2080             MOVS     R0,#+128
   \      0x178   0x9003             STR      R0,[SP, #+12]
    217            CRYP_Init(&AES_CRYP_InitStructure);
   \      0x17A   0xA801             ADD      R0,SP,#+4
   \      0x17C   0x....'....        BL       CRYP_Init
    218          
    219            /* Flush IN/OUT FIFOs */
    220            CRYP_FIFOFlush();
   \      0x180   0x....'....        BL       CRYP_FIFOFlush
    221          
    222            /* Enable Crypto processor */
    223            CRYP_Cmd(ENABLE);
   \      0x184   0x2001             MOVS     R0,#+1
   \      0x186   0x....'....        BL       CRYP_Cmd
    224          
    225            if(CRYP_GetCmdStatus() == DISABLE)
   \      0x18A   0x....'....        BL       CRYP_GetCmdStatus
   \      0x18E   0x2800             CMP      R0,#+0
   \      0x190   0xD101             BNE.N    ??CRYP_AES_ECB_10
    226            {
    227              /* The CRYP peripheral clock is not enabled or the device doesn't embed 
    228                 the CRYP peripheral (please check the device sales type. */
    229              return(ERROR);
   \      0x192   0x2000             MOVS     R0,#+0
   \      0x194   0xE041             B.N      ??CRYP_AES_ECB_11
    230            }
    231            
    232            for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
   \                     ??CRYP_AES_ECB_10: (+1)
   \      0x196   0x2700             MOVS     R7,#+0
   \      0x198   0xF8DD 0x8050      LDR      R8,[SP, #+80]
   \      0x19C   0xE032             B.N      ??CRYP_AES_ECB_12
    233            {
    234          
    235              /* Write the Input block in the IN FIFO */
    236              CRYP_DataIn(*(uint32_t*)(inputaddr));
    237              inputaddr+=4;
    238              CRYP_DataIn(*(uint32_t*)(inputaddr));
    239              inputaddr+=4;
    240              CRYP_DataIn(*(uint32_t*)(inputaddr));
    241              inputaddr+=4;
    242              CRYP_DataIn(*(uint32_t*)(inputaddr));
    243              inputaddr+=4;
    244          
    245              /* Wait until the complete message has been processed */
    246              counter = 0;
    247              do
    248              {
    249                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
    250                counter++;
    251              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
    252          
    253              if (busystatus != RESET)
    254             {
    255                 status = ERROR;
    256              }
    257              else
    258              {
    259          
    260                /* Read the Output block from the Output FIFO */
    261                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \                     ??CRYP_AES_ECB_13: (+1)
   \      0x19E   0x....'....        BL       CRYP_DataOut
   \      0x1A2   0x6030             STR      R0,[R6, #+0]
    262                outputaddr+=4;
   \      0x1A4   0x1D36             ADDS     R6,R6,#+4
    263                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x1A6   0x....'....        BL       CRYP_DataOut
   \      0x1AA   0x6030             STR      R0,[R6, #+0]
    264                outputaddr+=4;
   \      0x1AC   0x1D36             ADDS     R6,R6,#+4
    265                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x1AE   0x....'....        BL       CRYP_DataOut
   \      0x1B2   0x6030             STR      R0,[R6, #+0]
    266                outputaddr+=4;
   \      0x1B4   0x1D36             ADDS     R6,R6,#+4
    267                *(uint32_t*)(outputaddr) = CRYP_DataOut(); 
   \      0x1B6   0x....'....        BL       CRYP_DataOut
   \      0x1BA   0x6030             STR      R0,[R6, #+0]
    268                outputaddr+=4;
   \      0x1BC   0x1D36             ADDS     R6,R6,#+4
   \      0x1BE   0xE020             B.N      ??CRYP_AES_ECB_14
    269              }
   \                     ??CRYP_AES_ECB_15: (+1)
   \      0x1C0   0x6828             LDR      R0,[R5, #+0]
   \      0x1C2   0x....'....        BL       CRYP_DataIn
   \      0x1C6   0x1D2D             ADDS     R5,R5,#+4
   \      0x1C8   0x6828             LDR      R0,[R5, #+0]
   \      0x1CA   0x....'....        BL       CRYP_DataIn
   \      0x1CE   0x1D2D             ADDS     R5,R5,#+4
   \      0x1D0   0x6828             LDR      R0,[R5, #+0]
   \      0x1D2   0x....'....        BL       CRYP_DataIn
   \      0x1D6   0x1D2D             ADDS     R5,R5,#+4
   \      0x1D8   0x6828             LDR      R0,[R5, #+0]
   \      0x1DA   0x....'....        BL       CRYP_DataIn
   \      0x1DE   0x1D2D             ADDS     R5,R5,#+4
   \      0x1E0   0x2000             MOVS     R0,#+0
   \      0x1E2   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_ECB_16: (+1)
   \      0x1E4   0x2010             MOVS     R0,#+16
   \      0x1E6   0x....'....        BL       CRYP_GetFlagStatus
   \      0x1EA   0x9900             LDR      R1,[SP, #+0]
   \      0x1EC   0x1C49             ADDS     R1,R1,#+1
   \      0x1EE   0x9100             STR      R1,[SP, #+0]
   \      0x1F0   0x9900             LDR      R1,[SP, #+0]
   \      0x1F2   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x1F6   0xD001             BEQ.N    ??CRYP_AES_ECB_17
   \      0x1F8   0x2800             CMP      R0,#+0
   \      0x1FA   0xD1F3             BNE.N    ??CRYP_AES_ECB_16
   \                     ??CRYP_AES_ECB_17: (+1)
   \      0x1FC   0x2800             CMP      R0,#+0
   \      0x1FE   0xD0CE             BEQ.N    ??CRYP_AES_ECB_13
   \      0x200   0x2400             MOVS     R4,#+0
    270            }
   \                     ??CRYP_AES_ECB_14: (+1)
   \      0x202   0x3710             ADDS     R7,R7,#+16
   \                     ??CRYP_AES_ECB_12: (+1)
   \      0x204   0x4547             CMP      R7,R8
   \      0x206   0xD203             BCS.N    ??CRYP_AES_ECB_18
   \      0x208   0x0020             MOVS     R0,R4
   \      0x20A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x20C   0x2800             CMP      R0,#+0
   \      0x20E   0xD1D7             BNE.N    ??CRYP_AES_ECB_15
    271          
    272            /* Disable Crypto */
    273            CRYP_Cmd(DISABLE);
   \                     ??CRYP_AES_ECB_18: (+1)
   \      0x210   0x2000             MOVS     R0,#+0
   \      0x212   0x....'....        BL       CRYP_Cmd
    274          
    275            return status; 
   \      0x216   0x0020             MOVS     R0,R4
   \      0x218   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??CRYP_AES_ECB_11: (+1)
   \      0x21A   0xB00D             ADD      SP,SP,#+52
   \      0x21C   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    276          }
    277          
    278          /**
    279            * @brief  Encrypt and decrypt using AES in CBC Mode
    280            * @param  Mode: encryption or decryption Mode.
    281            *          This parameter can be one of the following values:
    282            *            @arg MODE_ENCRYPT: Encryption
    283            *            @arg MODE_DECRYPT: Decryption
    284            * @param  InitVectors: Initialisation Vectors used for AES algorithm.
    285            * @param  Key: Key used for AES algorithm.
    286            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
    287            * @param  Input: pointer to the Input buffer.
    288            * @param  Ilength: length of the Input buffer, must be a multiple of 16.
    289            * @param  Output: pointer to the returned buffer.
    290            * @retval An ErrorStatus enumeration value:
    291            *          - SUCCESS: Operation done
    292            *          - ERROR: Operation failed
    293            */

   \                                 In section .text, align 2, keep-with-next
    294          ErrorStatus CRYP_AES_CBC(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key,
    295                                   uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
    296                                   uint8_t *Output)
    297          {
   \                     CRYP_AES_CBC: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB091             SUB      SP,SP,#+68
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4691             MOV      R9,R2
   \        0xC   0x469A             MOV      R10,R3
   \        0xE   0x9D1A             LDR      R5,[SP, #+104]
   \       0x10   0x9C1C             LDR      R4,[SP, #+112]
    298            CRYP_InitTypeDef AES_CRYP_InitStructure;
    299            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
    300            CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
    301            __IO uint32_t counter = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x9000             STR      R0,[SP, #+0]
    302            uint32_t busystatus = 0;
   \       0x16   0x2000             MOVS     R0,#+0
    303            ErrorStatus status = SUCCESS;
   \       0x18   0x2601             MOVS     R6,#+1
    304            uint32_t keyaddr    = (uint32_t)Key;
    305            uint32_t inputaddr  = (uint32_t)Input;
    306            uint32_t outputaddr = (uint32_t)Output;
    307            uint32_t ivaddr = (uint32_t)InitVectors;
    308            uint32_t i = 0;
   \       0x1A   0x2000             MOVS     R0,#+0
    309          
    310            /* Crypto structures initialisation*/
    311            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \       0x1C   0xA805             ADD      R0,SP,#+20
   \       0x1E   0x....'....        BL       CRYP_KeyStructInit
    312          
    313            switch(Keysize)
   \       0x22   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \       0x26   0xF1BA 0x0F80      CMP      R10,#+128
   \       0x2A   0xD006             BEQ.N    ??CRYP_AES_CBC_0
   \       0x2C   0xF1BA 0x0FC0      CMP      R10,#+192
   \       0x30   0xD01C             BEQ.N    ??CRYP_AES_CBC_1
   \       0x32   0xF5BA 0x7F80      CMP      R10,#+256
   \       0x36   0xD03F             BEQ.N    ??CRYP_AES_CBC_2
   \       0x38   0xE070             B.N      ??CRYP_AES_CBC_3
    314            {
    315              case 128:
    316              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_CBC_0: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x9004             STR      R0,[SP, #+16]
    317              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \       0x3E   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x42   0xBA00             REV      R0,R0
   \       0x44   0x9009             STR      R0,[SP, #+36]
    318              keyaddr+=4;
   \       0x46   0xF119 0x0904      ADDS     R9,R9,#+4
    319              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \       0x4A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x4E   0xBA00             REV      R0,R0
   \       0x50   0x900A             STR      R0,[SP, #+40]
    320              keyaddr+=4;
   \       0x52   0xF119 0x0904      ADDS     R9,R9,#+4
    321              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \       0x56   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x5A   0xBA00             REV      R0,R0
   \       0x5C   0x900B             STR      R0,[SP, #+44]
    322              keyaddr+=4;
   \       0x5E   0xF119 0x0904      ADDS     R9,R9,#+4
    323              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \       0x62   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x66   0xBA00             REV      R0,R0
   \       0x68   0x900C             STR      R0,[SP, #+48]
    324              break;
   \       0x6A   0xE057             B.N      ??CRYP_AES_CBC_4
    325              case 192:
    326              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_CBC_1: (+1)
   \       0x6C   0xF44F 0x7080      MOV      R0,#+256
   \       0x70   0x9004             STR      R0,[SP, #+16]
    327              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \       0x72   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x76   0xBA00             REV      R0,R0
   \       0x78   0x9007             STR      R0,[SP, #+28]
    328              keyaddr+=4;
   \       0x7A   0xF119 0x0904      ADDS     R9,R9,#+4
    329              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \       0x7E   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x82   0xBA00             REV      R0,R0
   \       0x84   0x9008             STR      R0,[SP, #+32]
    330              keyaddr+=4;
   \       0x86   0xF119 0x0904      ADDS     R9,R9,#+4
    331              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \       0x8A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x8E   0xBA00             REV      R0,R0
   \       0x90   0x9009             STR      R0,[SP, #+36]
    332              keyaddr+=4;
   \       0x92   0xF119 0x0904      ADDS     R9,R9,#+4
    333              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \       0x96   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x9A   0xBA00             REV      R0,R0
   \       0x9C   0x900A             STR      R0,[SP, #+40]
    334              keyaddr+=4;
   \       0x9E   0xF119 0x0904      ADDS     R9,R9,#+4
    335              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \       0xA2   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xA6   0xBA00             REV      R0,R0
   \       0xA8   0x900B             STR      R0,[SP, #+44]
    336              keyaddr+=4;
   \       0xAA   0xF119 0x0904      ADDS     R9,R9,#+4
    337              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \       0xAE   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xB2   0xBA00             REV      R0,R0
   \       0xB4   0x900C             STR      R0,[SP, #+48]
    338              break;
   \       0xB6   0xE031             B.N      ??CRYP_AES_CBC_4
    339              case 256:
    340              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_CBC_2: (+1)
   \       0xB8   0xF44F 0x7000      MOV      R0,#+512
   \       0xBC   0x9004             STR      R0,[SP, #+16]
    341              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \       0xBE   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xC2   0xBA00             REV      R0,R0
   \       0xC4   0x9005             STR      R0,[SP, #+20]
    342              keyaddr+=4;
   \       0xC6   0xF119 0x0904      ADDS     R9,R9,#+4
    343              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \       0xCA   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xCE   0xBA00             REV      R0,R0
   \       0xD0   0x9006             STR      R0,[SP, #+24]
    344              keyaddr+=4;
   \       0xD2   0xF119 0x0904      ADDS     R9,R9,#+4
    345              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \       0xD6   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xDA   0xBA00             REV      R0,R0
   \       0xDC   0x9007             STR      R0,[SP, #+28]
    346              keyaddr+=4;
   \       0xDE   0xF119 0x0904      ADDS     R9,R9,#+4
    347              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \       0xE2   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xE6   0xBA00             REV      R0,R0
   \       0xE8   0x9008             STR      R0,[SP, #+32]
    348              keyaddr+=4;
   \       0xEA   0xF119 0x0904      ADDS     R9,R9,#+4
    349              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \       0xEE   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xF2   0xBA00             REV      R0,R0
   \       0xF4   0x9009             STR      R0,[SP, #+36]
    350              keyaddr+=4;
   \       0xF6   0xF119 0x0904      ADDS     R9,R9,#+4
    351              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \       0xFA   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xFE   0xBA00             REV      R0,R0
   \      0x100   0x900A             STR      R0,[SP, #+40]
    352              keyaddr+=4;
   \      0x102   0xF119 0x0904      ADDS     R9,R9,#+4
    353              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \      0x106   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x10A   0xBA00             REV      R0,R0
   \      0x10C   0x900B             STR      R0,[SP, #+44]
    354              keyaddr+=4;
   \      0x10E   0xF119 0x0904      ADDS     R9,R9,#+4
    355              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \      0x112   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x116   0xBA00             REV      R0,R0
   \      0x118   0x900C             STR      R0,[SP, #+48]
    356              break;
   \      0x11A   0xE7FF             B.N      ??CRYP_AES_CBC_4
    357              default:
    358              break;
    359            }
    360          
    361            /* CRYP Initialization Vectors */
    362            AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
   \                     ??CRYP_AES_CBC_3: (+1)
   \                     ??CRYP_AES_CBC_4: (+1)
   \      0x11C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x120   0xBA00             REV      R0,R0
   \      0x122   0x900D             STR      R0,[SP, #+52]
    363            ivaddr+=4;
   \      0x124   0xF118 0x0804      ADDS     R8,R8,#+4
    364            AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
   \      0x128   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x12C   0xBA00             REV      R0,R0
   \      0x12E   0x900E             STR      R0,[SP, #+56]
    365            ivaddr+=4;
   \      0x130   0xF118 0x0804      ADDS     R8,R8,#+4
    366            AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
   \      0x134   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x138   0xBA00             REV      R0,R0
   \      0x13A   0x900F             STR      R0,[SP, #+60]
    367            ivaddr+=4;
   \      0x13C   0xF118 0x0804      ADDS     R8,R8,#+4
    368            AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
   \      0x140   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x144   0xBA00             REV      R0,R0
   \      0x146   0x9010             STR      R0,[SP, #+64]
    369          
    370          
    371            /*------------------ AES Decryption ------------------*/
    372            if(Mode == MODE_DECRYPT) /* AES decryption */
   \      0x148   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \      0x14A   0x2F00             CMP      R7,#+0
   \      0x14C   0xD123             BNE.N    ??CRYP_AES_CBC_5
    373            {
    374              /* Flush IN/OUT FIFOs */
    375              CRYP_FIFOFlush();
   \      0x14E   0x....'....        BL       CRYP_FIFOFlush
    376          
    377              /* Crypto Init for Key preparation for decryption process */
    378              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \      0x152   0x2004             MOVS     R0,#+4
   \      0x154   0x9001             STR      R0,[SP, #+4]
    379              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
   \      0x156   0x2038             MOVS     R0,#+56
   \      0x158   0x9002             STR      R0,[SP, #+8]
    380              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
   \      0x15A   0x2000             MOVS     R0,#+0
   \      0x15C   0x9003             STR      R0,[SP, #+12]
    381          
    382              CRYP_Init(&AES_CRYP_InitStructure);
   \      0x15E   0xA801             ADD      R0,SP,#+4
   \      0x160   0x....'....        BL       CRYP_Init
    383          
    384              /* Key Initialisation */
    385              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \      0x164   0xA805             ADD      R0,SP,#+20
   \      0x166   0x....'....        BL       CRYP_KeyInit
    386          
    387              /* Enable Crypto processor */
    388              CRYP_Cmd(ENABLE);
   \      0x16A   0x2001             MOVS     R0,#+1
   \      0x16C   0x....'....        BL       CRYP_Cmd
    389          
    390              /* wait until the Busy flag is RESET */
    391              do
    392              {
    393                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_CBC_6: (+1)
   \      0x170   0x2010             MOVS     R0,#+16
   \      0x172   0x....'....        BL       CRYP_GetFlagStatus
    394                counter++;
   \      0x176   0x9900             LDR      R1,[SP, #+0]
   \      0x178   0x1C49             ADDS     R1,R1,#+1
   \      0x17A   0x9100             STR      R1,[SP, #+0]
    395              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \      0x17C   0x9900             LDR      R1,[SP, #+0]
   \      0x17E   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x182   0xD001             BEQ.N    ??CRYP_AES_CBC_7
   \      0x184   0x2800             CMP      R0,#+0
   \      0x186   0xD1F3             BNE.N    ??CRYP_AES_CBC_6
    396          
    397              if (busystatus != RESET)
   \                     ??CRYP_AES_CBC_7: (+1)
   \      0x188   0x2800             CMP      R0,#+0
   \      0x18A   0xD001             BEQ.N    ??CRYP_AES_CBC_8
    398             {
    399                 status = ERROR;
   \      0x18C   0x2600             MOVS     R6,#+0
   \      0x18E   0xE007             B.N      ??CRYP_AES_CBC_9
    400              }
    401              else
    402              {
    403                /* Crypto Init for decryption process */  
    404                AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \                     ??CRYP_AES_CBC_8: (+1)
   \      0x190   0x2004             MOVS     R0,#+4
   \      0x192   0x9001             STR      R0,[SP, #+4]
   \      0x194   0xE004             B.N      ??CRYP_AES_CBC_9
    405              }
    406            }
    407            /*------------------ AES Encryption ------------------*/
    408            else /* AES encryption */
    409            {
    410              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \                     ??CRYP_AES_CBC_5: (+1)
   \      0x196   0xA805             ADD      R0,SP,#+20
   \      0x198   0x....'....        BL       CRYP_KeyInit
    411          
    412              /* Crypto Init for Encryption process */
    413              AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
   \      0x19C   0x2000             MOVS     R0,#+0
   \      0x19E   0x9001             STR      R0,[SP, #+4]
    414            }
    415            AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CBC;
   \                     ??CRYP_AES_CBC_9: (+1)
   \      0x1A0   0x2028             MOVS     R0,#+40
   \      0x1A2   0x9002             STR      R0,[SP, #+8]
    416            AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \      0x1A4   0x2080             MOVS     R0,#+128
   \      0x1A6   0x9003             STR      R0,[SP, #+12]
    417            CRYP_Init(&AES_CRYP_InitStructure);
   \      0x1A8   0xA801             ADD      R0,SP,#+4
   \      0x1AA   0x....'....        BL       CRYP_Init
    418          
    419            /* CRYP Initialization Vectors */
    420            CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \      0x1AE   0xA80D             ADD      R0,SP,#+52
   \      0x1B0   0x....'....        BL       CRYP_IVInit
    421          
    422            /* Flush IN/OUT FIFOs */
    423            CRYP_FIFOFlush();
   \      0x1B4   0x....'....        BL       CRYP_FIFOFlush
    424          
    425            /* Enable Crypto processor */
    426            CRYP_Cmd(ENABLE);
   \      0x1B8   0x2001             MOVS     R0,#+1
   \      0x1BA   0x....'....        BL       CRYP_Cmd
    427          
    428            if(CRYP_GetCmdStatus() == DISABLE)
   \      0x1BE   0x....'....        BL       CRYP_GetCmdStatus
   \      0x1C2   0x2800             CMP      R0,#+0
   \      0x1C4   0xD101             BNE.N    ??CRYP_AES_CBC_10
    429            {
    430              /* The CRYP peripheral clock is not enabled or the device doesn't embed 
    431                 the CRYP peripheral (please check the device sales type. */
    432              return(ERROR);
   \      0x1C6   0x2000             MOVS     R0,#+0
   \      0x1C8   0xE041             B.N      ??CRYP_AES_CBC_11
    433            }
    434            
    435            for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
   \                     ??CRYP_AES_CBC_10: (+1)
   \      0x1CA   0x2700             MOVS     R7,#+0
   \      0x1CC   0xF8DD 0x806C      LDR      R8,[SP, #+108]
   \      0x1D0   0xE032             B.N      ??CRYP_AES_CBC_12
    436            {
    437          
    438              /* Write the Input block in the IN FIFO */
    439              CRYP_DataIn(*(uint32_t*)(inputaddr));
    440              inputaddr+=4;
    441              CRYP_DataIn(*(uint32_t*)(inputaddr));
    442              inputaddr+=4;
    443              CRYP_DataIn(*(uint32_t*)(inputaddr));
    444              inputaddr+=4;
    445              CRYP_DataIn(*(uint32_t*)(inputaddr));
    446              inputaddr+=4;
    447              /* Wait until the complete message has been processed */
    448              counter = 0;
    449              do
    450              {
    451                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
    452                counter++;
    453              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
    454          
    455              if (busystatus != RESET)
    456             {
    457                 status = ERROR;
    458              }
    459              else
    460              {
    461          
    462                /* Read the Output block from the Output FIFO */
    463                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \                     ??CRYP_AES_CBC_13: (+1)
   \      0x1D2   0x....'....        BL       CRYP_DataOut
   \      0x1D6   0x6020             STR      R0,[R4, #+0]
    464                outputaddr+=4;
   \      0x1D8   0x1D24             ADDS     R4,R4,#+4
    465                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x1DA   0x....'....        BL       CRYP_DataOut
   \      0x1DE   0x6020             STR      R0,[R4, #+0]
    466                outputaddr+=4;
   \      0x1E0   0x1D24             ADDS     R4,R4,#+4
    467                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x1E2   0x....'....        BL       CRYP_DataOut
   \      0x1E6   0x6020             STR      R0,[R4, #+0]
    468                outputaddr+=4;
   \      0x1E8   0x1D24             ADDS     R4,R4,#+4
    469                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x1EA   0x....'....        BL       CRYP_DataOut
   \      0x1EE   0x6020             STR      R0,[R4, #+0]
    470                outputaddr+=4;
   \      0x1F0   0x1D24             ADDS     R4,R4,#+4
   \      0x1F2   0xE020             B.N      ??CRYP_AES_CBC_14
    471              }
   \                     ??CRYP_AES_CBC_15: (+1)
   \      0x1F4   0x6828             LDR      R0,[R5, #+0]
   \      0x1F6   0x....'....        BL       CRYP_DataIn
   \      0x1FA   0x1D2D             ADDS     R5,R5,#+4
   \      0x1FC   0x6828             LDR      R0,[R5, #+0]
   \      0x1FE   0x....'....        BL       CRYP_DataIn
   \      0x202   0x1D2D             ADDS     R5,R5,#+4
   \      0x204   0x6828             LDR      R0,[R5, #+0]
   \      0x206   0x....'....        BL       CRYP_DataIn
   \      0x20A   0x1D2D             ADDS     R5,R5,#+4
   \      0x20C   0x6828             LDR      R0,[R5, #+0]
   \      0x20E   0x....'....        BL       CRYP_DataIn
   \      0x212   0x1D2D             ADDS     R5,R5,#+4
   \      0x214   0x2000             MOVS     R0,#+0
   \      0x216   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_CBC_16: (+1)
   \      0x218   0x2010             MOVS     R0,#+16
   \      0x21A   0x....'....        BL       CRYP_GetFlagStatus
   \      0x21E   0x9900             LDR      R1,[SP, #+0]
   \      0x220   0x1C49             ADDS     R1,R1,#+1
   \      0x222   0x9100             STR      R1,[SP, #+0]
   \      0x224   0x9900             LDR      R1,[SP, #+0]
   \      0x226   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x22A   0xD001             BEQ.N    ??CRYP_AES_CBC_17
   \      0x22C   0x2800             CMP      R0,#+0
   \      0x22E   0xD1F3             BNE.N    ??CRYP_AES_CBC_16
   \                     ??CRYP_AES_CBC_17: (+1)
   \      0x230   0x2800             CMP      R0,#+0
   \      0x232   0xD0CE             BEQ.N    ??CRYP_AES_CBC_13
   \      0x234   0x2600             MOVS     R6,#+0
    472            }
   \                     ??CRYP_AES_CBC_14: (+1)
   \      0x236   0x3710             ADDS     R7,R7,#+16
   \                     ??CRYP_AES_CBC_12: (+1)
   \      0x238   0x4547             CMP      R7,R8
   \      0x23A   0xD203             BCS.N    ??CRYP_AES_CBC_18
   \      0x23C   0x0030             MOVS     R0,R6
   \      0x23E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x240   0x2800             CMP      R0,#+0
   \      0x242   0xD1D7             BNE.N    ??CRYP_AES_CBC_15
    473          
    474            /* Disable Crypto */
    475            CRYP_Cmd(DISABLE);
   \                     ??CRYP_AES_CBC_18: (+1)
   \      0x244   0x2000             MOVS     R0,#+0
   \      0x246   0x....'....        BL       CRYP_Cmd
    476          
    477            return status;
   \      0x24A   0x0030             MOVS     R0,R6
   \      0x24C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??CRYP_AES_CBC_11: (+1)
   \      0x24E   0xB012             ADD      SP,SP,#+72
   \      0x250   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    478          }
    479          
    480          /**
    481            * @brief  Encrypt and decrypt using AES in CTR Mode
    482            * @param  Mode: encryption or decryption Mode.
    483            *           This parameter can be one of the following values:
    484            *            @arg MODE_ENCRYPT: Encryption
    485            *            @arg MODE_DECRYPT: Decryption
    486            * @param  InitVectors: Initialisation Vectors used for AES algorithm.
    487            * @param  Key: Key used for AES algorithm.
    488            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
    489            * @param  Input: pointer to the Input buffer.
    490            * @param  Ilength: length of the Input buffer, must be a multiple of 16.
    491            * @param  Output: pointer to the returned buffer.
    492            * @retval An ErrorStatus enumeration value:
    493            *          - SUCCESS: Operation done
    494            *          - ERROR: Operation failed
    495            */

   \                                 In section .text, align 2, keep-with-next
    496          ErrorStatus CRYP_AES_CTR(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key, 
    497                                   uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
    498                                   uint8_t *Output)
    499          {
   \                     CRYP_AES_CTR: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB091             SUB      SP,SP,#+68
   \        0x6   0x0007             MOVS     R7,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4691             MOV      R9,R2
   \        0xC   0x469A             MOV      R10,R3
   \        0xE   0x9D1A             LDR      R5,[SP, #+104]
   \       0x10   0x9C1C             LDR      R4,[SP, #+112]
    500            CRYP_InitTypeDef AES_CRYP_InitStructure;
    501            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
    502            CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
    503            __IO uint32_t counter = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x9000             STR      R0,[SP, #+0]
    504            uint32_t busystatus = 0;
   \       0x16   0x2000             MOVS     R0,#+0
    505            ErrorStatus status = SUCCESS;
   \       0x18   0x2601             MOVS     R6,#+1
    506            uint32_t keyaddr    = (uint32_t)Key;
    507            uint32_t inputaddr  = (uint32_t)Input;
    508            uint32_t outputaddr = (uint32_t)Output;
    509            uint32_t ivaddr     = (uint32_t)InitVectors;
    510            uint32_t i = 0;
   \       0x1A   0x2000             MOVS     R0,#+0
    511          
    512            /* Crypto structures initialisation*/
    513            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \       0x1C   0xA801             ADD      R0,SP,#+4
   \       0x1E   0x....'....        BL       CRYP_KeyStructInit
    514          
    515            switch(Keysize)
   \       0x22   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \       0x26   0xF1BA 0x0F80      CMP      R10,#+128
   \       0x2A   0xD006             BEQ.N    ??CRYP_AES_CTR_0
   \       0x2C   0xF1BA 0x0FC0      CMP      R10,#+192
   \       0x30   0xD01C             BEQ.N    ??CRYP_AES_CTR_1
   \       0x32   0xF5BA 0x7F80      CMP      R10,#+256
   \       0x36   0xD03F             BEQ.N    ??CRYP_AES_CTR_2
   \       0x38   0xE070             B.N      ??CRYP_AES_CTR_3
    516            {
    517              case 128:
    518              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_CTR_0: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x900C             STR      R0,[SP, #+48]
    519              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \       0x3E   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x42   0xBA00             REV      R0,R0
   \       0x44   0x9005             STR      R0,[SP, #+20]
    520              keyaddr+=4;
   \       0x46   0xF119 0x0904      ADDS     R9,R9,#+4
    521              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \       0x4A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x4E   0xBA00             REV      R0,R0
   \       0x50   0x9006             STR      R0,[SP, #+24]
    522              keyaddr+=4;
   \       0x52   0xF119 0x0904      ADDS     R9,R9,#+4
    523              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \       0x56   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x5A   0xBA00             REV      R0,R0
   \       0x5C   0x9007             STR      R0,[SP, #+28]
    524              keyaddr+=4;
   \       0x5E   0xF119 0x0904      ADDS     R9,R9,#+4
    525              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \       0x62   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x66   0xBA00             REV      R0,R0
   \       0x68   0x9008             STR      R0,[SP, #+32]
    526              break;
   \       0x6A   0xE057             B.N      ??CRYP_AES_CTR_4
    527              case 192:
    528              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_CTR_1: (+1)
   \       0x6C   0xF44F 0x7080      MOV      R0,#+256
   \       0x70   0x900C             STR      R0,[SP, #+48]
    529              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \       0x72   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x76   0xBA00             REV      R0,R0
   \       0x78   0x9003             STR      R0,[SP, #+12]
    530              keyaddr+=4;
   \       0x7A   0xF119 0x0904      ADDS     R9,R9,#+4
    531              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \       0x7E   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x82   0xBA00             REV      R0,R0
   \       0x84   0x9004             STR      R0,[SP, #+16]
    532              keyaddr+=4;
   \       0x86   0xF119 0x0904      ADDS     R9,R9,#+4
    533              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \       0x8A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x8E   0xBA00             REV      R0,R0
   \       0x90   0x9005             STR      R0,[SP, #+20]
    534              keyaddr+=4;
   \       0x92   0xF119 0x0904      ADDS     R9,R9,#+4
    535              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \       0x96   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x9A   0xBA00             REV      R0,R0
   \       0x9C   0x9006             STR      R0,[SP, #+24]
    536              keyaddr+=4;
   \       0x9E   0xF119 0x0904      ADDS     R9,R9,#+4
    537              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \       0xA2   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xA6   0xBA00             REV      R0,R0
   \       0xA8   0x9007             STR      R0,[SP, #+28]
    538              keyaddr+=4;
   \       0xAA   0xF119 0x0904      ADDS     R9,R9,#+4
    539              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \       0xAE   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xB2   0xBA00             REV      R0,R0
   \       0xB4   0x9008             STR      R0,[SP, #+32]
    540              break;
   \       0xB6   0xE031             B.N      ??CRYP_AES_CTR_4
    541              case 256:
    542              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_CTR_2: (+1)
   \       0xB8   0xF44F 0x7000      MOV      R0,#+512
   \       0xBC   0x900C             STR      R0,[SP, #+48]
    543              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \       0xBE   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xC2   0xBA00             REV      R0,R0
   \       0xC4   0x9001             STR      R0,[SP, #+4]
    544              keyaddr+=4;
   \       0xC6   0xF119 0x0904      ADDS     R9,R9,#+4
    545              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \       0xCA   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xCE   0xBA00             REV      R0,R0
   \       0xD0   0x9002             STR      R0,[SP, #+8]
    546              keyaddr+=4;
   \       0xD2   0xF119 0x0904      ADDS     R9,R9,#+4
    547              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \       0xD6   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xDA   0xBA00             REV      R0,R0
   \       0xDC   0x9003             STR      R0,[SP, #+12]
    548              keyaddr+=4;
   \       0xDE   0xF119 0x0904      ADDS     R9,R9,#+4
    549              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \       0xE2   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xE6   0xBA00             REV      R0,R0
   \       0xE8   0x9004             STR      R0,[SP, #+16]
    550              keyaddr+=4;
   \       0xEA   0xF119 0x0904      ADDS     R9,R9,#+4
    551              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \       0xEE   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xF2   0xBA00             REV      R0,R0
   \       0xF4   0x9005             STR      R0,[SP, #+20]
    552              keyaddr+=4;
   \       0xF6   0xF119 0x0904      ADDS     R9,R9,#+4
    553              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \       0xFA   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xFE   0xBA00             REV      R0,R0
   \      0x100   0x9006             STR      R0,[SP, #+24]
    554              keyaddr+=4;
   \      0x102   0xF119 0x0904      ADDS     R9,R9,#+4
    555              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \      0x106   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x10A   0xBA00             REV      R0,R0
   \      0x10C   0x9007             STR      R0,[SP, #+28]
    556              keyaddr+=4;
   \      0x10E   0xF119 0x0904      ADDS     R9,R9,#+4
    557              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \      0x112   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x116   0xBA00             REV      R0,R0
   \      0x118   0x9008             STR      R0,[SP, #+32]
    558              break;
   \      0x11A   0xE7FF             B.N      ??CRYP_AES_CTR_4
    559              default:
    560              break;
    561            }
    562            /* CRYP Initialization Vectors */
    563            AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
   \                     ??CRYP_AES_CTR_3: (+1)
   \                     ??CRYP_AES_CTR_4: (+1)
   \      0x11C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x120   0xBA00             REV      R0,R0
   \      0x122   0x900D             STR      R0,[SP, #+52]
    564            ivaddr+=4;
   \      0x124   0xF118 0x0804      ADDS     R8,R8,#+4
    565            AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
   \      0x128   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x12C   0xBA00             REV      R0,R0
   \      0x12E   0x900E             STR      R0,[SP, #+56]
    566            ivaddr+=4;
   \      0x130   0xF118 0x0804      ADDS     R8,R8,#+4
    567            AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
   \      0x134   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x138   0xBA00             REV      R0,R0
   \      0x13A   0x900F             STR      R0,[SP, #+60]
    568            ivaddr+=4;
   \      0x13C   0xF118 0x0804      ADDS     R8,R8,#+4
    569            AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
   \      0x140   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x144   0xBA00             REV      R0,R0
   \      0x146   0x9010             STR      R0,[SP, #+64]
    570          
    571            /* Key Initialisation */
    572            CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \      0x148   0xA801             ADD      R0,SP,#+4
   \      0x14A   0x....'....        BL       CRYP_KeyInit
    573          
    574            /*------------------ AES Decryption ------------------*/
    575            if(Mode == MODE_DECRYPT) /* AES decryption */
   \      0x14E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \      0x150   0x2F00             CMP      R7,#+0
   \      0x152   0xD102             BNE.N    ??CRYP_AES_CTR_5
    576            {
    577              /* Crypto Init for decryption process */
    578              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \      0x154   0x2004             MOVS     R0,#+4
   \      0x156   0x9009             STR      R0,[SP, #+36]
   \      0x158   0xE001             B.N      ??CRYP_AES_CTR_6
    579            }
    580            /*------------------ AES Encryption ------------------*/
    581            else /* AES encryption */
    582            {
    583              /* Crypto Init for Encryption process */
    584              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
   \                     ??CRYP_AES_CTR_5: (+1)
   \      0x15A   0x2000             MOVS     R0,#+0
   \      0x15C   0x9009             STR      R0,[SP, #+36]
    585            }
    586            AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CTR;
   \                     ??CRYP_AES_CTR_6: (+1)
   \      0x15E   0x2030             MOVS     R0,#+48
   \      0x160   0x900A             STR      R0,[SP, #+40]
    587            AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \      0x162   0x2080             MOVS     R0,#+128
   \      0x164   0x900B             STR      R0,[SP, #+44]
    588            CRYP_Init(&AES_CRYP_InitStructure);
   \      0x166   0xA809             ADD      R0,SP,#+36
   \      0x168   0x....'....        BL       CRYP_Init
    589          
    590            /* CRYP Initialization Vectors */
    591            CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \      0x16C   0xA80D             ADD      R0,SP,#+52
   \      0x16E   0x....'....        BL       CRYP_IVInit
    592          
    593            /* Flush IN/OUT FIFOs */
    594            CRYP_FIFOFlush();
   \      0x172   0x....'....        BL       CRYP_FIFOFlush
    595          
    596            /* Enable Crypto processor */
    597            CRYP_Cmd(ENABLE);
   \      0x176   0x2001             MOVS     R0,#+1
   \      0x178   0x....'....        BL       CRYP_Cmd
    598          
    599            if(CRYP_GetCmdStatus() == DISABLE)
   \      0x17C   0x....'....        BL       CRYP_GetCmdStatus
   \      0x180   0x2800             CMP      R0,#+0
   \      0x182   0xD101             BNE.N    ??CRYP_AES_CTR_7
    600            {
    601              /* The CRYP peripheral clock is not enabled or the device doesn't embed 
    602                 the CRYP peripheral (please check the device sales type. */
    603              return(ERROR);
   \      0x184   0x2000             MOVS     R0,#+0
   \      0x186   0xE041             B.N      ??CRYP_AES_CTR_8
    604            }
    605            
    606            for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
   \                     ??CRYP_AES_CTR_7: (+1)
   \      0x188   0x2700             MOVS     R7,#+0
   \      0x18A   0xF8DD 0x806C      LDR      R8,[SP, #+108]
   \      0x18E   0xE032             B.N      ??CRYP_AES_CTR_9
    607            {
    608          
    609              /* Write the Input block in the IN FIFO */
    610              CRYP_DataIn(*(uint32_t*)(inputaddr));
    611              inputaddr+=4;
    612              CRYP_DataIn(*(uint32_t*)(inputaddr));
    613              inputaddr+=4;
    614              CRYP_DataIn(*(uint32_t*)(inputaddr));
    615              inputaddr+=4;
    616              CRYP_DataIn(*(uint32_t*)(inputaddr));
    617              inputaddr+=4;
    618              /* Wait until the complete message has been processed */
    619              counter = 0;
    620              do
    621              {
    622                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
    623                counter++;
    624              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
    625          
    626              if (busystatus != RESET)
    627             {
    628                 status = ERROR;
    629              }
    630              else
    631              {
    632          
    633                /* Read the Output block from the Output FIFO */
    634                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \                     ??CRYP_AES_CTR_10: (+1)
   \      0x190   0x....'....        BL       CRYP_DataOut
   \      0x194   0x6020             STR      R0,[R4, #+0]
    635                outputaddr+=4;
   \      0x196   0x1D24             ADDS     R4,R4,#+4
    636                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x198   0x....'....        BL       CRYP_DataOut
   \      0x19C   0x6020             STR      R0,[R4, #+0]
    637                outputaddr+=4;
   \      0x19E   0x1D24             ADDS     R4,R4,#+4
    638                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x1A0   0x....'....        BL       CRYP_DataOut
   \      0x1A4   0x6020             STR      R0,[R4, #+0]
    639                outputaddr+=4;
   \      0x1A6   0x1D24             ADDS     R4,R4,#+4
    640                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x1A8   0x....'....        BL       CRYP_DataOut
   \      0x1AC   0x6020             STR      R0,[R4, #+0]
    641                outputaddr+=4;
   \      0x1AE   0x1D24             ADDS     R4,R4,#+4
   \      0x1B0   0xE020             B.N      ??CRYP_AES_CTR_11
    642              }
   \                     ??CRYP_AES_CTR_12: (+1)
   \      0x1B2   0x6828             LDR      R0,[R5, #+0]
   \      0x1B4   0x....'....        BL       CRYP_DataIn
   \      0x1B8   0x1D2D             ADDS     R5,R5,#+4
   \      0x1BA   0x6828             LDR      R0,[R5, #+0]
   \      0x1BC   0x....'....        BL       CRYP_DataIn
   \      0x1C0   0x1D2D             ADDS     R5,R5,#+4
   \      0x1C2   0x6828             LDR      R0,[R5, #+0]
   \      0x1C4   0x....'....        BL       CRYP_DataIn
   \      0x1C8   0x1D2D             ADDS     R5,R5,#+4
   \      0x1CA   0x6828             LDR      R0,[R5, #+0]
   \      0x1CC   0x....'....        BL       CRYP_DataIn
   \      0x1D0   0x1D2D             ADDS     R5,R5,#+4
   \      0x1D2   0x2000             MOVS     R0,#+0
   \      0x1D4   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_CTR_13: (+1)
   \      0x1D6   0x2010             MOVS     R0,#+16
   \      0x1D8   0x....'....        BL       CRYP_GetFlagStatus
   \      0x1DC   0x9900             LDR      R1,[SP, #+0]
   \      0x1DE   0x1C49             ADDS     R1,R1,#+1
   \      0x1E0   0x9100             STR      R1,[SP, #+0]
   \      0x1E2   0x9900             LDR      R1,[SP, #+0]
   \      0x1E4   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x1E8   0xD001             BEQ.N    ??CRYP_AES_CTR_14
   \      0x1EA   0x2800             CMP      R0,#+0
   \      0x1EC   0xD1F3             BNE.N    ??CRYP_AES_CTR_13
   \                     ??CRYP_AES_CTR_14: (+1)
   \      0x1EE   0x2800             CMP      R0,#+0
   \      0x1F0   0xD0CE             BEQ.N    ??CRYP_AES_CTR_10
   \      0x1F2   0x2600             MOVS     R6,#+0
    643            }
   \                     ??CRYP_AES_CTR_11: (+1)
   \      0x1F4   0x3710             ADDS     R7,R7,#+16
   \                     ??CRYP_AES_CTR_9: (+1)
   \      0x1F6   0x4547             CMP      R7,R8
   \      0x1F8   0xD203             BCS.N    ??CRYP_AES_CTR_15
   \      0x1FA   0x0030             MOVS     R0,R6
   \      0x1FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x1FE   0x2800             CMP      R0,#+0
   \      0x200   0xD1D7             BNE.N    ??CRYP_AES_CTR_12
    644            /* Disable Crypto */
    645            CRYP_Cmd(DISABLE);
   \                     ??CRYP_AES_CTR_15: (+1)
   \      0x202   0x2000             MOVS     R0,#+0
   \      0x204   0x....'....        BL       CRYP_Cmd
    646          
    647            return status;
   \      0x208   0x0030             MOVS     R0,R6
   \      0x20A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??CRYP_AES_CTR_8: (+1)
   \      0x20C   0xB012             ADD      SP,SP,#+72
   \      0x20E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    648          }
    649          
    650          /**
    651            * @brief  Encrypt and decrypt using AES in GCM Mode. The GCM and CCM modes
    652            *         are available only on STM32F437x Devices.
    653            * @param  Mode: encryption or decryption Mode.
    654            *          This parameter can be one of the following values:
    655            *            @arg MODE_ENCRYPT: Encryption
    656            *            @arg MODE_DECRYPT: Decryption
    657            * @param  InitVectors: Initialisation Vectors used for AES algorithm.
    658            * @param  Key: Key used for AES algorithm.
    659            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
    660            * @param  Input: pointer to the Input buffer.
    661            * @param  Ilength: length of the Input buffer in bytes, must be a multiple of 16.
    662            * @param  Header: pointer to the header buffer.
    663            * @param  Hlength: length of the header buffer in bytes, must be a multiple of 16.  
    664            * @param  Output: pointer to the returned buffer.
    665            * @param  AuthTAG: pointer to the authentication TAG buffer.
    666            * @retval An ErrorStatus enumeration value:
    667            *          - SUCCESS: Operation done
    668            *          - ERROR: Operation failed
    669            */

   \                                 In section .text, align 2, keep-with-next
    670          ErrorStatus CRYP_AES_GCM(uint8_t Mode, uint8_t InitVectors[16],
    671                                   uint8_t *Key, uint16_t Keysize,
    672                                   uint8_t *Input, uint32_t ILength,
    673                                   uint8_t *Header, uint32_t HLength,
    674                                   uint8_t *Output, uint8_t *AuthTAG)
    675          {
   \                     CRYP_AES_GCM: (+1)
   \        0x0   0xE92D 0x4FF9      PUSH     {R0,R3-R11,LR}
   \        0x4   0xB095             SUB      SP,SP,#+84
   \        0x6   0x9E20             LDR      R6,[SP, #+128]
   \        0x8   0xF8DD 0x8088      LDR      R8,[SP, #+136]
   \        0xC   0x9F24             LDR      R7,[SP, #+144]
   \        0xE   0xF8DD 0x9094      LDR      R9,[SP, #+148]
    676            CRYP_InitTypeDef AES_CRYP_InitStructure;
    677            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
    678            CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
    679            __IO uint32_t counter = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x9000             STR      R0,[SP, #+0]
    680            uint32_t busystatus = 0;
   \       0x16   0x2000             MOVS     R0,#+0
    681            ErrorStatus status = SUCCESS;
   \       0x18   0x2401             MOVS     R4,#+1
    682            uint32_t keyaddr    = (uint32_t)Key;
   \       0x1A   0x0015             MOVS     R5,R2
    683            uint32_t inputaddr  = (uint32_t)Input;
    684            uint32_t outputaddr = (uint32_t)Output;
    685            uint32_t ivaddr     = (uint32_t)InitVectors;
   \       0x1C   0x9100             STR      R1,[SP, #+0]
    686            uint32_t headeraddr = (uint32_t)Header;
    687            uint32_t tagaddr = (uint32_t)AuthTAG;
   \       0x1E   0x4648             MOV      R0,R9
    688            uint64_t headerlength = HLength * 8;/* header length in bits */
   \       0x20   0x9823             LDR      R0,[SP, #+140]
   \       0x22   0xEA5F 0x0AC0      LSLS     R10,R0,#+3
   \       0x26   0xF05F 0x0B00      MOVS     R11,#+0
    689            uint64_t inputlength = ILength * 8;/* input length in bits */
   \       0x2A   0x9821             LDR      R0,[SP, #+132]
   \       0x2C   0x00C0             LSLS     R0,R0,#+3
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0xE9CD 0x0106      STRD     R0,R1,[SP, #+24]
    690            uint32_t loopcounter = 0;
   \       0x34   0x2000             MOVS     R0,#+0
    691          
    692            /* Crypto structures initialisation*/
    693            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \       0x36   0xA808             ADD      R0,SP,#+32
   \       0x38   0x....'....        BL       CRYP_KeyStructInit
    694          
    695            switch(Keysize)
   \       0x3C   0xF8BD 0x0058      LDRH     R0,[SP, #+88]
   \       0x40   0x2880             CMP      R0,#+128
   \       0x42   0xD005             BEQ.N    ??CRYP_AES_GCM_0
   \       0x44   0x28C0             CMP      R0,#+192
   \       0x46   0xD015             BEQ.N    ??CRYP_AES_GCM_1
   \       0x48   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x4C   0xD02D             BEQ.N    ??CRYP_AES_GCM_2
   \       0x4E   0xE04F             B.N      ??CRYP_AES_GCM_3
    696            {
    697              case 128:
    698              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_GCM_0: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x9004             STR      R0,[SP, #+16]
    699              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \       0x54   0x6828             LDR      R0,[R5, #+0]
   \       0x56   0xBA00             REV      R0,R0
   \       0x58   0x900C             STR      R0,[SP, #+48]
    700              keyaddr+=4;
   \       0x5A   0x1D2D             ADDS     R5,R5,#+4
    701              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \       0x5C   0x6828             LDR      R0,[R5, #+0]
   \       0x5E   0xBA00             REV      R0,R0
   \       0x60   0x900D             STR      R0,[SP, #+52]
    702              keyaddr+=4;
   \       0x62   0x1D2D             ADDS     R5,R5,#+4
    703              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \       0x64   0x6828             LDR      R0,[R5, #+0]
   \       0x66   0xBA00             REV      R0,R0
   \       0x68   0x900E             STR      R0,[SP, #+56]
    704              keyaddr+=4;
   \       0x6A   0x1D2D             ADDS     R5,R5,#+4
    705              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \       0x6C   0x6828             LDR      R0,[R5, #+0]
   \       0x6E   0xBA00             REV      R0,R0
   \       0x70   0x900F             STR      R0,[SP, #+60]
    706              break;
   \       0x72   0xE03D             B.N      ??CRYP_AES_GCM_4
    707              case 192:
    708              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_GCM_1: (+1)
   \       0x74   0xF44F 0x7080      MOV      R0,#+256
   \       0x78   0x9004             STR      R0,[SP, #+16]
    709              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \       0x7A   0x6828             LDR      R0,[R5, #+0]
   \       0x7C   0xBA00             REV      R0,R0
   \       0x7E   0x900A             STR      R0,[SP, #+40]
    710              keyaddr+=4;
   \       0x80   0x1D2D             ADDS     R5,R5,#+4
    711              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \       0x82   0x6828             LDR      R0,[R5, #+0]
   \       0x84   0xBA00             REV      R0,R0
   \       0x86   0x900B             STR      R0,[SP, #+44]
    712              keyaddr+=4;
   \       0x88   0x1D2D             ADDS     R5,R5,#+4
    713              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \       0x8A   0x6828             LDR      R0,[R5, #+0]
   \       0x8C   0xBA00             REV      R0,R0
   \       0x8E   0x900C             STR      R0,[SP, #+48]
    714              keyaddr+=4;
   \       0x90   0x1D2D             ADDS     R5,R5,#+4
    715              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \       0x92   0x6828             LDR      R0,[R5, #+0]
   \       0x94   0xBA00             REV      R0,R0
   \       0x96   0x900D             STR      R0,[SP, #+52]
    716              keyaddr+=4;
   \       0x98   0x1D2D             ADDS     R5,R5,#+4
    717              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \       0x9A   0x6828             LDR      R0,[R5, #+0]
   \       0x9C   0xBA00             REV      R0,R0
   \       0x9E   0x900E             STR      R0,[SP, #+56]
    718              keyaddr+=4;
   \       0xA0   0x1D2D             ADDS     R5,R5,#+4
    719              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \       0xA2   0x6828             LDR      R0,[R5, #+0]
   \       0xA4   0xBA00             REV      R0,R0
   \       0xA6   0x900F             STR      R0,[SP, #+60]
    720              break;
   \       0xA8   0xE022             B.N      ??CRYP_AES_GCM_4
    721              case 256:
    722              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_GCM_2: (+1)
   \       0xAA   0xF44F 0x7000      MOV      R0,#+512
   \       0xAE   0x9004             STR      R0,[SP, #+16]
    723              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \       0xB0   0x6828             LDR      R0,[R5, #+0]
   \       0xB2   0xBA00             REV      R0,R0
   \       0xB4   0x9008             STR      R0,[SP, #+32]
    724              keyaddr+=4;
   \       0xB6   0x1D2D             ADDS     R5,R5,#+4
    725              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \       0xB8   0x6828             LDR      R0,[R5, #+0]
   \       0xBA   0xBA00             REV      R0,R0
   \       0xBC   0x9009             STR      R0,[SP, #+36]
    726              keyaddr+=4;
   \       0xBE   0x1D2D             ADDS     R5,R5,#+4
    727              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \       0xC0   0x6828             LDR      R0,[R5, #+0]
   \       0xC2   0xBA00             REV      R0,R0
   \       0xC4   0x900A             STR      R0,[SP, #+40]
    728              keyaddr+=4;
   \       0xC6   0x1D2D             ADDS     R5,R5,#+4
    729              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \       0xC8   0x6828             LDR      R0,[R5, #+0]
   \       0xCA   0xBA00             REV      R0,R0
   \       0xCC   0x900B             STR      R0,[SP, #+44]
    730              keyaddr+=4;
   \       0xCE   0x1D2D             ADDS     R5,R5,#+4
    731              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \       0xD0   0x6828             LDR      R0,[R5, #+0]
   \       0xD2   0xBA00             REV      R0,R0
   \       0xD4   0x900C             STR      R0,[SP, #+48]
    732              keyaddr+=4;
   \       0xD6   0x1D2D             ADDS     R5,R5,#+4
    733              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \       0xD8   0x6828             LDR      R0,[R5, #+0]
   \       0xDA   0xBA00             REV      R0,R0
   \       0xDC   0x900D             STR      R0,[SP, #+52]
    734              keyaddr+=4;
   \       0xDE   0x1D2D             ADDS     R5,R5,#+4
    735              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \       0xE0   0x6828             LDR      R0,[R5, #+0]
   \       0xE2   0xBA00             REV      R0,R0
   \       0xE4   0x900E             STR      R0,[SP, #+56]
    736              keyaddr+=4;
   \       0xE6   0x1D2D             ADDS     R5,R5,#+4
    737              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \       0xE8   0x6828             LDR      R0,[R5, #+0]
   \       0xEA   0xBA00             REV      R0,R0
   \       0xEC   0x900F             STR      R0,[SP, #+60]
    738              break;
   \       0xEE   0xE7FF             B.N      ??CRYP_AES_GCM_4
    739              default:
    740              break;
   \                     ??CRYP_AES_GCM_3: (+1)
   \                     ??CRYP_AES_GCM_4: (+1)
   \       0xF0   0xF89D 0x0054      LDRB     R0,[SP, #+84]
    741            }
    742            
    743            /* CRYP Initialization Vectors */
    744            AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
   \       0xF4   0x9900             LDR      R1,[SP, #+0]
   \       0xF6   0x6809             LDR      R1,[R1, #+0]
   \       0xF8   0xBA09             REV      R1,R1
   \       0xFA   0x9110             STR      R1,[SP, #+64]
    745            ivaddr+=4;
   \       0xFC   0x9900             LDR      R1,[SP, #+0]
   \       0xFE   0x1D09             ADDS     R1,R1,#+4
    746            AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
   \      0x100   0x680A             LDR      R2,[R1, #+0]
   \      0x102   0xBA12             REV      R2,R2
   \      0x104   0x9211             STR      R2,[SP, #+68]
    747            ivaddr+=4;
   \      0x106   0x1D09             ADDS     R1,R1,#+4
    748            AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
   \      0x108   0x680A             LDR      R2,[R1, #+0]
   \      0x10A   0xBA12             REV      R2,R2
   \      0x10C   0x9212             STR      R2,[SP, #+72]
    749            ivaddr+=4;
   \      0x10E   0x1D09             ADDS     R1,R1,#+4
    750            AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
   \      0x110   0x6809             LDR      R1,[R1, #+0]
   \      0x112   0xBA09             REV      R1,R1
   \      0x114   0x9113             STR      R1,[SP, #+76]
    751            
    752            /*------------------ AES Encryption ------------------*/
    753            if(Mode == MODE_ENCRYPT) /* AES encryption */
   \      0x116   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x118   0x2801             CMP      R0,#+1
   \      0x11A   0xF040 0x80F3      BNE.W    ??CRYP_AES_GCM_5
    754            {
    755              /* Flush IN/OUT FIFOs */
    756              CRYP_FIFOFlush();
   \      0x11E   0x....'....        BL       CRYP_FIFOFlush
    757              
    758              /* Key Initialisation */
    759              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \      0x122   0xA808             ADD      R0,SP,#+32
   \      0x124   0x....'....        BL       CRYP_KeyInit
    760              
    761              /* CRYP Initialization Vectors */
    762              CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \      0x128   0xA810             ADD      R0,SP,#+64
   \      0x12A   0x....'....        BL       CRYP_IVInit
    763              
    764              /* Crypto Init for Key preparation for decryption process */
    765              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
   \      0x12E   0x2000             MOVS     R0,#+0
   \      0x130   0x9001             STR      R0,[SP, #+4]
    766              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_GCM;
   \      0x132   0xF45F 0x2000      MOVS     R0,#+524288
   \      0x136   0x9002             STR      R0,[SP, #+8]
    767              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \      0x138   0x2080             MOVS     R0,#+128
   \      0x13A   0x9003             STR      R0,[SP, #+12]
    768              CRYP_Init(&AES_CRYP_InitStructure);
   \      0x13C   0xA801             ADD      R0,SP,#+4
   \      0x13E   0x....'....        BL       CRYP_Init
    769              
    770              /***************************** Init phase *********************************/
    771              /* Select init phase */
    772              CRYP_PhaseConfig(CRYP_Phase_Init);
   \      0x142   0x2000             MOVS     R0,#+0
   \      0x144   0x....'....        BL       CRYP_PhaseConfig
    773              
    774              /* Enable Crypto processor */
    775              CRYP_Cmd(ENABLE);
   \      0x148   0x2001             MOVS     R0,#+1
   \      0x14A   0x....'....        BL       CRYP_Cmd
    776              
    777              /* Wait for CRYPEN bit to be 0 */
    778              while(CRYP_GetCmdStatus() == ENABLE)
   \                     ??CRYP_AES_GCM_6: (+1)
   \      0x14E   0x....'....        BL       CRYP_GetCmdStatus
   \      0x152   0x2801             CMP      R0,#+1
   \      0x154   0xD0FB             BEQ.N    ??CRYP_AES_GCM_6
    779              {
    780              }
    781              
    782              /***************************** header phase *******************************/
    783              if(HLength != 0)
   \      0x156   0x9823             LDR      R0,[SP, #+140]
   \      0x158   0x2800             CMP      R0,#+0
   \      0x15A   0xD040             BEQ.N    ??CRYP_AES_GCM_7
    784              {
    785                /* Select header phase */
    786                CRYP_PhaseConfig(CRYP_Phase_Header);
   \      0x15C   0xF45F 0x3080      MOVS     R0,#+65536
   \      0x160   0x....'....        BL       CRYP_PhaseConfig
    787                
    788                /* Enable Crypto processor */
    789                CRYP_Cmd(ENABLE);
   \      0x164   0x2001             MOVS     R0,#+1
   \      0x166   0x....'....        BL       CRYP_Cmd
    790                
    791                if(CRYP_GetCmdStatus() == DISABLE)
   \      0x16A   0x....'....        BL       CRYP_GetCmdStatus
   \      0x16E   0x2800             CMP      R0,#+0
   \      0x170   0xD101             BNE.N    ??CRYP_AES_GCM_8
    792                {
    793                   /* The CRYP peripheral clock is not enabled or the device doesn't embed 
    794                      the CRYP peripheral (please check the device sales type. */
    795                   return(ERROR);
   \      0x172   0x2000             MOVS     R0,#+0
   \      0x174   0xE1BD             B.N      ??CRYP_AES_GCM_9
    796                }
    797                
    798                for(loopcounter = 0; (loopcounter < HLength); loopcounter+=16)
   \                     ??CRYP_AES_GCM_8: (+1)
   \      0x176   0x2500             MOVS     R5,#+0
   \      0x178   0xE01D             B.N      ??CRYP_AES_GCM_10
    799                {
    800                  /* Wait until the IFEM flag is reset */
    801                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   \                     ??CRYP_AES_GCM_11: (+1)
   \      0x17A   0x2001             MOVS     R0,#+1
   \      0x17C   0x....'....        BL       CRYP_GetFlagStatus
   \      0x180   0x2800             CMP      R0,#+0
   \      0x182   0xD0FA             BEQ.N    ??CRYP_AES_GCM_11
    802                  {
    803                  }
    804                  
    805                  /* Write the Input block in the IN FIFO */
    806                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x184   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x188   0x....'....        BL       CRYP_DataIn
    807                  headeraddr+=4;
   \      0x18C   0xF118 0x0804      ADDS     R8,R8,#+4
    808                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x190   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x194   0x....'....        BL       CRYP_DataIn
    809                  headeraddr+=4;
   \      0x198   0xF118 0x0804      ADDS     R8,R8,#+4
    810                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x19C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x1A0   0x....'....        BL       CRYP_DataIn
    811                  headeraddr+=4;
   \      0x1A4   0xF118 0x0804      ADDS     R8,R8,#+4
    812                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x1A8   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x1AC   0x....'....        BL       CRYP_DataIn
    813                  headeraddr+=4;
   \      0x1B0   0xF118 0x0804      ADDS     R8,R8,#+4
    814                }
   \      0x1B4   0x3510             ADDS     R5,R5,#+16
   \                     ??CRYP_AES_GCM_10: (+1)
   \      0x1B6   0x9823             LDR      R0,[SP, #+140]
   \      0x1B8   0x4285             CMP      R5,R0
   \      0x1BA   0xD3DE             BCC.N    ??CRYP_AES_GCM_11
    815                
    816                /* Wait until the complete message has been processed */
    817                counter = 0;
   \      0x1BC   0x2000             MOVS     R0,#+0
   \      0x1BE   0x9000             STR      R0,[SP, #+0]
    818                do
    819                {
    820                  busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_GCM_12: (+1)
   \      0x1C0   0x2010             MOVS     R0,#+16
   \      0x1C2   0x....'....        BL       CRYP_GetFlagStatus
    821                  counter++;
   \      0x1C6   0x9900             LDR      R1,[SP, #+0]
   \      0x1C8   0x1C49             ADDS     R1,R1,#+1
   \      0x1CA   0x9100             STR      R1,[SP, #+0]
    822                }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \      0x1CC   0x9900             LDR      R1,[SP, #+0]
   \      0x1CE   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x1D2   0xD001             BEQ.N    ??CRYP_AES_GCM_13
   \      0x1D4   0x2800             CMP      R0,#+0
   \      0x1D6   0xD1F3             BNE.N    ??CRYP_AES_GCM_12
    823          
    824                if (busystatus != RESET)
   \                     ??CRYP_AES_GCM_13: (+1)
   \      0x1D8   0x2800             CMP      R0,#+0
   \      0x1DA   0xD000             BEQ.N    ??CRYP_AES_GCM_7
    825                {
    826                  status = ERROR;
   \      0x1DC   0x2400             MOVS     R4,#+0
    827                }
    828              }
    829              
    830              /**************************** payload phase *******************************/
    831              if(ILength != 0)
   \                     ??CRYP_AES_GCM_7: (+1)
   \      0x1DE   0x9821             LDR      R0,[SP, #+132]
   \      0x1E0   0x2800             CMP      R0,#+0
   \      0x1E2   0xD052             BEQ.N    ??CRYP_AES_GCM_14
    832              {
    833                /* Select payload phase */
    834                CRYP_PhaseConfig(CRYP_Phase_Payload);
   \      0x1E4   0xF45F 0x3000      MOVS     R0,#+131072
   \      0x1E8   0x....'....        BL       CRYP_PhaseConfig
    835                
    836                /* Enable Crypto processor */
    837                CRYP_Cmd(ENABLE);
   \      0x1EC   0x2001             MOVS     R0,#+1
   \      0x1EE   0x....'....        BL       CRYP_Cmd
    838                
    839                if(CRYP_GetCmdStatus() == DISABLE)
   \      0x1F2   0x....'....        BL       CRYP_GetCmdStatus
   \      0x1F6   0x2800             CMP      R0,#+0
   \      0x1F8   0xD101             BNE.N    ??CRYP_AES_GCM_15
    840                {
    841                  /* The CRYP peripheral clock is not enabled or the device doesn't embed 
    842                     the CRYP peripheral (please check the device sales type. */
    843                  return(ERROR);
   \      0x1FA   0x2000             MOVS     R0,#+0
   \      0x1FC   0xE179             B.N      ??CRYP_AES_GCM_9
    844                }
    845                
    846                for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
   \                     ??CRYP_AES_GCM_15: (+1)
   \      0x1FE   0x2500             MOVS     R5,#+0
   \      0x200   0xE03C             B.N      ??CRYP_AES_GCM_16
    847                {
    848                  /* Wait until the IFEM flag is reset */
    849                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
    850                  {
    851                  }
    852                  /* Write the Input block in the IN FIFO */
    853                  CRYP_DataIn(*(uint32_t*)(inputaddr));
    854                  inputaddr+=4;
    855                  CRYP_DataIn(*(uint32_t*)(inputaddr));
    856                  inputaddr+=4;
    857                  CRYP_DataIn(*(uint32_t*)(inputaddr));
    858                  inputaddr+=4;
    859                  CRYP_DataIn(*(uint32_t*)(inputaddr));
    860                  inputaddr+=4;
    861                  
    862                  /* Wait until the complete message has been processed */
    863                  counter = 0;
    864                  do
    865                  {
    866                    busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
    867                    counter++;
    868                  }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
    869          
    870                  if (busystatus != RESET)
    871                  {
    872                    status = ERROR;
    873                  }
    874                  else
    875                  {
    876                    /* Wait until the OFNE flag is reset */
    877                    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_GCM_17: (+1)
   \      0x202   0x2004             MOVS     R0,#+4
   \      0x204   0x....'....        BL       CRYP_GetFlagStatus
   \      0x208   0x2800             CMP      R0,#+0
   \      0x20A   0xD0FA             BEQ.N    ??CRYP_AES_GCM_17
    878                    {
    879                    }
    880                    
    881                    /* Read the Output block from the Output FIFO */
    882                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x20C   0x....'....        BL       CRYP_DataOut
   \      0x210   0x6038             STR      R0,[R7, #+0]
    883                    outputaddr+=4;
   \      0x212   0x1D3F             ADDS     R7,R7,#+4
    884                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x214   0x....'....        BL       CRYP_DataOut
   \      0x218   0x6038             STR      R0,[R7, #+0]
    885                    outputaddr+=4;
   \      0x21A   0x1D3F             ADDS     R7,R7,#+4
    886                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x21C   0x....'....        BL       CRYP_DataOut
   \      0x220   0x6038             STR      R0,[R7, #+0]
    887                    outputaddr+=4;
   \      0x222   0x1D3F             ADDS     R7,R7,#+4
    888                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x224   0x....'....        BL       CRYP_DataOut
   \      0x228   0x6038             STR      R0,[R7, #+0]
    889                    outputaddr+=4;
   \      0x22A   0x1D3F             ADDS     R7,R7,#+4
   \      0x22C   0xE025             B.N      ??CRYP_AES_GCM_18
    890                  }
   \                     ??CRYP_AES_GCM_19: (+1)
   \      0x22E   0x2001             MOVS     R0,#+1
   \      0x230   0x....'....        BL       CRYP_GetFlagStatus
   \      0x234   0x2800             CMP      R0,#+0
   \      0x236   0xD0FA             BEQ.N    ??CRYP_AES_GCM_19
   \      0x238   0x6830             LDR      R0,[R6, #+0]
   \      0x23A   0x....'....        BL       CRYP_DataIn
   \      0x23E   0x1D36             ADDS     R6,R6,#+4
   \      0x240   0x6830             LDR      R0,[R6, #+0]
   \      0x242   0x....'....        BL       CRYP_DataIn
   \      0x246   0x1D36             ADDS     R6,R6,#+4
   \      0x248   0x6830             LDR      R0,[R6, #+0]
   \      0x24A   0x....'....        BL       CRYP_DataIn
   \      0x24E   0x1D36             ADDS     R6,R6,#+4
   \      0x250   0x6830             LDR      R0,[R6, #+0]
   \      0x252   0x....'....        BL       CRYP_DataIn
   \      0x256   0x1D36             ADDS     R6,R6,#+4
   \      0x258   0x2000             MOVS     R0,#+0
   \      0x25A   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_GCM_20: (+1)
   \      0x25C   0x2010             MOVS     R0,#+16
   \      0x25E   0x....'....        BL       CRYP_GetFlagStatus
   \      0x262   0x9900             LDR      R1,[SP, #+0]
   \      0x264   0x1C49             ADDS     R1,R1,#+1
   \      0x266   0x9100             STR      R1,[SP, #+0]
   \      0x268   0x9900             LDR      R1,[SP, #+0]
   \      0x26A   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x26E   0xD001             BEQ.N    ??CRYP_AES_GCM_21
   \      0x270   0x2800             CMP      R0,#+0
   \      0x272   0xD1F3             BNE.N    ??CRYP_AES_GCM_20
   \                     ??CRYP_AES_GCM_21: (+1)
   \      0x274   0x2800             CMP      R0,#+0
   \      0x276   0xD0C4             BEQ.N    ??CRYP_AES_GCM_17
   \      0x278   0x2400             MOVS     R4,#+0
    891                }
   \                     ??CRYP_AES_GCM_18: (+1)
   \      0x27A   0x3510             ADDS     R5,R5,#+16
   \                     ??CRYP_AES_GCM_16: (+1)
   \      0x27C   0x9821             LDR      R0,[SP, #+132]
   \      0x27E   0x4285             CMP      R5,R0
   \      0x280   0xD203             BCS.N    ??CRYP_AES_GCM_14
   \      0x282   0x0020             MOVS     R0,R4
   \      0x284   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x286   0x2800             CMP      R0,#+0
   \      0x288   0xD1D1             BNE.N    ??CRYP_AES_GCM_19
    892              }
    893              
    894              /***************************** final phase ********************************/
    895              /* Select final phase */
    896              CRYP_PhaseConfig(CRYP_Phase_Final);
   \                     ??CRYP_AES_GCM_14: (+1)
   \      0x28A   0xF45F 0x3040      MOVS     R0,#+196608
   \      0x28E   0x....'....        BL       CRYP_PhaseConfig
    897              
    898              /* Enable Crypto processor */
    899              CRYP_Cmd(ENABLE);
   \      0x292   0x2001             MOVS     R0,#+1
   \      0x294   0x....'....        BL       CRYP_Cmd
    900              
    901              if(CRYP_GetCmdStatus() == DISABLE)
   \      0x298   0x....'....        BL       CRYP_GetCmdStatus
   \      0x29C   0x2800             CMP      R0,#+0
   \      0x29E   0xD101             BNE.N    ??CRYP_AES_GCM_22
    902              {
    903                /* The CRYP peripheral clock is not enabled or the device doesn't embed 
    904                   the CRYP peripheral (please check the device sales type. */
    905                return(ERROR);
   \      0x2A0   0x2000             MOVS     R0,#+0
   \      0x2A2   0xE126             B.N      ??CRYP_AES_GCM_9
    906              }
    907              
    908              /* Write number of bits concatenated with header in the IN FIFO */
    909              CRYP_DataIn(__REV(headerlength>>32));
   \                     ??CRYP_AES_GCM_22: (+1)
   \      0x2A4   0xFA9B 0xF08B      REV      R0,R11
   \      0x2A8   0x....'....        BL       CRYP_DataIn
    910              CRYP_DataIn(__REV(headerlength));
   \      0x2AC   0xFA9A 0xF08A      REV      R0,R10
   \      0x2B0   0x....'....        BL       CRYP_DataIn
    911              CRYP_DataIn(__REV(inputlength>>32));
   \      0x2B4   0xE9DD 0x0106      LDRD     R0,R1,[SP, #+24]
   \      0x2B8   0xBA08             REV      R0,R1
   \      0x2BA   0x....'....        BL       CRYP_DataIn
    912              CRYP_DataIn(__REV(inputlength));
   \      0x2BE   0xE9DD 0x0106      LDRD     R0,R1,[SP, #+24]
   \      0x2C2   0xBA00             REV      R0,R0
   \      0x2C4   0x....'....        BL       CRYP_DataIn
    913              /* Wait until the OFNE flag is reset */
    914              while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_GCM_23: (+1)
   \      0x2C8   0x2004             MOVS     R0,#+4
   \      0x2CA   0x....'....        BL       CRYP_GetFlagStatus
   \      0x2CE   0x2800             CMP      R0,#+0
   \      0x2D0   0xD0FA             BEQ.N    ??CRYP_AES_GCM_23
    915              {
    916              }
    917              
    918              tagaddr = (uint32_t)AuthTAG;
    919              /* Read the Auth TAG in the IN FIFO */
    920              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \      0x2D2   0x....'....        BL       CRYP_DataOut
   \      0x2D6   0xF8C9 0x0000      STR      R0,[R9, #+0]
    921              tagaddr+=4;
   \      0x2DA   0xF119 0x0904      ADDS     R9,R9,#+4
    922              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \      0x2DE   0x....'....        BL       CRYP_DataOut
   \      0x2E2   0xF8C9 0x0000      STR      R0,[R9, #+0]
    923              tagaddr+=4;
   \      0x2E6   0xF119 0x0904      ADDS     R9,R9,#+4
    924              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \      0x2EA   0x....'....        BL       CRYP_DataOut
   \      0x2EE   0xF8C9 0x0000      STR      R0,[R9, #+0]
    925              tagaddr+=4;
   \      0x2F2   0xF119 0x0904      ADDS     R9,R9,#+4
    926              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \      0x2F6   0x....'....        BL       CRYP_DataOut
   \      0x2FA   0xF8C9 0x0000      STR      R0,[R9, #+0]
    927              tagaddr+=4;
   \      0x2FE   0xF119 0x0904      ADDS     R9,R9,#+4
   \      0x302   0xE0F1             B.N      ??CRYP_AES_GCM_24
    928            }
    929            /*------------------ AES Decryption ------------------*/
    930            else /* AES decryption */
    931            {
    932              /* Flush IN/OUT FIFOs */
    933              CRYP_FIFOFlush();
   \                     ??CRYP_AES_GCM_5: (+1)
   \      0x304   0x....'....        BL       CRYP_FIFOFlush
    934              
    935              /* Key Initialisation */
    936              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \      0x308   0xA808             ADD      R0,SP,#+32
   \      0x30A   0x....'....        BL       CRYP_KeyInit
    937              
    938              /* CRYP Initialization Vectors */
    939              CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \      0x30E   0xA810             ADD      R0,SP,#+64
   \      0x310   0x....'....        BL       CRYP_IVInit
    940              
    941              /* Crypto Init for Key preparation for decryption process */
    942              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \      0x314   0x2004             MOVS     R0,#+4
   \      0x316   0x9001             STR      R0,[SP, #+4]
    943              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_GCM;
   \      0x318   0xF45F 0x2000      MOVS     R0,#+524288
   \      0x31C   0x9002             STR      R0,[SP, #+8]
    944              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \      0x31E   0x2080             MOVS     R0,#+128
   \      0x320   0x9003             STR      R0,[SP, #+12]
    945              CRYP_Init(&AES_CRYP_InitStructure);
   \      0x322   0xA801             ADD      R0,SP,#+4
   \      0x324   0x....'....        BL       CRYP_Init
    946              
    947              /***************************** Init phase *********************************/
    948              /* Select init phase */
    949              CRYP_PhaseConfig(CRYP_Phase_Init);
   \      0x328   0x2000             MOVS     R0,#+0
   \      0x32A   0x....'....        BL       CRYP_PhaseConfig
    950              
    951              /* Enable Crypto processor */
    952              CRYP_Cmd(ENABLE);
   \      0x32E   0x2001             MOVS     R0,#+1
   \      0x330   0x....'....        BL       CRYP_Cmd
    953              
    954              /* Wait for CRYPEN bit to be 0 */
    955              while(CRYP_GetCmdStatus() == ENABLE)
   \                     ??CRYP_AES_GCM_25: (+1)
   \      0x334   0x....'....        BL       CRYP_GetCmdStatus
   \      0x338   0x2801             CMP      R0,#+1
   \      0x33A   0xD0FB             BEQ.N    ??CRYP_AES_GCM_25
    956              {
    957              }
    958              
    959              /***************************** header phase *******************************/
    960              if(HLength != 0)
   \      0x33C   0x9823             LDR      R0,[SP, #+140]
   \      0x33E   0x2800             CMP      R0,#+0
   \      0x340   0xD040             BEQ.N    ??CRYP_AES_GCM_26
    961              {
    962                /* Select header phase */
    963                CRYP_PhaseConfig(CRYP_Phase_Header);
   \      0x342   0xF45F 0x3080      MOVS     R0,#+65536
   \      0x346   0x....'....        BL       CRYP_PhaseConfig
    964                
    965                /* Enable Crypto processor */
    966                CRYP_Cmd(ENABLE);
   \      0x34A   0x2001             MOVS     R0,#+1
   \      0x34C   0x....'....        BL       CRYP_Cmd
    967                
    968                if(CRYP_GetCmdStatus() == DISABLE)
   \      0x350   0x....'....        BL       CRYP_GetCmdStatus
   \      0x354   0x2800             CMP      R0,#+0
   \      0x356   0xD101             BNE.N    ??CRYP_AES_GCM_27
    969                {
    970                  /* The CRYP peripheral clock is not enabled or the device doesn't embed 
    971                     the CRYP peripheral (please check the device sales type. */
    972                  return(ERROR);
   \      0x358   0x2000             MOVS     R0,#+0
   \      0x35A   0xE0CA             B.N      ??CRYP_AES_GCM_9
    973                }
    974                
    975                for(loopcounter = 0; (loopcounter < HLength); loopcounter+=16)
   \                     ??CRYP_AES_GCM_27: (+1)
   \      0x35C   0x2500             MOVS     R5,#+0
   \      0x35E   0xE01D             B.N      ??CRYP_AES_GCM_28
    976                {
    977                  /* Wait until the IFEM flag is reset */
    978                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   \                     ??CRYP_AES_GCM_29: (+1)
   \      0x360   0x2001             MOVS     R0,#+1
   \      0x362   0x....'....        BL       CRYP_GetFlagStatus
   \      0x366   0x2800             CMP      R0,#+0
   \      0x368   0xD0FA             BEQ.N    ??CRYP_AES_GCM_29
    979                  {
    980                  }
    981                  
    982                  /* Write the Input block in the IN FIFO */
    983                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x36A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x36E   0x....'....        BL       CRYP_DataIn
    984                  headeraddr+=4;
   \      0x372   0xF118 0x0804      ADDS     R8,R8,#+4
    985                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x376   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x37A   0x....'....        BL       CRYP_DataIn
    986                  headeraddr+=4;
   \      0x37E   0xF118 0x0804      ADDS     R8,R8,#+4
    987                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x382   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x386   0x....'....        BL       CRYP_DataIn
    988                  headeraddr+=4;
   \      0x38A   0xF118 0x0804      ADDS     R8,R8,#+4
    989                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x38E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x392   0x....'....        BL       CRYP_DataIn
    990                  headeraddr+=4;
   \      0x396   0xF118 0x0804      ADDS     R8,R8,#+4
    991                }
   \      0x39A   0x3510             ADDS     R5,R5,#+16
   \                     ??CRYP_AES_GCM_28: (+1)
   \      0x39C   0x9823             LDR      R0,[SP, #+140]
   \      0x39E   0x4285             CMP      R5,R0
   \      0x3A0   0xD3DE             BCC.N    ??CRYP_AES_GCM_29
    992                
    993                /* Wait until the complete message has been processed */
    994                counter = 0;
   \      0x3A2   0x2000             MOVS     R0,#+0
   \      0x3A4   0x9000             STR      R0,[SP, #+0]
    995                do
    996                {
    997                  busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_GCM_30: (+1)
   \      0x3A6   0x2010             MOVS     R0,#+16
   \      0x3A8   0x....'....        BL       CRYP_GetFlagStatus
    998                  counter++;
   \      0x3AC   0x9900             LDR      R1,[SP, #+0]
   \      0x3AE   0x1C49             ADDS     R1,R1,#+1
   \      0x3B0   0x9100             STR      R1,[SP, #+0]
    999                }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \      0x3B2   0x9900             LDR      R1,[SP, #+0]
   \      0x3B4   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x3B8   0xD001             BEQ.N    ??CRYP_AES_GCM_31
   \      0x3BA   0x2800             CMP      R0,#+0
   \      0x3BC   0xD1F3             BNE.N    ??CRYP_AES_GCM_30
   1000          
   1001                if (busystatus != RESET)
   \                     ??CRYP_AES_GCM_31: (+1)
   \      0x3BE   0x2800             CMP      R0,#+0
   \      0x3C0   0xD000             BEQ.N    ??CRYP_AES_GCM_26
   1002                {
   1003                  status = ERROR;
   \      0x3C2   0x2400             MOVS     R4,#+0
   1004                }
   1005              }
   1006              
   1007              /**************************** payload phase *******************************/
   1008              if(ILength != 0)
   \                     ??CRYP_AES_GCM_26: (+1)
   \      0x3C4   0x9821             LDR      R0,[SP, #+132]
   \      0x3C6   0x2800             CMP      R0,#+0
   \      0x3C8   0xD052             BEQ.N    ??CRYP_AES_GCM_32
   1009              {
   1010                /* Select payload phase */
   1011                CRYP_PhaseConfig(CRYP_Phase_Payload);
   \      0x3CA   0xF45F 0x3000      MOVS     R0,#+131072
   \      0x3CE   0x....'....        BL       CRYP_PhaseConfig
   1012          
   1013                /* Enable Crypto processor */
   1014                CRYP_Cmd(ENABLE);
   \      0x3D2   0x2001             MOVS     R0,#+1
   \      0x3D4   0x....'....        BL       CRYP_Cmd
   1015                
   1016                if(CRYP_GetCmdStatus() == DISABLE)
   \      0x3D8   0x....'....        BL       CRYP_GetCmdStatus
   \      0x3DC   0x2800             CMP      R0,#+0
   \      0x3DE   0xD101             BNE.N    ??CRYP_AES_GCM_33
   1017                {
   1018                  /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1019                     the CRYP peripheral (please check the device sales type. */
   1020                  return(ERROR);
   \      0x3E0   0x2000             MOVS     R0,#+0
   \      0x3E2   0xE086             B.N      ??CRYP_AES_GCM_9
   1021                }
   1022                
   1023                for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
   \                     ??CRYP_AES_GCM_33: (+1)
   \      0x3E4   0x2500             MOVS     R5,#+0
   \      0x3E6   0xE03C             B.N      ??CRYP_AES_GCM_34
   1024                {
   1025                  /* Wait until the IFEM flag is reset */
   1026                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   1027                  {
   1028                  }
   1029                  /* Write the Input block in the IN FIFO */
   1030                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1031                  inputaddr+=4;
   1032                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1033                  inputaddr+=4;
   1034                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1035                  inputaddr+=4;
   1036                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1037                  inputaddr+=4;
   1038                  
   1039                  /* Wait until the complete message has been processed */
   1040                  counter = 0;
   1041                  do
   1042                  {
   1043                    busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   1044                    counter++;
   1045                  }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   1046          
   1047                  if (busystatus != RESET)
   1048                  {
   1049                    status = ERROR;
   1050                  }
   1051                  else
   1052                  {
   1053                    /* Wait until the OFNE flag is reset */
   1054                    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_GCM_35: (+1)
   \      0x3E8   0x2004             MOVS     R0,#+4
   \      0x3EA   0x....'....        BL       CRYP_GetFlagStatus
   \      0x3EE   0x2800             CMP      R0,#+0
   \      0x3F0   0xD0FA             BEQ.N    ??CRYP_AES_GCM_35
   1055                    {
   1056                    }
   1057                    
   1058                    /* Read the Output block from the Output FIFO */
   1059                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x3F2   0x....'....        BL       CRYP_DataOut
   \      0x3F6   0x6038             STR      R0,[R7, #+0]
   1060                    outputaddr+=4;
   \      0x3F8   0x1D3F             ADDS     R7,R7,#+4
   1061                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x3FA   0x....'....        BL       CRYP_DataOut
   \      0x3FE   0x6038             STR      R0,[R7, #+0]
   1062                    outputaddr+=4;
   \      0x400   0x1D3F             ADDS     R7,R7,#+4
   1063                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x402   0x....'....        BL       CRYP_DataOut
   \      0x406   0x6038             STR      R0,[R7, #+0]
   1064                    outputaddr+=4;
   \      0x408   0x1D3F             ADDS     R7,R7,#+4
   1065                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x40A   0x....'....        BL       CRYP_DataOut
   \      0x40E   0x6038             STR      R0,[R7, #+0]
   1066                    outputaddr+=4;
   \      0x410   0x1D3F             ADDS     R7,R7,#+4
   \      0x412   0xE025             B.N      ??CRYP_AES_GCM_36
   1067                  }
   \                     ??CRYP_AES_GCM_37: (+1)
   \      0x414   0x2001             MOVS     R0,#+1
   \      0x416   0x....'....        BL       CRYP_GetFlagStatus
   \      0x41A   0x2800             CMP      R0,#+0
   \      0x41C   0xD0FA             BEQ.N    ??CRYP_AES_GCM_37
   \      0x41E   0x6830             LDR      R0,[R6, #+0]
   \      0x420   0x....'....        BL       CRYP_DataIn
   \      0x424   0x1D36             ADDS     R6,R6,#+4
   \      0x426   0x6830             LDR      R0,[R6, #+0]
   \      0x428   0x....'....        BL       CRYP_DataIn
   \      0x42C   0x1D36             ADDS     R6,R6,#+4
   \      0x42E   0x6830             LDR      R0,[R6, #+0]
   \      0x430   0x....'....        BL       CRYP_DataIn
   \      0x434   0x1D36             ADDS     R6,R6,#+4
   \      0x436   0x6830             LDR      R0,[R6, #+0]
   \      0x438   0x....'....        BL       CRYP_DataIn
   \      0x43C   0x1D36             ADDS     R6,R6,#+4
   \      0x43E   0x2000             MOVS     R0,#+0
   \      0x440   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_GCM_38: (+1)
   \      0x442   0x2010             MOVS     R0,#+16
   \      0x444   0x....'....        BL       CRYP_GetFlagStatus
   \      0x448   0x9900             LDR      R1,[SP, #+0]
   \      0x44A   0x1C49             ADDS     R1,R1,#+1
   \      0x44C   0x9100             STR      R1,[SP, #+0]
   \      0x44E   0x9900             LDR      R1,[SP, #+0]
   \      0x450   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x454   0xD001             BEQ.N    ??CRYP_AES_GCM_39
   \      0x456   0x2800             CMP      R0,#+0
   \      0x458   0xD1F3             BNE.N    ??CRYP_AES_GCM_38
   \                     ??CRYP_AES_GCM_39: (+1)
   \      0x45A   0x2800             CMP      R0,#+0
   \      0x45C   0xD0C4             BEQ.N    ??CRYP_AES_GCM_35
   \      0x45E   0x2400             MOVS     R4,#+0
   1068                }
   \                     ??CRYP_AES_GCM_36: (+1)
   \      0x460   0x3510             ADDS     R5,R5,#+16
   \                     ??CRYP_AES_GCM_34: (+1)
   \      0x462   0x9821             LDR      R0,[SP, #+132]
   \      0x464   0x4285             CMP      R5,R0
   \      0x466   0xD203             BCS.N    ??CRYP_AES_GCM_32
   \      0x468   0x0020             MOVS     R0,R4
   \      0x46A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x46C   0x2800             CMP      R0,#+0
   \      0x46E   0xD1D1             BNE.N    ??CRYP_AES_GCM_37
   1069              }
   1070              
   1071              /***************************** final phase ********************************/
   1072              /* Select final phase */
   1073              CRYP_PhaseConfig(CRYP_Phase_Final);
   \                     ??CRYP_AES_GCM_32: (+1)
   \      0x470   0xF45F 0x3040      MOVS     R0,#+196608
   \      0x474   0x....'....        BL       CRYP_PhaseConfig
   1074          
   1075              /* Enable Crypto processor */
   1076              CRYP_Cmd(ENABLE);
   \      0x478   0x2001             MOVS     R0,#+1
   \      0x47A   0x....'....        BL       CRYP_Cmd
   1077              
   1078              if(CRYP_GetCmdStatus() == DISABLE)
   \      0x47E   0x....'....        BL       CRYP_GetCmdStatus
   \      0x482   0x2800             CMP      R0,#+0
   \      0x484   0xD101             BNE.N    ??CRYP_AES_GCM_40
   1079              {
   1080                /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1081                   the CRYP peripheral (please check the device sales type. */
   1082                return(ERROR);
   \      0x486   0x2000             MOVS     R0,#+0
   \      0x488   0xE033             B.N      ??CRYP_AES_GCM_9
   1083              }
   1084              
   1085              /* Write number of bits concatenated with header in the IN FIFO */
   1086              CRYP_DataIn(__REV(headerlength>>32));
   \                     ??CRYP_AES_GCM_40: (+1)
   \      0x48A   0xFA9B 0xF08B      REV      R0,R11
   \      0x48E   0x....'....        BL       CRYP_DataIn
   1087              CRYP_DataIn(__REV(headerlength));
   \      0x492   0xFA9A 0xF08A      REV      R0,R10
   \      0x496   0x....'....        BL       CRYP_DataIn
   1088              CRYP_DataIn(__REV(inputlength>>32));
   \      0x49A   0xE9DD 0x0106      LDRD     R0,R1,[SP, #+24]
   \      0x49E   0xBA08             REV      R0,R1
   \      0x4A0   0x....'....        BL       CRYP_DataIn
   1089              CRYP_DataIn(__REV(inputlength));
   \      0x4A4   0xE9DD 0x0106      LDRD     R0,R1,[SP, #+24]
   \      0x4A8   0xBA00             REV      R0,R0
   \      0x4AA   0x....'....        BL       CRYP_DataIn
   1090              /* Wait until the OFNE flag is reset */
   1091              while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_GCM_41: (+1)
   \      0x4AE   0x2004             MOVS     R0,#+4
   \      0x4B0   0x....'....        BL       CRYP_GetFlagStatus
   \      0x4B4   0x2800             CMP      R0,#+0
   \      0x4B6   0xD0FA             BEQ.N    ??CRYP_AES_GCM_41
   1092              {
   1093              }
   1094              
   1095              tagaddr = (uint32_t)AuthTAG;
   1096              /* Read the Auth TAG in the IN FIFO */
   1097              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \      0x4B8   0x....'....        BL       CRYP_DataOut
   \      0x4BC   0xF8C9 0x0000      STR      R0,[R9, #+0]
   1098              tagaddr+=4;
   \      0x4C0   0xF119 0x0904      ADDS     R9,R9,#+4
   1099              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \      0x4C4   0x....'....        BL       CRYP_DataOut
   \      0x4C8   0xF8C9 0x0000      STR      R0,[R9, #+0]
   1100              tagaddr+=4;
   \      0x4CC   0xF119 0x0904      ADDS     R9,R9,#+4
   1101              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \      0x4D0   0x....'....        BL       CRYP_DataOut
   \      0x4D4   0xF8C9 0x0000      STR      R0,[R9, #+0]
   1102              tagaddr+=4;
   \      0x4D8   0xF119 0x0904      ADDS     R9,R9,#+4
   1103              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \      0x4DC   0x....'....        BL       CRYP_DataOut
   \      0x4E0   0xF8C9 0x0000      STR      R0,[R9, #+0]
   1104              tagaddr+=4;
   \      0x4E4   0xF119 0x0904      ADDS     R9,R9,#+4
   1105            }
   1106            /* Disable Crypto */
   1107            CRYP_Cmd(DISABLE);
   \                     ??CRYP_AES_GCM_24: (+1)
   \      0x4E8   0x2000             MOVS     R0,#+0
   \      0x4EA   0x....'....        BL       CRYP_Cmd
   1108          
   1109            return status;
   \      0x4EE   0x0020             MOVS     R0,R4
   \      0x4F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??CRYP_AES_GCM_9: (+1)
   \      0x4F2   0xB017             ADD      SP,SP,#+92
   \      0x4F4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1110          }
   1111          
   1112          /**
   1113            * @brief  Encrypt and decrypt using AES in CCM Mode. The GCM and CCM modes
   1114            *         are available only on STM32F437x Devices.
   1115            * @param  Mode: encryption or decryption Mode.
   1116            *          This parameter can be one of the following values:
   1117            *            @arg MODE_ENCRYPT: Encryption
   1118            *            @arg MODE_DECRYPT: Decryption
   1119            * @param  Nonce: the nonce used for AES algorithm. It shall be unique for each processing.
   1120            * @param  Key: Key used for AES algorithm.
   1121            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
   1122            * @param  Input: pointer to the Input buffer.
   1123            * @param  Ilength: length of the Input buffer in bytes, must be a multiple of 16.
   1124            * @param  Header: pointer to the header buffer.
   1125            * @param  Hlength: length of the header buffer in bytes.
   1126            * @param  HBuffer: pointer to temporary buffer used to append the header
   1127            *         HBuffer size must be equal to Hlength + 21
   1128            * @param  Output: pointer to the returned buffer.
   1129            * @param  AuthTAG: pointer to the authentication TAG buffer.
   1130            * @param  TAGSize: the size of the TAG (called also MAC).
   1131            * @retval An ErrorStatus enumeration value:
   1132            *          - SUCCESS: Operation done
   1133            *          - ERROR: Operation failed
   1134            */

   \                                 In section .text, align 2, keep-with-next
   1135          ErrorStatus CRYP_AES_CCM(uint8_t Mode, 
   1136                                   uint8_t* Nonce, uint32_t NonceSize,
   1137                                   uint8_t *Key, uint16_t Keysize,
   1138                                   uint8_t *Input, uint32_t ILength,
   1139                                   uint8_t *Header, uint32_t HLength, uint8_t *HBuffer,
   1140                                   uint8_t *Output,
   1141                                   uint8_t *AuthTAG, uint32_t TAGSize)
   1142          {
   \                     CRYP_AES_CCM: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xB09E             SUB      SP,SP,#+120
   \        0x6   0x9F2B             LDR      R7,[SP, #+172]
   \        0x8   0x9C2E             LDR      R4,[SP, #+184]
   \        0xA   0xF8DD 0x80C0      LDR      R8,[SP, #+192]
   1143            CRYP_InitTypeDef AES_CRYP_InitStructure;
   1144            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
   1145            CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
   1146            __IO uint32_t counter = 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x9000             STR      R0,[SP, #+0]
   1147            uint32_t busystatus = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   1148            ErrorStatus status = SUCCESS;
   \       0x14   0x2601             MOVS     R6,#+1
   1149            uint32_t keyaddr    = (uint32_t)Key;
   \       0x16   0x469A             MOV      R10,R3
   1150            uint32_t inputaddr  = (uint32_t)Input;
   1151            uint32_t outputaddr = (uint32_t)Output;
   1152            uint32_t headeraddr = (uint32_t)Header;
   \       0x18   0xF8DD 0x90B4      LDR      R9,[SP, #+180]
   1153            uint32_t tagaddr = (uint32_t)AuthTAG;
   \       0x1C   0x9831             LDR      R0,[SP, #+196]
   \       0x1E   0x9015             STR      R0,[SP, #+84]
   1154            uint32_t headersize = HLength;
   1155            uint32_t loopcounter = 0;
   \       0x20   0x2000             MOVS     R0,#+0
   1156            uint32_t bufferidx = 0;
   \       0x22   0x2500             MOVS     R5,#+0
   \       0x24   0x2210             MOVS     R2,#+16
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0xA801             ADD      R0,SP,#+4
   \       0x2A   0x....'....        BL       memset
   \       0x2E   0x2210             MOVS     R2,#+16
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0xA811             ADD      R0,SP,#+68
   \       0x34   0x....'....        BL       memset
   \       0x38   0x2210             MOVS     R2,#+16
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0xA816             ADD      R0,SP,#+88
   \       0x3E   0x....'....        BL       memset
   1157            uint8_t blockb0[16] = {0};/* Block B0 */
   1158            uint8_t ctr[16] = {0}; /* Counter */
   1159            uint32_t temptag[4] = {0}; /* temporary TAG (MAC) */
   1160            uint32_t ctraddr = (uint32_t)ctr;
   \       0x42   0xF10D 0x0B44      ADD      R11,SP,#+68
   1161            uint32_t b0addr = (uint32_t)blockb0;
   \       0x46   0xA801             ADD      R0,SP,#+4
   1162            
   1163            /************************ Formatting the header block ***********************/
   1164            if(headersize != 0)
   \       0x48   0x2C00             CMP      R4,#+0
   \       0x4A   0xD042             BEQ.N    ??CRYP_AES_CCM_0
   \       0x4C   0xF8DD 0x90BC      LDR      R9,[SP, #+188]
   1165            {
   1166              /* Check that the associated data (or header) length is lower than 2^16 - 2^8 = 65536 - 256 = 65280 */
   1167              if(headersize < 65280)
   \       0x50   0xF5B4 0x4F7F      CMP      R4,#+65280
   \       0x54   0xD209             BCS.N    ??CRYP_AES_CCM_1
   1168              {
   1169                HBuffer[bufferidx++] = (uint8_t) ((headersize >> 8) & 0xFF);
   \       0x56   0x0020             MOVS     R0,R4
   \       0x58   0x0A00             LSRS     R0,R0,#+8
   \       0x5A   0xF809 0x0005      STRB     R0,[R9, R5]
   \       0x5E   0x1C6D             ADDS     R5,R5,#+1
   1170                HBuffer[bufferidx++] = (uint8_t) ((headersize) & 0xFF);
   \       0x60   0xF809 0x4005      STRB     R4,[R9, R5]
   \       0x64   0x1C6D             ADDS     R5,R5,#+1
   1171                headersize += 2;
   \       0x66   0x1CA4             ADDS     R4,R4,#+2
   \       0x68   0xE017             B.N      ??CRYP_AES_CCM_2
   1172              }
   1173              else
   1174              {
   1175                /* header is encoded as 0xff || 0xfe || [headersize]32, i.e., six octets */
   1176                HBuffer[bufferidx++] = 0xFF;
   \                     ??CRYP_AES_CCM_1: (+1)
   \       0x6A   0x20FF             MOVS     R0,#+255
   \       0x6C   0xF809 0x0005      STRB     R0,[R9, R5]
   \       0x70   0x1C6D             ADDS     R5,R5,#+1
   1177                HBuffer[bufferidx++] = 0xFE;
   \       0x72   0x20FE             MOVS     R0,#+254
   \       0x74   0xF809 0x0005      STRB     R0,[R9, R5]
   \       0x78   0x1C6D             ADDS     R5,R5,#+1
   1178                HBuffer[bufferidx++] = headersize & 0xff000000;
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xF809 0x0005      STRB     R0,[R9, R5]
   \       0x80   0x1C6D             ADDS     R5,R5,#+1
   1179                HBuffer[bufferidx++] = headersize & 0x00ff0000;
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xF809 0x0005      STRB     R0,[R9, R5]
   \       0x88   0x1C6D             ADDS     R5,R5,#+1
   1180                HBuffer[bufferidx++] = headersize & 0x0000ff00;
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0xF809 0x0005      STRB     R0,[R9, R5]
   \       0x90   0x1C6D             ADDS     R5,R5,#+1
   1181                HBuffer[bufferidx++] = headersize & 0x000000ff;
   \       0x92   0xF809 0x4005      STRB     R4,[R9, R5]
   \       0x96   0x1C6D             ADDS     R5,R5,#+1
   1182                headersize += 6;
   \       0x98   0x1DA4             ADDS     R4,R4,#+6
   1183              }
   1184              /* Copy the header buffer in internal buffer "HBuffer" */
   1185              for(loopcounter = 0; loopcounter < headersize; loopcounter++)
   \                     ??CRYP_AES_CCM_2: (+1)
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xE005             B.N      ??CRYP_AES_CCM_3
   1186              {
   1187                HBuffer[bufferidx++] = Header[loopcounter];
   \                     ??CRYP_AES_CCM_4: (+1)
   \       0x9E   0x992D             LDR      R1,[SP, #+180]
   \       0xA0   0x5C09             LDRB     R1,[R1, R0]
   \       0xA2   0xF809 0x1005      STRB     R1,[R9, R5]
   \       0xA6   0x1C6D             ADDS     R5,R5,#+1
   1188              }
   \       0xA8   0x1C40             ADDS     R0,R0,#+1
   \                     ??CRYP_AES_CCM_3: (+1)
   \       0xAA   0x42A0             CMP      R0,R4
   \       0xAC   0xD3F7             BCC.N    ??CRYP_AES_CCM_4
   1189              /* Check if the header size is modulo 16 */
   1190              if ((headersize % 16) != 0)
   \       0xAE   0xF014 0x0F0F      TST      R4,#0xF
   \       0xB2   0xD00E             BEQ.N    ??CRYP_AES_CCM_5
   1191              {
   1192                /* Padd the header buffer with 0s till the HBuffer length is modulo 16 */
   1193                for(loopcounter = headersize; loopcounter <= ((headersize/16) + 1) * 16; loopcounter++)
   \       0xB4   0x0020             MOVS     R0,R4
   \       0xB6   0xE003             B.N      ??CRYP_AES_CCM_6
   1194                {
   1195                  HBuffer[loopcounter] = 0;
   \                     ??CRYP_AES_CCM_7: (+1)
   \       0xB8   0x2100             MOVS     R1,#+0
   \       0xBA   0xF809 0x1000      STRB     R1,[R9, R0]
   1196                }
   \       0xBE   0x1C40             ADDS     R0,R0,#+1
   \                     ??CRYP_AES_CCM_6: (+1)
   \       0xC0   0x0021             MOVS     R1,R4
   \       0xC2   0x0909             LSRS     R1,R1,#+4
   \       0xC4   0x1C49             ADDS     R1,R1,#+1
   \       0xC6   0x0109             LSLS     R1,R1,#+4
   \       0xC8   0x4281             CMP      R1,R0
   \       0xCA   0xD2F5             BCS.N    ??CRYP_AES_CCM_7
   1197                /* Set the header size to modulo 16 */
   1198                headersize = ((headersize/16) + 1) * 16;
   \       0xCC   0x0924             LSRS     R4,R4,#+4
   \       0xCE   0x1C64             ADDS     R4,R4,#+1
   \       0xD0   0x0124             LSLS     R4,R4,#+4
   1199              }
   1200              /* set the pointer headeraddr to HBuffer */
   1201              headeraddr = (uint32_t)HBuffer;
   1202            }
   1203            /************************* Formatting the block B0 **************************/
   1204            if(headersize != 0)
   \                     ??CRYP_AES_CCM_5: (+1)
   \                     ??CRYP_AES_CCM_0: (+1)
   \       0xD2   0x2C00             CMP      R4,#+0
   \       0xD4   0xD002             BEQ.N    ??CRYP_AES_CCM_8
   1205            {
   1206              blockb0[0] = 0x40;
   \       0xD6   0x2040             MOVS     R0,#+64
   \       0xD8   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \                     ??CRYP_AES_CCM_8: (+1)
   \       0xDC   0x9820             LDR      R0,[SP, #+128]
   1207            }
   1208            /* Flags byte */
   1209            blockb0[0] |= 0u | (((( (uint8_t) TAGSize - 2) / 2) & 0x07 ) << 3 ) | ( ( (uint8_t) (15 - NonceSize) - 1) & 0x07);
   \       0xDE   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \       0xE2   0xAA32             ADD      R2,SP,#+200
   \       0xE4   0x7812             LDRB     R2,[R2, #+0]
   \       0xE6   0x1E92             SUBS     R2,R2,#+2
   \       0xE8   0x2302             MOVS     R3,#+2
   \       0xEA   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \       0xEE   0x00D2             LSLS     R2,R2,#+3
   \       0xF0   0xF012 0x0238      ANDS     R2,R2,#0x38
   \       0xF4   0xF1D0 0x030F      RSBS     R3,R0,#+15
   \       0xF8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0xFA   0x1E5B             SUBS     R3,R3,#+1
   \       0xFC   0xF013 0x0307      ANDS     R3,R3,#0x7
   \      0x100   0x431A             ORRS     R2,R3,R2
   \      0x102   0x4311             ORRS     R1,R2,R1
   \      0x104   0xF88D 0x1004      STRB     R1,[SP, #+4]
   1210            
   1211            for (loopcounter = 0; loopcounter < NonceSize; loopcounter++)
   \      0x108   0x2100             MOVS     R1,#+0
   \      0x10A   0x9A1F             LDR      R2,[SP, #+124]
   \      0x10C   0xE004             B.N      ??CRYP_AES_CCM_9
   1212            {
   1213              blockb0[loopcounter+1] = Nonce[loopcounter];
   \                     ??CRYP_AES_CCM_10: (+1)
   \      0x10E   0x5C53             LDRB     R3,[R2, R1]
   \      0x110   0xAD01             ADD      R5,SP,#+4
   \      0x112   0x440D             ADD      R5,R5,R1
   \      0x114   0x706B             STRB     R3,[R5, #+1]
   1214            }
   \      0x116   0x1C49             ADDS     R1,R1,#+1
   \                     ??CRYP_AES_CCM_9: (+1)
   \      0x118   0x4281             CMP      R1,R0
   \      0x11A   0xD3F8             BCC.N    ??CRYP_AES_CCM_10
   1215            for ( ; loopcounter < 13; loopcounter++)
   \                     ??CRYP_AES_CCM_11: (+1)
   \      0x11C   0x290D             CMP      R1,#+13
   \      0x11E   0xD205             BCS.N    ??CRYP_AES_CCM_12
   1216            {
   1217              blockb0[loopcounter+1] = 0;
   \      0x120   0x2200             MOVS     R2,#+0
   \      0x122   0xAB01             ADD      R3,SP,#+4
   \      0x124   0x440B             ADD      R3,R3,R1
   \      0x126   0x705A             STRB     R2,[R3, #+1]
   1218            }
   \      0x128   0x1C49             ADDS     R1,R1,#+1
   \      0x12A   0xE7F7             B.N      ??CRYP_AES_CCM_11
   \                     ??CRYP_AES_CCM_12: (+1)
   \      0x12C   0x9D2C             LDR      R5,[SP, #+176]
   1219            
   1220            blockb0[14] = ((ILength >> 8) & 0xFF);
   \      0x12E   0x0029             MOVS     R1,R5
   \      0x130   0x0A09             LSRS     R1,R1,#+8
   \      0x132   0xF88D 0x1012      STRB     R1,[SP, #+18]
   1221            blockb0[15] = (ILength & 0xFF);
   \      0x136   0xA901             ADD      R1,SP,#+4
   \      0x138   0x73CD             STRB     R5,[R1, #+15]
   1222            
   1223            /************************* Formatting the initial counter *******************/
   1224            /* Byte 0:
   1225               Bits 7 and 6 are reserved and shall be set to 0
   1226               Bits 3, 4, and 5 shall also be set to 0, to ensure that all the counter blocks
   1227               are distinct from B0
   1228               Bits 0, 1, and 2 contain the same encoding of q as in B0
   1229            */
   1230            ctr[0] = blockb0[0] & 0x07;
   \      0x13A   0xF89D 0x2004      LDRB     R2,[SP, #+4]
   \      0x13E   0xF012 0x0207      ANDS     R2,R2,#0x7
   \      0x142   0xF88D 0x2044      STRB     R2,[SP, #+68]
   1231            /* byte 1 to NonceSize is the IV (Nonce) */
   1232            for(loopcounter = 1; loopcounter < NonceSize + 1; loopcounter++)
   \      0x146   0x2201             MOVS     R2,#+1
   \      0x148   0xE005             B.N      ??CRYP_AES_CCM_13
   1233            {
   1234              ctr[loopcounter] = blockb0[loopcounter];
   \                     ??CRYP_AES_CCM_14: (+1)
   \      0x14A   0x5C8B             LDRB     R3,[R1, R2]
   \      0x14C   0xF10D 0x0C44      ADD      R12,SP,#+68
   \      0x150   0xF80C 0x3002      STRB     R3,[R12, R2]
   1235            }
   \      0x154   0x1C52             ADDS     R2,R2,#+1
   \                     ??CRYP_AES_CCM_13: (+1)
   \      0x156   0x1C43             ADDS     R3,R0,#+1
   \      0x158   0x429A             CMP      R2,R3
   \      0x15A   0xD3F6             BCC.N    ??CRYP_AES_CCM_14
   1236            /* Set the LSB to 1 */
   1237            ctr[15] |= 0x01;
   \      0x15C   0xA811             ADD      R0,SP,#+68
   \      0x15E   0x7BC1             LDRB     R1,[R0, #+15]
   \      0x160   0xF051 0x0101      ORRS     R1,R1,#0x1
   \      0x164   0x73C1             STRB     R1,[R0, #+15]
   1238            
   1239            /* Crypto structures initialisation*/
   1240            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \      0x166   0xA809             ADD      R0,SP,#+36
   \      0x168   0x....'....        BL       CRYP_KeyStructInit
   1241            
   1242            switch(Keysize)
   \      0x16C   0xF8BD 0x00A8      LDRH     R0,[SP, #+168]
   \      0x170   0x2880             CMP      R0,#+128
   \      0x172   0xD005             BEQ.N    ??CRYP_AES_CCM_15
   \      0x174   0x28C0             CMP      R0,#+192
   \      0x176   0xD01C             BEQ.N    ??CRYP_AES_CCM_16
   \      0x178   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x17C   0xD03F             BEQ.N    ??CRYP_AES_CCM_17
   \      0x17E   0xE070             B.N      ??CRYP_AES_CCM_18
   1243            {
   1244              case 128:
   1245              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_CCM_15: (+1)
   \      0x180   0x2000             MOVS     R0,#+0
   \      0x182   0x9008             STR      R0,[SP, #+32]
   1246              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \      0x184   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x188   0xBA00             REV      R0,R0
   \      0x18A   0x900D             STR      R0,[SP, #+52]
   1247              keyaddr+=4;
   \      0x18C   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1248              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \      0x190   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x194   0xBA00             REV      R0,R0
   \      0x196   0x900E             STR      R0,[SP, #+56]
   1249              keyaddr+=4;
   \      0x198   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1250              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \      0x19C   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x1A0   0xBA00             REV      R0,R0
   \      0x1A2   0x900F             STR      R0,[SP, #+60]
   1251              keyaddr+=4;
   \      0x1A4   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1252              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \      0x1A8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x1AC   0xBA00             REV      R0,R0
   \      0x1AE   0x9010             STR      R0,[SP, #+64]
   1253              break;
   \      0x1B0   0xE057             B.N      ??CRYP_AES_CCM_19
   1254              case 192:
   1255              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_CCM_16: (+1)
   \      0x1B2   0xF44F 0x7080      MOV      R0,#+256
   \      0x1B6   0x9008             STR      R0,[SP, #+32]
   1256              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \      0x1B8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x1BC   0xBA00             REV      R0,R0
   \      0x1BE   0x900B             STR      R0,[SP, #+44]
   1257              keyaddr+=4;
   \      0x1C0   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1258              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \      0x1C4   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x1C8   0xBA00             REV      R0,R0
   \      0x1CA   0x900C             STR      R0,[SP, #+48]
   1259              keyaddr+=4;
   \      0x1CC   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1260              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \      0x1D0   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x1D4   0xBA00             REV      R0,R0
   \      0x1D6   0x900D             STR      R0,[SP, #+52]
   1261              keyaddr+=4;
   \      0x1D8   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1262              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \      0x1DC   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x1E0   0xBA00             REV      R0,R0
   \      0x1E2   0x900E             STR      R0,[SP, #+56]
   1263              keyaddr+=4;
   \      0x1E4   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1264              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \      0x1E8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x1EC   0xBA00             REV      R0,R0
   \      0x1EE   0x900F             STR      R0,[SP, #+60]
   1265              keyaddr+=4;
   \      0x1F0   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1266              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \      0x1F4   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x1F8   0xBA00             REV      R0,R0
   \      0x1FA   0x9010             STR      R0,[SP, #+64]
   1267              break;
   \      0x1FC   0xE031             B.N      ??CRYP_AES_CCM_19
   1268              case 256:
   1269              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_CCM_17: (+1)
   \      0x1FE   0xF44F 0x7000      MOV      R0,#+512
   \      0x202   0x9008             STR      R0,[SP, #+32]
   1270              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \      0x204   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x208   0xBA00             REV      R0,R0
   \      0x20A   0x9009             STR      R0,[SP, #+36]
   1271              keyaddr+=4;
   \      0x20C   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1272              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \      0x210   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x214   0xBA00             REV      R0,R0
   \      0x216   0x900A             STR      R0,[SP, #+40]
   1273              keyaddr+=4;
   \      0x218   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1274              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \      0x21C   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x220   0xBA00             REV      R0,R0
   \      0x222   0x900B             STR      R0,[SP, #+44]
   1275              keyaddr+=4;
   \      0x224   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1276              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \      0x228   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x22C   0xBA00             REV      R0,R0
   \      0x22E   0x900C             STR      R0,[SP, #+48]
   1277              keyaddr+=4;
   \      0x230   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1278              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \      0x234   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x238   0xBA00             REV      R0,R0
   \      0x23A   0x900D             STR      R0,[SP, #+52]
   1279              keyaddr+=4;
   \      0x23C   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1280              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \      0x240   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x244   0xBA00             REV      R0,R0
   \      0x246   0x900E             STR      R0,[SP, #+56]
   1281              keyaddr+=4;
   \      0x248   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1282              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \      0x24C   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x250   0xBA00             REV      R0,R0
   \      0x252   0x900F             STR      R0,[SP, #+60]
   1283              keyaddr+=4;
   \      0x254   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1284              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \      0x258   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x25C   0xBA00             REV      R0,R0
   \      0x25E   0x9010             STR      R0,[SP, #+64]
   1285              break;
   \      0x260   0xE7FF             B.N      ??CRYP_AES_CCM_19
   1286              default:
   1287              break;
   \                     ??CRYP_AES_CCM_18: (+1)
   \                     ??CRYP_AES_CCM_19: (+1)
   \      0x262   0xF89D 0x0078      LDRB     R0,[SP, #+120]
   1288            }
   1289            
   1290            /* CRYP Initialization Vectors */
   1291            AES_CRYP_IVInitStructure.CRYP_IV0Left = (__REV(*(uint32_t*)(ctraddr)));
   \      0x266   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0x26A   0xBA09             REV      R1,R1
   \      0x26C   0x911A             STR      R1,[SP, #+104]
   1292            ctraddr+=4;
   \      0x26E   0xF11B 0x0B04      ADDS     R11,R11,#+4
   1293            AES_CRYP_IVInitStructure.CRYP_IV0Right= (__REV(*(uint32_t*)(ctraddr)));
   \      0x272   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0x276   0xBA09             REV      R1,R1
   \      0x278   0x911B             STR      R1,[SP, #+108]
   1294            ctraddr+=4;
   \      0x27A   0xF11B 0x0B04      ADDS     R11,R11,#+4
   1295            AES_CRYP_IVInitStructure.CRYP_IV1Left = (__REV(*(uint32_t*)(ctraddr)));
   \      0x27E   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0x282   0xBA09             REV      R1,R1
   \      0x284   0x911C             STR      R1,[SP, #+112]
   1296            ctraddr+=4;
   \      0x286   0xF11B 0x0B04      ADDS     R11,R11,#+4
   1297            AES_CRYP_IVInitStructure.CRYP_IV1Right= (__REV(*(uint32_t*)(ctraddr)));
   \      0x28A   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0x28E   0xBA09             REV      R1,R1
   \      0x290   0x911D             STR      R1,[SP, #+116]
   1298            
   1299            /*------------------ AES Encryption ------------------*/
   1300            if(Mode == MODE_ENCRYPT) /* AES encryption */
   \      0x292   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x294   0x2801             CMP      R0,#+1
   \      0x296   0xF040 0x8106      BNE.W    ??CRYP_AES_CCM_20
   1301            {
   1302              /* Flush IN/OUT FIFOs */
   1303              CRYP_FIFOFlush();
   \      0x29A   0x....'....        BL       CRYP_FIFOFlush
   1304              
   1305              /* Key Initialisation */
   1306              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \      0x29E   0xA809             ADD      R0,SP,#+36
   \      0x2A0   0x....'....        BL       CRYP_KeyInit
   1307              
   1308              /* CRYP Initialization Vectors */
   1309              CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \      0x2A4   0xA81A             ADD      R0,SP,#+104
   \      0x2A6   0x....'....        BL       CRYP_IVInit
   1310              
   1311              /* Crypto Init for Key preparation for decryption process */
   1312              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
   \      0x2AA   0x2000             MOVS     R0,#+0
   \      0x2AC   0x9005             STR      R0,[SP, #+20]
   1313              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CCM;
   \      0x2AE   0xF05F 0x1008      MOVS     R0,#+524296
   \      0x2B2   0x9006             STR      R0,[SP, #+24]
   1314              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \      0x2B4   0x2080             MOVS     R0,#+128
   \      0x2B6   0x9007             STR      R0,[SP, #+28]
   1315              CRYP_Init(&AES_CRYP_InitStructure);
   \      0x2B8   0xA805             ADD      R0,SP,#+20
   \      0x2BA   0x....'....        BL       CRYP_Init
   1316              
   1317              /***************************** Init phase *********************************/
   1318              /* Select init phase */
   1319              CRYP_PhaseConfig(CRYP_Phase_Init);
   \      0x2BE   0x2000             MOVS     R0,#+0
   \      0x2C0   0x....'....        BL       CRYP_PhaseConfig
   1320              
   1321              b0addr = (uint32_t)blockb0;
   \      0x2C4   0xF10D 0x0A04      ADD      R10,SP,#+4
   1322              /* Write the blockb0 block in the IN FIFO */
   1323              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \      0x2C8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x2CC   0x....'....        BL       CRYP_DataIn
   1324              b0addr+=4;
   \      0x2D0   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1325              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \      0x2D4   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x2D8   0x....'....        BL       CRYP_DataIn
   1326              b0addr+=4;
   \      0x2DC   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1327              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \      0x2E0   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x2E4   0x....'....        BL       CRYP_DataIn
   1328              b0addr+=4;
   \      0x2E8   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1329              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \      0x2EC   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x2F0   0x....'....        BL       CRYP_DataIn
   1330              
   1331              /* Enable Crypto processor */
   1332              CRYP_Cmd(ENABLE);
   \      0x2F4   0x2001             MOVS     R0,#+1
   \      0x2F6   0x....'....        BL       CRYP_Cmd
   1333              
   1334              /* Wait for CRYPEN bit to be 0 */
   1335              while(CRYP_GetCmdStatus() == ENABLE)
   \                     ??CRYP_AES_CCM_21: (+1)
   \      0x2FA   0x....'....        BL       CRYP_GetCmdStatus
   \      0x2FE   0x2801             CMP      R0,#+1
   \      0x300   0xD0FB             BEQ.N    ??CRYP_AES_CCM_21
   1336              {
   1337              }
   1338              /***************************** header phase *******************************/
   1339              if(headersize != 0)
   \      0x302   0x2C00             CMP      R4,#+0
   \      0x304   0xD041             BEQ.N    ??CRYP_AES_CCM_22
   1340              {
   1341                /* Select header phase */
   1342                CRYP_PhaseConfig(CRYP_Phase_Header);
   \      0x306   0xF45F 0x3080      MOVS     R0,#+65536
   \      0x30A   0x....'....        BL       CRYP_PhaseConfig
   1343                
   1344                /* Enable Crypto processor */
   1345                CRYP_Cmd(ENABLE);
   \      0x30E   0x2001             MOVS     R0,#+1
   \      0x310   0x....'....        BL       CRYP_Cmd
   1346                
   1347                if(CRYP_GetCmdStatus() == DISABLE)
   \      0x314   0x....'....        BL       CRYP_GetCmdStatus
   \      0x318   0x2800             CMP      R0,#+0
   \      0x31A   0xD101             BNE.N    ??CRYP_AES_CCM_23
   1348                {
   1349                   /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1350                      the CRYP peripheral (please check the device sales type. */
   1351                   return(ERROR);
   \      0x31C   0x2000             MOVS     R0,#+0
   \      0x31E   0xE1D6             B.N      ??CRYP_AES_CCM_24
   1352                }
   1353                
   1354                for(loopcounter = 0; (loopcounter < headersize); loopcounter+=16)
   \                     ??CRYP_AES_CCM_23: (+1)
   \      0x320   0xF05F 0x0A00      MOVS     R10,#+0
   \      0x324   0xE01E             B.N      ??CRYP_AES_CCM_25
   1355                {
   1356                  /* Wait until the IFEM flag is reset */
   1357                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   \                     ??CRYP_AES_CCM_26: (+1)
   \      0x326   0x2001             MOVS     R0,#+1
   \      0x328   0x....'....        BL       CRYP_GetFlagStatus
   \      0x32C   0x2800             CMP      R0,#+0
   \      0x32E   0xD0FA             BEQ.N    ??CRYP_AES_CCM_26
   1358                  {
   1359                  }
   1360                  
   1361                  /* Write the Input block in the IN FIFO */
   1362                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x330   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x334   0x....'....        BL       CRYP_DataIn
   1363                  headeraddr+=4;
   \      0x338   0xF119 0x0904      ADDS     R9,R9,#+4
   1364                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x33C   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x340   0x....'....        BL       CRYP_DataIn
   1365                  headeraddr+=4;
   \      0x344   0xF119 0x0904      ADDS     R9,R9,#+4
   1366                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x348   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x34C   0x....'....        BL       CRYP_DataIn
   1367                  headeraddr+=4;
   \      0x350   0xF119 0x0904      ADDS     R9,R9,#+4
   1368                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x354   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x358   0x....'....        BL       CRYP_DataIn
   1369                  headeraddr+=4;
   \      0x35C   0xF119 0x0904      ADDS     R9,R9,#+4
   1370                }
   \      0x360   0xF11A 0x0A10      ADDS     R10,R10,#+16
   \                     ??CRYP_AES_CCM_25: (+1)
   \      0x364   0x45A2             CMP      R10,R4
   \      0x366   0xD3DE             BCC.N    ??CRYP_AES_CCM_26
   1371                
   1372                /* Wait until the complete message has been processed */
   1373                counter = 0;
   \      0x368   0x2000             MOVS     R0,#+0
   \      0x36A   0x9000             STR      R0,[SP, #+0]
   1374                do
   1375                {
   1376                  busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_CCM_27: (+1)
   \      0x36C   0x2010             MOVS     R0,#+16
   \      0x36E   0x....'....        BL       CRYP_GetFlagStatus
   1377                  counter++;
   \      0x372   0x9900             LDR      R1,[SP, #+0]
   \      0x374   0x1C49             ADDS     R1,R1,#+1
   \      0x376   0x9100             STR      R1,[SP, #+0]
   1378                }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \      0x378   0x9900             LDR      R1,[SP, #+0]
   \      0x37A   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x37E   0xD001             BEQ.N    ??CRYP_AES_CCM_28
   \      0x380   0x2800             CMP      R0,#+0
   \      0x382   0xD1F3             BNE.N    ??CRYP_AES_CCM_27
   1379          
   1380                if (busystatus != RESET)
   \                     ??CRYP_AES_CCM_28: (+1)
   \      0x384   0x2800             CMP      R0,#+0
   \      0x386   0xD000             BEQ.N    ??CRYP_AES_CCM_22
   1381                {
   1382                  status = ERROR;
   \      0x388   0x2600             MOVS     R6,#+0
   1383                }
   1384              }
   1385              
   1386              /**************************** payload phase *******************************/
   1387              if(ILength != 0)
   \                     ??CRYP_AES_CCM_22: (+1)
   \      0x38A   0x2D00             CMP      R5,#+0
   \      0x38C   0xD059             BEQ.N    ??CRYP_AES_CCM_29
   1388              {
   1389                /* Select payload phase */
   1390                CRYP_PhaseConfig(CRYP_Phase_Payload);
   \      0x38E   0xF45F 0x3000      MOVS     R0,#+131072
   \      0x392   0x....'....        BL       CRYP_PhaseConfig
   1391                
   1392                /* Enable Crypto processor */
   1393                CRYP_Cmd(ENABLE);
   \      0x396   0x2001             MOVS     R0,#+1
   \      0x398   0x....'....        BL       CRYP_Cmd
   1394                
   1395                if(CRYP_GetCmdStatus() == DISABLE)
   \      0x39C   0x....'....        BL       CRYP_GetCmdStatus
   \      0x3A0   0x2800             CMP      R0,#+0
   \      0x3A2   0xD101             BNE.N    ??CRYP_AES_CCM_30
   1396                {
   1397                  /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1398                     the CRYP peripheral (please check the device sales type. */
   1399                  return(ERROR);
   \      0x3A4   0x2000             MOVS     R0,#+0
   \      0x3A6   0xE192             B.N      ??CRYP_AES_CCM_24
   1400                }
   1401                
   1402                for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
   \                     ??CRYP_AES_CCM_30: (+1)
   \      0x3A8   0x2400             MOVS     R4,#+0
   \      0x3AA   0xE044             B.N      ??CRYP_AES_CCM_31
   1403                {
   1404                  /* Wait until the IFEM flag is reset */
   1405                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   1406                  {
   1407                  }
   1408                  
   1409                  /* Write the Input block in the IN FIFO */
   1410                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1411                  inputaddr+=4;
   1412                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1413                  inputaddr+=4;
   1414                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1415                  inputaddr+=4;
   1416                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1417                  inputaddr+=4;
   1418                  
   1419                  /* Wait until the complete message has been processed */
   1420                  counter = 0;
   1421                  do
   1422                  {
   1423                    busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   1424                    counter++;
   1425                  }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   1426          
   1427                  if (busystatus != RESET)
   1428                  {
   1429                    status = ERROR;
   1430                  }
   1431                  else
   1432                  {
   1433                    /* Wait until the OFNE flag is reset */
   1434                    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_CCM_32: (+1)
   \      0x3AC   0x2004             MOVS     R0,#+4
   \      0x3AE   0x....'....        BL       CRYP_GetFlagStatus
   \      0x3B2   0x2800             CMP      R0,#+0
   \      0x3B4   0xD0FA             BEQ.N    ??CRYP_AES_CCM_32
   1435                    {
   1436                    }
   1437                    
   1438                    /* Read the Output block from the Output FIFO */
   1439                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x3B6   0x....'....        BL       CRYP_DataOut
   \      0x3BA   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1440                    outputaddr+=4;
   \      0x3BE   0xF118 0x0804      ADDS     R8,R8,#+4
   1441                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x3C2   0x....'....        BL       CRYP_DataOut
   \      0x3C6   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1442                    outputaddr+=4;
   \      0x3CA   0xF118 0x0804      ADDS     R8,R8,#+4
   1443                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x3CE   0x....'....        BL       CRYP_DataOut
   \      0x3D2   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1444                    outputaddr+=4;
   \      0x3D6   0xF118 0x0804      ADDS     R8,R8,#+4
   1445                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x3DA   0x....'....        BL       CRYP_DataOut
   \      0x3DE   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1446                    outputaddr+=4;
   \      0x3E2   0xF118 0x0804      ADDS     R8,R8,#+4
   \      0x3E6   0xE025             B.N      ??CRYP_AES_CCM_33
   1447                  }
   \                     ??CRYP_AES_CCM_34: (+1)
   \      0x3E8   0x2001             MOVS     R0,#+1
   \      0x3EA   0x....'....        BL       CRYP_GetFlagStatus
   \      0x3EE   0x2800             CMP      R0,#+0
   \      0x3F0   0xD0FA             BEQ.N    ??CRYP_AES_CCM_34
   \      0x3F2   0x6838             LDR      R0,[R7, #+0]
   \      0x3F4   0x....'....        BL       CRYP_DataIn
   \      0x3F8   0x1D3F             ADDS     R7,R7,#+4
   \      0x3FA   0x6838             LDR      R0,[R7, #+0]
   \      0x3FC   0x....'....        BL       CRYP_DataIn
   \      0x400   0x1D3F             ADDS     R7,R7,#+4
   \      0x402   0x6838             LDR      R0,[R7, #+0]
   \      0x404   0x....'....        BL       CRYP_DataIn
   \      0x408   0x1D3F             ADDS     R7,R7,#+4
   \      0x40A   0x6838             LDR      R0,[R7, #+0]
   \      0x40C   0x....'....        BL       CRYP_DataIn
   \      0x410   0x1D3F             ADDS     R7,R7,#+4
   \      0x412   0x2000             MOVS     R0,#+0
   \      0x414   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_CCM_35: (+1)
   \      0x416   0x2010             MOVS     R0,#+16
   \      0x418   0x....'....        BL       CRYP_GetFlagStatus
   \      0x41C   0x9900             LDR      R1,[SP, #+0]
   \      0x41E   0x1C49             ADDS     R1,R1,#+1
   \      0x420   0x9100             STR      R1,[SP, #+0]
   \      0x422   0x9900             LDR      R1,[SP, #+0]
   \      0x424   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x428   0xD001             BEQ.N    ??CRYP_AES_CCM_36
   \      0x42A   0x2800             CMP      R0,#+0
   \      0x42C   0xD1F3             BNE.N    ??CRYP_AES_CCM_35
   \                     ??CRYP_AES_CCM_36: (+1)
   \      0x42E   0x2800             CMP      R0,#+0
   \      0x430   0xD0BC             BEQ.N    ??CRYP_AES_CCM_32
   \      0x432   0x2600             MOVS     R6,#+0
   1448                }
   \                     ??CRYP_AES_CCM_33: (+1)
   \      0x434   0x3410             ADDS     R4,R4,#+16
   \                     ??CRYP_AES_CCM_31: (+1)
   \      0x436   0x42AC             CMP      R4,R5
   \      0x438   0xD203             BCS.N    ??CRYP_AES_CCM_29
   \      0x43A   0x0030             MOVS     R0,R6
   \      0x43C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x43E   0x2800             CMP      R0,#+0
   \      0x440   0xD1D2             BNE.N    ??CRYP_AES_CCM_34
   1449              }
   1450              
   1451              /***************************** final phase ********************************/
   1452              /* Select final phase */
   1453              CRYP_PhaseConfig(CRYP_Phase_Final);
   \                     ??CRYP_AES_CCM_29: (+1)
   \      0x442   0xF45F 0x3040      MOVS     R0,#+196608
   \      0x446   0x....'....        BL       CRYP_PhaseConfig
   1454              
   1455              /* Enable Crypto processor */
   1456              CRYP_Cmd(ENABLE);
   \      0x44A   0x2001             MOVS     R0,#+1
   \      0x44C   0x....'....        BL       CRYP_Cmd
   1457              
   1458              if(CRYP_GetCmdStatus() == DISABLE)
   \      0x450   0x....'....        BL       CRYP_GetCmdStatus
   \      0x454   0x2800             CMP      R0,#+0
   \      0x456   0xD101             BNE.N    ??CRYP_AES_CCM_37
   1459              {
   1460                /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1461                   the CRYP peripheral (please check the device sales type. */
   1462                return(ERROR);
   \      0x458   0x2000             MOVS     R0,#+0
   \      0x45A   0xE138             B.N      ??CRYP_AES_CCM_24
   1463              }
   1464              
   1465              ctraddr = (uint32_t)ctr;
   \                     ??CRYP_AES_CCM_37: (+1)
   \      0x45C   0xAC11             ADD      R4,SP,#+68
   1466              /* Write the counter block in the IN FIFO */
   1467              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \      0x45E   0x6820             LDR      R0,[R4, #+0]
   \      0x460   0x....'....        BL       CRYP_DataIn
   1468              ctraddr+=4;
   \      0x464   0x1D24             ADDS     R4,R4,#+4
   1469              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \      0x466   0x6820             LDR      R0,[R4, #+0]
   \      0x468   0x....'....        BL       CRYP_DataIn
   1470              ctraddr+=4;
   \      0x46C   0x1D24             ADDS     R4,R4,#+4
   1471              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \      0x46E   0x6820             LDR      R0,[R4, #+0]
   \      0x470   0x....'....        BL       CRYP_DataIn
   1472              ctraddr+=4;
   \      0x474   0x1D24             ADDS     R4,R4,#+4
   1473              /* Reset bit 0 (after 8-bit swap) is equivalent to reset bit 24 (before 8-bit swap) */
   1474              CRYP_DataIn(*(uint32_t*)(ctraddr) & 0xfeffffff);
   \      0x476   0x6820             LDR      R0,[R4, #+0]
   \      0x478   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \      0x47C   0x....'....        BL       CRYP_DataIn
   1475              
   1476              /* Wait until the OFNE flag is reset */
   1477              while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_CCM_38: (+1)
   \      0x480   0x2004             MOVS     R0,#+4
   \      0x482   0x....'....        BL       CRYP_GetFlagStatus
   \      0x486   0x2800             CMP      R0,#+0
   \      0x488   0xD0FA             BEQ.N    ??CRYP_AES_CCM_38
   1478              {
   1479              }
   1480              
   1481              /* Read the Auth TAG in the IN FIFO */
   1482              temptag[0] = CRYP_DataOut();
   \      0x48A   0x....'....        BL       CRYP_DataOut
   \      0x48E   0x9016             STR      R0,[SP, #+88]
   1483              temptag[1] = CRYP_DataOut();
   \      0x490   0xAC16             ADD      R4,SP,#+88
   \      0x492   0x....'....        BL       CRYP_DataOut
   \      0x496   0x6060             STR      R0,[R4, #+4]
   1484              temptag[2] = CRYP_DataOut();
   \      0x498   0x....'....        BL       CRYP_DataOut
   \      0x49C   0x60A0             STR      R0,[R4, #+8]
   1485              temptag[3] = CRYP_DataOut();
   \      0x49E   0x....'....        BL       CRYP_DataOut
   \      0x4A2   0x60E0             STR      R0,[R4, #+12]
   \      0x4A4   0xE104             B.N      ??CRYP_AES_CCM_39
   1486            }
   1487            /*------------------ AES Decryption ------------------*/
   1488            else /* AES decryption */
   1489            {
   1490              /* Flush IN/OUT FIFOs */
   1491              CRYP_FIFOFlush();
   \                     ??CRYP_AES_CCM_20: (+1)
   \      0x4A6   0x....'....        BL       CRYP_FIFOFlush
   1492              
   1493              /* Key Initialisation */
   1494              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \      0x4AA   0xA809             ADD      R0,SP,#+36
   \      0x4AC   0x....'....        BL       CRYP_KeyInit
   1495              
   1496              /* CRYP Initialization Vectors */
   1497              CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \      0x4B0   0xA81A             ADD      R0,SP,#+104
   \      0x4B2   0x....'....        BL       CRYP_IVInit
   1498              
   1499              /* Crypto Init for Key preparation for decryption process */
   1500              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \      0x4B6   0x2004             MOVS     R0,#+4
   \      0x4B8   0x9005             STR      R0,[SP, #+20]
   1501              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CCM;
   \      0x4BA   0xF05F 0x1008      MOVS     R0,#+524296
   \      0x4BE   0x9006             STR      R0,[SP, #+24]
   1502              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \      0x4C0   0x2080             MOVS     R0,#+128
   \      0x4C2   0x9007             STR      R0,[SP, #+28]
   1503              CRYP_Init(&AES_CRYP_InitStructure);
   \      0x4C4   0xA805             ADD      R0,SP,#+20
   \      0x4C6   0x....'....        BL       CRYP_Init
   1504              
   1505              /***************************** Init phase *********************************/
   1506              /* Select init phase */
   1507              CRYP_PhaseConfig(CRYP_Phase_Init);
   \      0x4CA   0x2000             MOVS     R0,#+0
   \      0x4CC   0x....'....        BL       CRYP_PhaseConfig
   1508              
   1509              b0addr = (uint32_t)blockb0;
   \      0x4D0   0xF10D 0x0A04      ADD      R10,SP,#+4
   1510              /* Write the blockb0 block in the IN FIFO */
   1511              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \      0x4D4   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x4D8   0x....'....        BL       CRYP_DataIn
   1512              b0addr+=4;
   \      0x4DC   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1513              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \      0x4E0   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x4E4   0x....'....        BL       CRYP_DataIn
   1514              b0addr+=4;
   \      0x4E8   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1515              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \      0x4EC   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x4F0   0x....'....        BL       CRYP_DataIn
   1516              b0addr+=4;
   \      0x4F4   0xF11A 0x0A04      ADDS     R10,R10,#+4
   1517              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \      0x4F8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x4FC   0x....'....        BL       CRYP_DataIn
   1518              
   1519              /* Enable Crypto processor */
   1520              CRYP_Cmd(ENABLE);
   \      0x500   0x2001             MOVS     R0,#+1
   \      0x502   0x....'....        BL       CRYP_Cmd
   1521              
   1522              /* Wait for CRYPEN bit to be 0 */
   1523              while(CRYP_GetCmdStatus() == ENABLE)
   \                     ??CRYP_AES_CCM_40: (+1)
   \      0x506   0x....'....        BL       CRYP_GetCmdStatus
   \      0x50A   0x2801             CMP      R0,#+1
   \      0x50C   0xD0FB             BEQ.N    ??CRYP_AES_CCM_40
   1524              {
   1525              }
   1526              
   1527              /***************************** header phase *******************************/
   1528              if(headersize != 0)
   \      0x50E   0x2C00             CMP      R4,#+0
   \      0x510   0xD041             BEQ.N    ??CRYP_AES_CCM_41
   1529              {
   1530                /* Select header phase */
   1531                CRYP_PhaseConfig(CRYP_Phase_Header);
   \      0x512   0xF45F 0x3080      MOVS     R0,#+65536
   \      0x516   0x....'....        BL       CRYP_PhaseConfig
   1532                
   1533                /* Enable Crypto processor */
   1534                CRYP_Cmd(ENABLE);
   \      0x51A   0x2001             MOVS     R0,#+1
   \      0x51C   0x....'....        BL       CRYP_Cmd
   1535                
   1536                if(CRYP_GetCmdStatus() == DISABLE)
   \      0x520   0x....'....        BL       CRYP_GetCmdStatus
   \      0x524   0x2800             CMP      R0,#+0
   \      0x526   0xD101             BNE.N    ??CRYP_AES_CCM_42
   1537                {
   1538                  /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1539                     the CRYP peripheral (please check the device sales type. */
   1540                  return(ERROR);
   \      0x528   0x2000             MOVS     R0,#+0
   \      0x52A   0xE0D0             B.N      ??CRYP_AES_CCM_24
   1541                }
   1542                
   1543                for(loopcounter = 0; (loopcounter < headersize); loopcounter+=16)
   \                     ??CRYP_AES_CCM_42: (+1)
   \      0x52C   0xF05F 0x0A00      MOVS     R10,#+0
   \      0x530   0xE01E             B.N      ??CRYP_AES_CCM_43
   1544                {
   1545                  /* Wait until the IFEM flag is reset */
   1546                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   \                     ??CRYP_AES_CCM_44: (+1)
   \      0x532   0x2001             MOVS     R0,#+1
   \      0x534   0x....'....        BL       CRYP_GetFlagStatus
   \      0x538   0x2800             CMP      R0,#+0
   \      0x53A   0xD0FA             BEQ.N    ??CRYP_AES_CCM_44
   1547                  {
   1548                  }
   1549                  
   1550                  /* Write the Input block in the IN FIFO */
   1551                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x53C   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x540   0x....'....        BL       CRYP_DataIn
   1552                  headeraddr+=4;
   \      0x544   0xF119 0x0904      ADDS     R9,R9,#+4
   1553                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x548   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x54C   0x....'....        BL       CRYP_DataIn
   1554                  headeraddr+=4;
   \      0x550   0xF119 0x0904      ADDS     R9,R9,#+4
   1555                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x554   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x558   0x....'....        BL       CRYP_DataIn
   1556                  headeraddr+=4;
   \      0x55C   0xF119 0x0904      ADDS     R9,R9,#+4
   1557                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \      0x560   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x564   0x....'....        BL       CRYP_DataIn
   1558                  headeraddr+=4;
   \      0x568   0xF119 0x0904      ADDS     R9,R9,#+4
   1559                }
   \      0x56C   0xF11A 0x0A10      ADDS     R10,R10,#+16
   \                     ??CRYP_AES_CCM_43: (+1)
   \      0x570   0x45A2             CMP      R10,R4
   \      0x572   0xD3DE             BCC.N    ??CRYP_AES_CCM_44
   1560                
   1561                /* Wait until the complete message has been processed */
   1562                counter = 0;
   \      0x574   0x2000             MOVS     R0,#+0
   \      0x576   0x9000             STR      R0,[SP, #+0]
   1563                do
   1564                {
   1565                  busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_CCM_45: (+1)
   \      0x578   0x2010             MOVS     R0,#+16
   \      0x57A   0x....'....        BL       CRYP_GetFlagStatus
   1566                  counter++;
   \      0x57E   0x9900             LDR      R1,[SP, #+0]
   \      0x580   0x1C49             ADDS     R1,R1,#+1
   \      0x582   0x9100             STR      R1,[SP, #+0]
   1567                }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \      0x584   0x9900             LDR      R1,[SP, #+0]
   \      0x586   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x58A   0xD001             BEQ.N    ??CRYP_AES_CCM_46
   \      0x58C   0x2800             CMP      R0,#+0
   \      0x58E   0xD1F3             BNE.N    ??CRYP_AES_CCM_45
   1568          
   1569                if (busystatus != RESET)
   \                     ??CRYP_AES_CCM_46: (+1)
   \      0x590   0x2800             CMP      R0,#+0
   \      0x592   0xD000             BEQ.N    ??CRYP_AES_CCM_41
   1570                {
   1571                  status = ERROR;
   \      0x594   0x2600             MOVS     R6,#+0
   1572                }
   1573              }
   1574              
   1575              /**************************** payload phase *******************************/
   1576              if(ILength != 0)
   \                     ??CRYP_AES_CCM_41: (+1)
   \      0x596   0x2D00             CMP      R5,#+0
   \      0x598   0xD059             BEQ.N    ??CRYP_AES_CCM_47
   1577              {
   1578                /* Select payload phase */
   1579                CRYP_PhaseConfig(CRYP_Phase_Payload);
   \      0x59A   0xF45F 0x3000      MOVS     R0,#+131072
   \      0x59E   0x....'....        BL       CRYP_PhaseConfig
   1580          
   1581                /* Enable Crypto processor */
   1582                CRYP_Cmd(ENABLE);
   \      0x5A2   0x2001             MOVS     R0,#+1
   \      0x5A4   0x....'....        BL       CRYP_Cmd
   1583                
   1584                if(CRYP_GetCmdStatus() == DISABLE)
   \      0x5A8   0x....'....        BL       CRYP_GetCmdStatus
   \      0x5AC   0x2800             CMP      R0,#+0
   \      0x5AE   0xD101             BNE.N    ??CRYP_AES_CCM_48
   1585                {
   1586                  /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1587                     the CRYP peripheral (please check the device sales type. */
   1588                  return(ERROR);
   \      0x5B0   0x2000             MOVS     R0,#+0
   \      0x5B2   0xE08C             B.N      ??CRYP_AES_CCM_24
   1589                }
   1590                
   1591                for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
   \                     ??CRYP_AES_CCM_48: (+1)
   \      0x5B4   0x2400             MOVS     R4,#+0
   \      0x5B6   0xE044             B.N      ??CRYP_AES_CCM_49
   1592                {
   1593                  /* Wait until the IFEM flag is reset */
   1594                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   1595                  {
   1596                  }
   1597                  
   1598                  /* Write the Input block in the IN FIFO */
   1599                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1600                  inputaddr+=4;
   1601                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1602                  inputaddr+=4;
   1603                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1604                  inputaddr+=4;
   1605                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1606                  inputaddr+=4;
   1607                  
   1608                  /* Wait until the complete message has been processed */
   1609                  counter = 0;
   1610                  do
   1611                  {
   1612                    busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   1613                    counter++;
   1614                  }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   1615          
   1616                  if (busystatus != RESET)
   1617                  {
   1618                    status = ERROR;
   1619                  }
   1620                  else
   1621                  {
   1622                    /* Wait until the OFNE flag is reset */
   1623                    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_CCM_50: (+1)
   \      0x5B8   0x2004             MOVS     R0,#+4
   \      0x5BA   0x....'....        BL       CRYP_GetFlagStatus
   \      0x5BE   0x2800             CMP      R0,#+0
   \      0x5C0   0xD0FA             BEQ.N    ??CRYP_AES_CCM_50
   1624                    {
   1625                    }
   1626                    
   1627                    /* Read the Output block from the Output FIFO */
   1628                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x5C2   0x....'....        BL       CRYP_DataOut
   \      0x5C6   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1629                    outputaddr+=4;
   \      0x5CA   0xF118 0x0804      ADDS     R8,R8,#+4
   1630                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x5CE   0x....'....        BL       CRYP_DataOut
   \      0x5D2   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1631                    outputaddr+=4;
   \      0x5D6   0xF118 0x0804      ADDS     R8,R8,#+4
   1632                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x5DA   0x....'....        BL       CRYP_DataOut
   \      0x5DE   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1633                    outputaddr+=4;
   \      0x5E2   0xF118 0x0804      ADDS     R8,R8,#+4
   1634                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \      0x5E6   0x....'....        BL       CRYP_DataOut
   \      0x5EA   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1635                    outputaddr+=4;
   \      0x5EE   0xF118 0x0804      ADDS     R8,R8,#+4
   \      0x5F2   0xE025             B.N      ??CRYP_AES_CCM_51
   1636                  }
   \                     ??CRYP_AES_CCM_52: (+1)
   \      0x5F4   0x2001             MOVS     R0,#+1
   \      0x5F6   0x....'....        BL       CRYP_GetFlagStatus
   \      0x5FA   0x2800             CMP      R0,#+0
   \      0x5FC   0xD0FA             BEQ.N    ??CRYP_AES_CCM_52
   \      0x5FE   0x6838             LDR      R0,[R7, #+0]
   \      0x600   0x....'....        BL       CRYP_DataIn
   \      0x604   0x1D3F             ADDS     R7,R7,#+4
   \      0x606   0x6838             LDR      R0,[R7, #+0]
   \      0x608   0x....'....        BL       CRYP_DataIn
   \      0x60C   0x1D3F             ADDS     R7,R7,#+4
   \      0x60E   0x6838             LDR      R0,[R7, #+0]
   \      0x610   0x....'....        BL       CRYP_DataIn
   \      0x614   0x1D3F             ADDS     R7,R7,#+4
   \      0x616   0x6838             LDR      R0,[R7, #+0]
   \      0x618   0x....'....        BL       CRYP_DataIn
   \      0x61C   0x1D3F             ADDS     R7,R7,#+4
   \      0x61E   0x2000             MOVS     R0,#+0
   \      0x620   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_CCM_53: (+1)
   \      0x622   0x2010             MOVS     R0,#+16
   \      0x624   0x....'....        BL       CRYP_GetFlagStatus
   \      0x628   0x9900             LDR      R1,[SP, #+0]
   \      0x62A   0x1C49             ADDS     R1,R1,#+1
   \      0x62C   0x9100             STR      R1,[SP, #+0]
   \      0x62E   0x9900             LDR      R1,[SP, #+0]
   \      0x630   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x634   0xD001             BEQ.N    ??CRYP_AES_CCM_54
   \      0x636   0x2800             CMP      R0,#+0
   \      0x638   0xD1F3             BNE.N    ??CRYP_AES_CCM_53
   \                     ??CRYP_AES_CCM_54: (+1)
   \      0x63A   0x2800             CMP      R0,#+0
   \      0x63C   0xD0BC             BEQ.N    ??CRYP_AES_CCM_50
   \      0x63E   0x2600             MOVS     R6,#+0
   1637                }
   \                     ??CRYP_AES_CCM_51: (+1)
   \      0x640   0x3410             ADDS     R4,R4,#+16
   \                     ??CRYP_AES_CCM_49: (+1)
   \      0x642   0x42AC             CMP      R4,R5
   \      0x644   0xD203             BCS.N    ??CRYP_AES_CCM_47
   \      0x646   0x0030             MOVS     R0,R6
   \      0x648   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x64A   0x2800             CMP      R0,#+0
   \      0x64C   0xD1D2             BNE.N    ??CRYP_AES_CCM_52
   1638              }
   1639              
   1640              /***************************** final phase ********************************/
   1641              /* Select final phase */
   1642              CRYP_PhaseConfig(CRYP_Phase_Final);
   \                     ??CRYP_AES_CCM_47: (+1)
   \      0x64E   0xF45F 0x3040      MOVS     R0,#+196608
   \      0x652   0x....'....        BL       CRYP_PhaseConfig
   1643              
   1644              /* Enable Crypto processor */
   1645              CRYP_Cmd(ENABLE);
   \      0x656   0x2001             MOVS     R0,#+1
   \      0x658   0x....'....        BL       CRYP_Cmd
   1646              
   1647              if(CRYP_GetCmdStatus() == DISABLE)
   \      0x65C   0x....'....        BL       CRYP_GetCmdStatus
   \      0x660   0x2800             CMP      R0,#+0
   \      0x662   0xD101             BNE.N    ??CRYP_AES_CCM_55
   1648              {
   1649                /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1650                   the CRYP peripheral (please check the device sales type. */
   1651                return(ERROR);
   \      0x664   0x2000             MOVS     R0,#+0
   \      0x666   0xE032             B.N      ??CRYP_AES_CCM_24
   1652              }
   1653              
   1654              ctraddr = (uint32_t)ctr;
   \                     ??CRYP_AES_CCM_55: (+1)
   \      0x668   0xAC11             ADD      R4,SP,#+68
   1655              /* Write the counter block in the IN FIFO */
   1656              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \      0x66A   0x6820             LDR      R0,[R4, #+0]
   \      0x66C   0x....'....        BL       CRYP_DataIn
   1657              ctraddr+=4;
   \      0x670   0x1D24             ADDS     R4,R4,#+4
   1658              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \      0x672   0x6820             LDR      R0,[R4, #+0]
   \      0x674   0x....'....        BL       CRYP_DataIn
   1659              ctraddr+=4;
   \      0x678   0x1D24             ADDS     R4,R4,#+4
   1660              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \      0x67A   0x6820             LDR      R0,[R4, #+0]
   \      0x67C   0x....'....        BL       CRYP_DataIn
   1661              ctraddr+=4;
   \      0x680   0x1D24             ADDS     R4,R4,#+4
   1662              /* Reset bit 0 (after 8-bit swap) is equivalent to reset bit 24 (before 8-bit swap) */
   1663              CRYP_DataIn(*(uint32_t*)(ctraddr) & 0xfeffffff);
   \      0x682   0x6820             LDR      R0,[R4, #+0]
   \      0x684   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \      0x688   0x....'....        BL       CRYP_DataIn
   1664              
   1665              /* Wait until the OFNE flag is reset */
   1666              while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_CCM_56: (+1)
   \      0x68C   0x2004             MOVS     R0,#+4
   \      0x68E   0x....'....        BL       CRYP_GetFlagStatus
   \      0x692   0x2800             CMP      R0,#+0
   \      0x694   0xD0FA             BEQ.N    ??CRYP_AES_CCM_56
   1667              {
   1668              }
   1669              
   1670              /* Read the Authentification TAG (MAC) in the IN FIFO */
   1671              temptag[0] = CRYP_DataOut();
   \      0x696   0x....'....        BL       CRYP_DataOut
   \      0x69A   0x9016             STR      R0,[SP, #+88]
   1672              temptag[1] = CRYP_DataOut();
   \      0x69C   0xAC16             ADD      R4,SP,#+88
   \      0x69E   0x....'....        BL       CRYP_DataOut
   \      0x6A2   0x6060             STR      R0,[R4, #+4]
   1673              temptag[2] = CRYP_DataOut();
   \      0x6A4   0x....'....        BL       CRYP_DataOut
   \      0x6A8   0x60A0             STR      R0,[R4, #+8]
   1674              temptag[3] = CRYP_DataOut();
   \      0x6AA   0x....'....        BL       CRYP_DataOut
   \      0x6AE   0x60E0             STR      R0,[R4, #+12]
   1675            }
   1676            
   1677            /* Copy temporary authentication TAG in user TAG buffer */
   1678            for(loopcounter = 0; (loopcounter < TAGSize); loopcounter++)
   \                     ??CRYP_AES_CCM_39: (+1)
   \      0x6B0   0x2000             MOVS     R0,#+0
   \      0x6B2   0xE004             B.N      ??CRYP_AES_CCM_57
   1679            {
   1680              /* Set the authentication TAG buffer */
   1681              *((uint8_t*)tagaddr+loopcounter) = *((uint8_t*)temptag+loopcounter);
   \                     ??CRYP_AES_CCM_58: (+1)
   \      0x6B4   0xA916             ADD      R1,SP,#+88
   \      0x6B6   0x5C09             LDRB     R1,[R1, R0]
   \      0x6B8   0x9A15             LDR      R2,[SP, #+84]
   \      0x6BA   0x5411             STRB     R1,[R2, R0]
   1682            }
   \      0x6BC   0x1C40             ADDS     R0,R0,#+1
   \                     ??CRYP_AES_CCM_57: (+1)
   \      0x6BE   0x9932             LDR      R1,[SP, #+200]
   \      0x6C0   0x4288             CMP      R0,R1
   \      0x6C2   0xD3F7             BCC.N    ??CRYP_AES_CCM_58
   1683            
   1684            /* Disable Crypto */
   1685            CRYP_Cmd(DISABLE);
   \      0x6C4   0x2000             MOVS     R0,#+0
   \      0x6C6   0x....'....        BL       CRYP_Cmd
   1686          
   1687            return status;
   \      0x6CA   0x0030             MOVS     R0,R6
   \      0x6CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??CRYP_AES_CCM_24: (+1)
   \      0x6CE   0xB021             ADD      SP,SP,#+132
   \      0x6D0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1688          }
   1689          
   1690          /**
   1691            * @}
   1692            */ 
   1693          
   1694          /**
   1695            * @}
   1696            */ 
   1697          
   1698          /**
   1699            * @}
   1700            */ 
   1701          
   1702          /**
   1703            * @}
   1704            */ 
   1705          
   1706          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
   1707          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     104   CRYP_AES_CBC
       104   -> CRYP_Cmd
       104   -> CRYP_DataIn
       104   -> CRYP_DataOut
       104   -> CRYP_FIFOFlush
       104   -> CRYP_GetCmdStatus
       104   -> CRYP_GetFlagStatus
       104   -> CRYP_IVInit
       104   -> CRYP_Init
       104   -> CRYP_KeyInit
       104   -> CRYP_KeyStructInit
     168   CRYP_AES_CCM
       168   -> CRYP_Cmd
       168   -> CRYP_DataIn
       168   -> CRYP_DataOut
       168   -> CRYP_FIFOFlush
       168   -> CRYP_GetCmdStatus
       168   -> CRYP_GetFlagStatus
       168   -> CRYP_IVInit
       168   -> CRYP_Init
       168   -> CRYP_KeyInit
       168   -> CRYP_KeyStructInit
       168   -> CRYP_PhaseConfig
       168   -> memset
     104   CRYP_AES_CTR
       104   -> CRYP_Cmd
       104   -> CRYP_DataIn
       104   -> CRYP_DataOut
       104   -> CRYP_FIFOFlush
       104   -> CRYP_GetCmdStatus
       104   -> CRYP_GetFlagStatus
       104   -> CRYP_IVInit
       104   -> CRYP_Init
       104   -> CRYP_KeyInit
       104   -> CRYP_KeyStructInit
      80   CRYP_AES_ECB
        80   -> CRYP_Cmd
        80   -> CRYP_DataIn
        80   -> CRYP_DataOut
        80   -> CRYP_FIFOFlush
        80   -> CRYP_GetCmdStatus
        80   -> CRYP_GetFlagStatus
        80   -> CRYP_Init
        80   -> CRYP_KeyInit
        80   -> CRYP_KeyStructInit
     128   CRYP_AES_GCM
       128   -> CRYP_Cmd
       128   -> CRYP_DataIn
       128   -> CRYP_DataOut
       128   -> CRYP_FIFOFlush
       128   -> CRYP_GetCmdStatus
       128   -> CRYP_GetFlagStatus
       128   -> CRYP_IVInit
       128   -> CRYP_Init
       128   -> CRYP_KeyInit
       128   -> CRYP_KeyStructInit
       128   -> CRYP_PhaseConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     596  CRYP_AES_CBC
    1748  CRYP_AES_CCM
     530  CRYP_AES_CTR
     544  CRYP_AES_ECB
    1272  CRYP_AES_GCM

 
 4'690 bytes in section .text
 
 4'690 bytes of CODE memory

Errors: none
Warnings: none
