###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.2.214/W32 for ARM         14/Jul/2020  18:42:04
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_hash.c
#    Command line =
#        -f C:\Users\Evan\AppData\Local\Temp\EW9953.tmp
#        (E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_hash.c
#        -D USE_STDPERIPH_DRIVER -D STM32F429_439xx -lC
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List
#        -o
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\IAR Systems\Embedded
#        Workbench 8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\CMSIS\Device\ST\STM32F4xx\Source\Templates\iar\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\..\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\user\inc\
#        -I
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\user\src\
#        -Ol --use_c++_inline -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "D:\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\List\stm32f4xx_hash.lst
#    Object file  =
#        E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\Cubli\Debug\Obj\stm32f4xx_hash.o
#
###############################################################################

E:\STM32Project\Cubli_with_STM32F429\Cubli-with-STM32F429\STM32F4xx_DSP_StdPeriph_Lib_V1.8.0\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_hash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hash.c
      4            * @author  MCD Application Team
      5            * @version V1.8.0
      6            * @date    04-November-2016
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the HASH / HMAC Processor (HASH) peripheral:           
      9            *           - Initialization and Configuration functions
     10            *           - Message Digest generation functions
     11            *           - context swapping functions   
     12            *           - DMA interface function       
     13            *           - Interrupts and flags management       
     14            *         
     15          @verbatim
     16           ===================================================================      
     17                           ##### How to use this driver #####
     18           ===================================================================
     19                      
     20           *** HASH operation : *** 
     21           ========================                 
     22           [..]
     23             (#) Enable the HASH controller clock using 
     24                 RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_HASH, ENABLE) function.
     25                       
     26             (#) Initialize the HASH using HASH_Init() function. 
     27                           
     28             (#) Reset the HASH processor core, so that the HASH will be ready 
     29                 to compute he message digest of a new message by using HASH_Reset() function.
     30            
     31             (#) Enable the HASH controller using the HASH_Cmd() function. 
     32                            
     33             (#) if using DMA for Data input transfer, Activate the DMA Request 
     34                 using HASH_DMACmd() function 
     35                                
     36             (#) if DMA is not used for data transfer, use HASH_DataIn() function 
     37                 to enter data to IN FIFO.
     38                         
     39                      
     40             (#) Configure the Number of valid bits in last word of the message 
     41                 using HASH_SetLastWordValidBitsNbr() function.
     42                         
     43             (#) if the message length is not an exact multiple of 512 bits, 
     44                 then the function HASH_StartDigest() must be called to launch the computation
     45                 of the final digest.     
     46                         
     47             (#) Once computed, the digest can be read using HASH_GetDigest() function.         
     48                               
     49             (#) To control HASH events you can use one of the following wo methods:
     50                 (++) Check on HASH flags using the HASH_GetFlagStatus() function.  
     51                 (++) Use HASH interrupts through the function HASH_ITConfig() at 
     52                      initialization phase and HASH_GetITStatus() function into 
     53                      interrupt routines in hashing phase.
     54                      After checking on a flag you should clear it using HASH_ClearFlag()
     55                      function. And after checking on an interrupt event you should 
     56                      clear it using HASH_ClearITPendingBit() function.     
     57                                 
     58             (#) Save and restore hash processor context using 
     59                 HASH_SaveContext() and HASH_RestoreContext() functions.     
     60                          
     61            
     62                        
     63           *** HMAC operation : *** 
     64           ========================
     65           [..] The HMAC algorithm is used for message authentication, by 
     66                irreversibly binding the message being processed to a key chosen 
     67                by the user. 
     68                For HMAC specifications, refer to "HMAC: keyed-hashing for message 
     69                authentication, H. Krawczyk, M. Bellare, R. Canetti, February 1997"
     70                      
     71           [..] Basically, the HMAC algorithm consists of two nested hash operations:
     72                HMAC(message) = Hash[((key | pad) XOR 0x5C) | Hash(((key | pad) XOR 0x36) | message)]
     73                where:
     74                (+) "pad" is a sequence of zeroes needed to extend the key to the 
     75                    length of the underlying hash function data block (that is 
     76                    512 bits for both the SHA-1 and MD5 hash algorithms)
     77                (+) "|"   represents the concatenation operator 
     78                      
     79                     
     80           [..]To compute the HMAC, four different phases are required:                  
     81             (#) Initialize the HASH using HASH_Init() function to do HMAC 
     82                 operation. 
     83                            
     84             (#) The key (to be used for the inner hash function) is then given to the core. 
     85                 This operation follows the same mechanism as the one used to send the 
     86                 message in the hash operation (that is, by HASH_DataIn() function and, 
     87                 finally, HASH_StartDigest() function.
     88                      
     89             (#) Once the last word has been entered and computation has started, 
     90                 the hash processor elaborates the key. It is then ready to accept the message
     91                 text using the same mechanism as the one used to send the message in the
     92                 hash operation.
     93                   
     94             (#) After the first hash round, the hash processor returns "ready" to indicate 
     95                 that it is ready to receive the key to be used for the outer hash function 
     96                 (normally, this key is the same as the one used for the inner hash function). 
     97                 When the last word of the key is entered and computation starts, the HMAC 
     98                 result is made available using HASH_GetDigest() function.
     99          
    100          @endverbatim
    101            *         
    102            ******************************************************************************
    103            * @attention
    104            *
    105            * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
    106            *
    107            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    108            * You may not use this file except in compliance with the License.
    109            * You may obtain a copy of the License at:
    110            *
    111            *        http://www.st.com/software_license_agreement_liberty_v2
    112            *
    113            * Unless required by applicable law or agreed to in writing, software 
    114            * distributed under the License is distributed on an "AS IS" BASIS, 
    115            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    116            * See the License for the specific language governing permissions and
    117            * limitations under the License.
    118            *
    119            ******************************************************************************  
    120            */
    121          
    122          /* Includes ------------------------------------------------------------------*/
    123          #include "stm32f4xx_hash.h"
    124          #include "stm32f4xx_rcc.h"
    125          
    126          /** @addtogroup STM32F4xx_StdPeriph_Driver
    127            * @{
    128            */
    129          
    130          /** @defgroup HASH 
    131            * @brief HASH driver modules
    132            * @{
    133            */ 
    134          
    135          /* Private typedef -----------------------------------------------------------*/
    136          /* Private define ------------------------------------------------------------*/
    137          /* Private macro -------------------------------------------------------------*/
    138          /* Private variables ---------------------------------------------------------*/
    139          /* Private function prototypes -----------------------------------------------*/
    140          /* Private functions ---------------------------------------------------------*/ 
    141          
    142          /** @defgroup HASH_Private_Functions
    143            * @{
    144            */ 
    145          
    146          /** @defgroup HASH_Group1 Initialization and Configuration functions
    147           *  @brief    Initialization and Configuration functions 
    148           *
    149          @verbatim    
    150           ===============================================================================
    151                        ##### Initialization and Configuration functions #####
    152           ===============================================================================  
    153           [..] This section provides functions allowing to 
    154             (+) Initialize the HASH peripheral
    155             (+) Configure the HASH Processor 
    156             (+) MD5/SHA1, 
    157             (+) HASH/HMAC, 
    158             (+) datatype 
    159             (+) HMAC Key (if mode = HMAC)
    160             (+) Reset the HASH Processor 
    161             
    162          @endverbatim
    163            * @{
    164            */
    165            
    166          /**
    167            * @brief  De-initializes the HASH peripheral registers to their default reset values
    168            * @param  None
    169            * @retval None
    170            */

   \                                 In section .text, align 2, keep-with-next
    171          void HASH_DeInit(void)
    172          {
   \                     HASH_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    173            /* Enable HASH reset state */
    174            RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, ENABLE);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0x....'....        BL       RCC_AHB2PeriphResetCmd
    175            /* Release HASH from reset state */
    176            RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, DISABLE);
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x2020             MOVS     R0,#+32
   \        0xE   0x....'....        BL       RCC_AHB2PeriphResetCmd
    177          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    178          
    179          /**
    180            * @brief  Initializes the HASH peripheral according to the specified parameters
    181            *         in the HASH_InitStruct structure.
    182            * @note   the hash processor is reset when calling this function so that the
    183            *         HASH will be ready to compute the message digest of a new message.
    184            *         There is no need to call HASH_Reset() function.           
    185            * @param  HASH_InitStruct: pointer to a HASH_InitTypeDef structure that contains
    186            *         the configuration information for the HASH peripheral.
    187            * @note   The field HASH_HMACKeyType in HASH_InitTypeDef must be filled only 
    188            *          if the algorithm mode is HMAC.       
    189            * @retval None
    190            */

   \                                 In section .text, align 2, keep-with-next
    191          void HASH_Init(HASH_InitTypeDef* HASH_InitStruct)
    192          {
   \                     HASH_Init: (+1)
   \        0x0   0xB410             PUSH     {R4}
    193            /* Check the parameters */
    194            assert_param(IS_HASH_ALGOSELECTION(HASH_InitStruct->HASH_AlgoSelection));
    195            assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
    196            assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
    197            
    198            /* Configure the Algorithm used, algorithm mode and the datatype */
    199            HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
   \        0x2   0x....             LDR.N    R2,??DataTable16  ;; 0x50060400
   \        0x4   0x6813             LDR      R3,[R2, #+0]
   \        0x6   0x....             LDR.N    R1,??DataTable16_1  ;; 0xfffbff0f
   \        0x8   0x400B             ANDS     R3,R1,R3
   \        0xA   0x6013             STR      R3,[R2, #+0]
    200            HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
    201                         HASH_InitStruct->HASH_DataType | \
    202                         HASH_InitStruct->HASH_AlgoMode);
   \        0xC   0x6813             LDR      R3,[R2, #+0]
   \        0xE   0x6804             LDR      R4,[R0, #+0]
   \       0x10   0x6881             LDR      R1,[R0, #+8]
   \       0x12   0x430C             ORRS     R4,R1,R4
   \       0x14   0x6841             LDR      R1,[R0, #+4]
   \       0x16   0x430C             ORRS     R4,R1,R4
   \       0x18   0x4323             ORRS     R3,R4,R3
   \       0x1A   0x6013             STR      R3,[R2, #+0]
    203            
    204            /* if algorithm mode is HMAC, set the Key */  
    205            if(HASH_InitStruct->HASH_AlgoMode == HASH_AlgoMode_HMAC) 
   \       0x1C   0x6841             LDR      R1,[R0, #+4]
   \       0x1E   0x2940             CMP      R1,#+64
   \       0x20   0xD107             BNE.N    ??HASH_Init_0
    206            {
    207              assert_param(IS_HASH_HMAC_KEYTYPE(HASH_InitStruct->HASH_HMACKeyType));
    208              HASH->CR &= ~HASH_CR_LKEY;
   \       0x22   0x6811             LDR      R1,[R2, #+0]
   \       0x24   0xF431 0x3180      BICS     R1,R1,#0x10000
   \       0x28   0x6011             STR      R1,[R2, #+0]
    209              HASH->CR |= HASH_InitStruct->HASH_HMACKeyType;
   \       0x2A   0x6811             LDR      R1,[R2, #+0]
   \       0x2C   0x68C0             LDR      R0,[R0, #+12]
   \       0x2E   0x4301             ORRS     R1,R0,R1
   \       0x30   0x6011             STR      R1,[R2, #+0]
    210            }
    211          
    212            /* Reset the HASH processor core, so that the HASH will be ready to compute 
    213               the message digest of a new message */
    214            HASH->CR |= HASH_CR_INIT;  
   \                     ??HASH_Init_0: (+1)
   \       0x32   0x6810             LDR      R0,[R2, #+0]
   \       0x34   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x38   0x6010             STR      R0,[R2, #+0]
    215          }
   \       0x3A   0xBC10             POP      {R4}
   \       0x3C   0x4770             BX       LR               ;; return
    216          
    217          /**
    218            * @brief  Fills each HASH_InitStruct member with its default value.
    219            * @param  HASH_InitStruct : pointer to a HASH_InitTypeDef structure which will
    220            *          be initialized.  
    221            *  @note  The default values set are : Processor mode is HASH, Algorithm selected is SHA1,
    222            *          Data type selected is 32b and HMAC Key Type is short key.  
    223            * @retval None
    224            */

   \                                 In section .text, align 2, keep-with-next
    225          void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct)
    226          {
    227            /* Initialize the HASH_AlgoSelection member */
    228            HASH_InitStruct->HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
   \                     HASH_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    229          
    230            /* Initialize the HASH_AlgoMode member */
    231            HASH_InitStruct->HASH_AlgoMode = HASH_AlgoMode_HASH;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6041             STR      R1,[R0, #+4]
    232          
    233            /* Initialize the HASH_DataType member */
    234            HASH_InitStruct->HASH_DataType = HASH_DataType_32b;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6081             STR      R1,[R0, #+8]
    235          
    236            /* Initialize the HASH_HMACKeyType member */
    237            HASH_InitStruct->HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x60C1             STR      R1,[R0, #+12]
    238          }
   \       0x10   0x4770             BX       LR               ;; return
    239          
    240          /**
    241            * @brief  Resets the HASH processor core, so that the HASH will be ready
    242            *         to compute the message digest of a new message.
    243            * @note   Calling this function will clear the HASH_SR_DCIS (Digest calculation 
    244            *         completion interrupt status) bit corresponding to HASH_IT_DCI 
    245            *         interrupt and HASH_FLAG_DCIS flag. 
    246            * @param  None
    247            * @retval None
    248            */

   \                                 In section .text, align 2, keep-with-next
    249          void HASH_Reset(void)
    250          {
    251            /* Reset the HASH processor core */
    252            HASH->CR |= HASH_CR_INIT;
   \                     HASH_Reset: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16  ;; 0x50060400
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0104      ORRS     R1,R1,#0x4
   \        0x8   0x6001             STR      R1,[R0, #+0]
    253          }
   \        0xA   0x4770             BX       LR               ;; return
    254          /**
    255            * @}
    256            */
    257           
    258          /** @defgroup HASH_Group2 Message Digest generation functions
    259           *  @brief    Message Digest generation functions
    260           *
    261          @verbatim    
    262           ===============================================================================
    263                            ##### Message Digest generation functions #####
    264           ===============================================================================  
    265           [..] This section provides functions allowing the generation of message digest: 
    266             (+) Push data in the IN FIFO : using HASH_DataIn()
    267             (+) Get the number of words set in IN FIFO, use HASH_GetInFIFOWordsNbr()  
    268             (+) set the last word valid bits number using HASH_SetLastWordValidBitsNbr() 
    269             (+) start digest calculation : using HASH_StartDigest()
    270             (+) Get the Digest message : using HASH_GetDigest()
    271           
    272          @endverbatim
    273            * @{
    274            */
    275          
    276          
    277          /**
    278            * @brief  Configure the Number of valid bits in last word of the message
    279            * @param  ValidNumber: Number of valid bits in last word of the message.
    280            *           This parameter must be a number between 0 and 0x1F.
    281            *             - 0x00: All 32 bits of the last data written are valid
    282            *             - 0x01: Only bit [0] of the last data written is valid
    283            *             - 0x02: Only bits[1:0] of the last data written are valid
    284            *             - 0x03: Only bits[2:0] of the last data written are valid
    285            *             - ...
    286            *             - 0x1F: Only bits[30:0] of the last data written are valid    
    287            * @note   The Number of valid bits must be set before to start the message 
    288            *         digest competition (in Hash and HMAC) and key treatment(in HMAC).    
    289            * @retval None
    290            */

   \                                 In section .text, align 2, keep-with-next
    291          void HASH_SetLastWordValidBitsNbr(uint16_t ValidNumber)
    292          {
    293            /* Check the parameters */
    294            assert_param(IS_HASH_VALIDBITSNUMBER(ValidNumber));
    295            
    296            /* Configure the Number of valid bits in last word of the message */
    297            HASH->STR &= ~(HASH_STR_NBW);
   \                     HASH_SetLastWordValidBitsNbr: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable16_2  ;; 0x50060408
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x0952             LSRS     R2,R2,#+5
   \        0x6   0x0152             LSLS     R2,R2,#+5
   \        0x8   0x600A             STR      R2,[R1, #+0]
    298            HASH->STR |= ValidNumber;
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \        0xE   0x4310             ORRS     R0,R0,R2
   \       0x10   0x6008             STR      R0,[R1, #+0]
    299          }
   \       0x12   0x4770             BX       LR               ;; return
    300          
    301          /**
    302            * @brief  Writes data in the Data Input FIFO
    303            * @param  Data: new data of the message to be processed.
    304            * @retval None
    305            */

   \                                 In section .text, align 2, keep-with-next
    306          void HASH_DataIn(uint32_t Data)
    307          {
    308            /* Write in the DIN register a new data */
    309            HASH->DIN = Data;
   \                     HASH_DataIn: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable16_3  ;; 0x50060404
   \        0x2   0x6008             STR      R0,[R1, #+0]
    310          }
   \        0x4   0x4770             BX       LR               ;; return
    311          
    312          /**
    313            * @brief  Returns the number of words already pushed into the IN FIFO.
    314            * @param  None
    315            * @retval The value of words already pushed into the IN FIFO.
    316            */

   \                                 In section .text, align 2, keep-with-next
    317          uint8_t HASH_GetInFIFOWordsNbr(void)
    318          {
    319            /* Return the value of NBW bits */
    320            return ((HASH->CR & HASH_CR_NBW) >> 8);
   \                     HASH_GetInFIFOWordsNbr: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16  ;; 0x50060400
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0A00             LSRS     R0,R0,#+8
   \        0x6   0xF010 0x000F      ANDS     R0,R0,#0xF
   \        0xA   0x4770             BX       LR               ;; return
    321          }
    322          
    323          /**
    324            * @brief  Provides the message digest result.
    325            * @note   In MD5 mode, Data[7] to Data[4] filed of HASH_MsgDigest structure is not used
    326            *         and is read as zero.
    327            *         In SHA-1 mode, Data[7] to Data[5] filed of HASH_MsgDigest structure is not used
    328            *         and is read as zero.    
    329            *         In SHA-224 mode, Data[7] filed of HASH_MsgDigest structure is not used
    330            *         and is read as zero.  
    331            * @param  HASH_MessageDigest: pointer to a HASH_MsgDigest structure which will 
    332            *         hold the message digest result 
    333            * @retval None
    334            */

   \                                 In section .text, align 2, keep-with-next
    335          void HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest)
    336          {
    337            /* Get the data field */
    338            HASH_MessageDigest->Data[0] = HASH->HR[0];
   \                     HASH_GetDigest: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable16_4  ;; 0x5006040c
   \        0x2   0x6809             LDR      R1,[R1, #+0]
   \        0x4   0x6001             STR      R1,[R0, #+0]
    339            HASH_MessageDigest->Data[1] = HASH->HR[1];
   \        0x6   0x....             LDR.N    R1,??DataTable16_5  ;; 0x50060410
   \        0x8   0x6809             LDR      R1,[R1, #+0]
   \        0xA   0x6041             STR      R1,[R0, #+4]
    340            HASH_MessageDigest->Data[2] = HASH->HR[2];
   \        0xC   0x....             LDR.N    R1,??DataTable16_6  ;; 0x50060414
   \        0xE   0x6809             LDR      R1,[R1, #+0]
   \       0x10   0x6081             STR      R1,[R0, #+8]
    341            HASH_MessageDigest->Data[3] = HASH->HR[3];
   \       0x12   0x....             LDR.N    R1,??DataTable16_7  ;; 0x50060418
   \       0x14   0x6809             LDR      R1,[R1, #+0]
   \       0x16   0x60C1             STR      R1,[R0, #+12]
    342            HASH_MessageDigest->Data[4] = HASH->HR[4];
   \       0x18   0x....             LDR.N    R1,??DataTable16_8  ;; 0x5006041c
   \       0x1A   0x6809             LDR      R1,[R1, #+0]
   \       0x1C   0x6101             STR      R1,[R0, #+16]
    343            HASH_MessageDigest->Data[5] = HASH_DIGEST->HR[5];
   \       0x1E   0x....             LDR.N    R1,??DataTable16_9  ;; 0x50060724
   \       0x20   0x6809             LDR      R1,[R1, #+0]
   \       0x22   0x6141             STR      R1,[R0, #+20]
    344            HASH_MessageDigest->Data[6] = HASH_DIGEST->HR[6];
   \       0x24   0x....             LDR.N    R1,??DataTable16_10  ;; 0x50060728
   \       0x26   0x6809             LDR      R1,[R1, #+0]
   \       0x28   0x6181             STR      R1,[R0, #+24]
    345            HASH_MessageDigest->Data[7] = HASH_DIGEST->HR[7];
   \       0x2A   0x....             LDR.N    R1,??DataTable16_11  ;; 0x5006072c
   \       0x2C   0x6809             LDR      R1,[R1, #+0]
   \       0x2E   0x61C1             STR      R1,[R0, #+28]
    346          }
   \       0x30   0x4770             BX       LR               ;; return
    347          
    348          /**
    349            * @brief  Starts the message padding and calculation of the final message     
    350            * @param  None
    351            * @retval None
    352            */

   \                                 In section .text, align 2, keep-with-next
    353          void HASH_StartDigest(void)
    354          {
    355            /* Start the Digest calculation */
    356            HASH->STR |= HASH_STR_DCAL;
   \                     HASH_StartDigest: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_2  ;; 0x50060408
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF451 0x7180      ORRS     R1,R1,#0x100
   \        0x8   0x6001             STR      R1,[R0, #+0]
    357          }
   \        0xA   0x4770             BX       LR               ;; return
    358          /**
    359            * @}
    360            */
    361          
    362          /** @defgroup HASH_Group3 Context swapping functions
    363           *  @brief   Context swapping functions
    364           *
    365          @verbatim   
    366           ===============================================================================
    367                                ##### Context swapping functions #####
    368           ===============================================================================  
    369           
    370           [..] This section provides functions allowing to save and store HASH Context
    371            
    372           [..] It is possible to interrupt a HASH/HMAC process to perform another processing 
    373                with a higher priority, and to complete the interrupted process later on, when 
    374                the higher priority task is complete. To do so, the context of the interrupted 
    375                task must be saved from the HASH registers to memory, and then be restored 
    376                from memory to the HASH registers.
    377            
    378             (#) To save the current context, use HASH_SaveContext() function
    379             (#) To restore the saved context, use HASH_RestoreContext() function 
    380            
    381          
    382          @endverbatim
    383            * @{
    384            */
    385            
    386          /**
    387            * @brief  Save the Hash peripheral Context. 
    388            * @note   The context can be saved only when no block is currently being 
    389            *         processed. So user must wait for DINIS = 1 (the last block has been 
    390            *         processed and the input FIFO is empty) or NBW != 0 (the FIFO is not 
    391            *         full and no processing is ongoing).   
    392            * @param  HASH_ContextSave: pointer to a HASH_Context structure that contains
    393            *         the repository for current context.
    394            * @retval None
    395            */

   \                                 In section .text, align 2, keep-with-next
    396          void HASH_SaveContext(HASH_Context* HASH_ContextSave)
    397          {
    398            uint8_t i = 0;
   \                     HASH_SaveContext: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
    399            
    400            /* save context registers */
    401            HASH_ContextSave->HASH_IMR = HASH->IMR;  
   \        0x2   0x....             LDR.N    R1,??DataTable16_12  ;; 0x50060420
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0x6001             STR      R1,[R0, #+0]
    402            HASH_ContextSave->HASH_STR = HASH->STR;      
   \        0x8   0x....             LDR.N    R1,??DataTable16_2  ;; 0x50060408
   \        0xA   0x6809             LDR      R1,[R1, #+0]
   \        0xC   0x6041             STR      R1,[R0, #+4]
    403            HASH_ContextSave->HASH_CR  = HASH->CR;     
   \        0xE   0x....             LDR.N    R1,??DataTable16  ;; 0x50060400
   \       0x10   0x6809             LDR      R1,[R1, #+0]
   \       0x12   0x6081             STR      R1,[R0, #+8]
    404            for(i=0; i<=53;i++)
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0xE00A             B.N      ??HASH_SaveContext_0
    405            {
    406               HASH_ContextSave->HASH_CSR[i] = HASH->CSR[i];
   \                     ??HASH_SaveContext_1: (+1)
   \       0x18   0x....             LDR.N    R2,??DataTable16_13  ;; 0x500604f8
   \       0x1A   0x000B             MOVS     R3,R1
   \       0x1C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x1E   0xF852 0x2023      LDR      R2,[R2, R3, LSL #+2]
   \       0x22   0x000B             MOVS     R3,R1
   \       0x24   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x26   0xEB00 0x0383      ADD      R3,R0,R3, LSL #+2
   \       0x2A   0x60DA             STR      R2,[R3, #+12]
    407            }   
   \       0x2C   0x1C49             ADDS     R1,R1,#+1
   \                     ??HASH_SaveContext_0: (+1)
   \       0x2E   0x000A             MOVS     R2,R1
   \       0x30   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x32   0x2A36             CMP      R2,#+54
   \       0x34   0xDBF0             BLT.N    ??HASH_SaveContext_1
    408          }
   \       0x36   0x4770             BX       LR               ;; return
    409          
    410          /**
    411            * @brief  Restore the Hash peripheral Context.  
    412            * @note   After calling this function, user can restart the processing from the
    413            *         point where it has been interrupted.  
    414            * @param  HASH_ContextRestore: pointer to a HASH_Context structure that contains
    415            *         the repository for saved context.
    416            * @retval None
    417            */

   \                                 In section .text, align 2, keep-with-next
    418          void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)  
    419          {
   \                     HASH_RestoreContext: (+1)
   \        0x0   0xB410             PUSH     {R4}
    420            uint8_t i = 0;
   \        0x2   0x2100             MOVS     R1,#+0
    421            
    422            /* restore context registers */
    423            HASH->IMR = HASH_ContextRestore->HASH_IMR;   
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x....             LDR.N    R2,??DataTable16_12  ;; 0x50060420
   \        0x8   0x6011             STR      R1,[R2, #+0]
    424            HASH->STR = HASH_ContextRestore->HASH_STR;     
   \        0xA   0x6841             LDR      R1,[R0, #+4]
   \        0xC   0x....             LDR.N    R2,??DataTable16_2  ;; 0x50060408
   \        0xE   0x6011             STR      R1,[R2, #+0]
    425            HASH->CR = HASH_ContextRestore->HASH_CR;
   \       0x10   0x....             LDR.N    R1,??DataTable16  ;; 0x50060400
   \       0x12   0x6882             LDR      R2,[R0, #+8]
   \       0x14   0x600A             STR      R2,[R1, #+0]
    426            
    427            /* Initialize the hash processor */
    428            HASH->CR |= HASH_CR_INIT; 
   \       0x16   0x680A             LDR      R2,[R1, #+0]
   \       0x18   0xF052 0x0204      ORRS     R2,R2,#0x4
   \       0x1C   0x600A             STR      R2,[R1, #+0]
    429            
    430             /* continue restoring context registers */     
    431            for(i=0; i<=53;i++)
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0xE00A             B.N      ??HASH_RestoreContext_0
    432            {
    433               HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];
   \                     ??HASH_RestoreContext_1: (+1)
   \       0x22   0x000A             MOVS     R2,R1
   \       0x24   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x26   0xEB00 0x0282      ADD      R2,R0,R2, LSL #+2
   \       0x2A   0x68D2             LDR      R2,[R2, #+12]
   \       0x2C   0x....             LDR.N    R3,??DataTable16_13  ;; 0x500604f8
   \       0x2E   0x000C             MOVS     R4,R1
   \       0x30   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \       0x32   0xF843 0x2024      STR      R2,[R3, R4, LSL #+2]
    434            }   
   \       0x36   0x1C49             ADDS     R1,R1,#+1
   \                     ??HASH_RestoreContext_0: (+1)
   \       0x38   0x000A             MOVS     R2,R1
   \       0x3A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \       0x3C   0x2A36             CMP      R2,#+54
   \       0x3E   0xDBF0             BLT.N    ??HASH_RestoreContext_1
    435          }
   \       0x40   0xBC10             POP      {R4}
   \       0x42   0x4770             BX       LR               ;; return
    436          /**
    437            * @}
    438            */
    439          
    440          /** @defgroup HASH_Group4 HASH's DMA interface Configuration function
    441           *  @brief   HASH's DMA interface Configuration function 
    442           *
    443          @verbatim   
    444           ===============================================================================
    445                         ##### HASH's DMA interface Configuration function #####
    446           ===============================================================================  
    447          
    448           [..] This section provides functions allowing to configure the DMA interface for 
    449                HASH/ HMAC data input transfer.
    450             
    451           [..] When the DMA mode is enabled (using the HASH_DMACmd() function), data can be 
    452                sent to the IN FIFO using the DMA peripheral.
    453          
    454          @endverbatim
    455            * @{
    456            */
    457          
    458          /**
    459            * @brief  Enables or disables auto-start message padding and
    460            *         calculation of the final message digest at the end of DMA transfer.
    461            * @param  NewState: new state of the selected HASH DMA transfer request.
    462            *          This parameter can be: ENABLE or DISABLE.
    463            * @retval None
    464            */

   \                                 In section .text, align 2, keep-with-next
    465          void HASH_AutoStartDigest(FunctionalState NewState)
    466          {
    467            /* Check the parameters */
    468            assert_param(IS_FUNCTIONAL_STATE(NewState));
    469          
    470            if (NewState != DISABLE)
   \                     HASH_AutoStartDigest: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD005             BEQ.N    ??HASH_AutoStartDigest_0
    471            {
    472              /* Enable the auto start of the final message digest at the end of DMA transfer */
    473              HASH->CR &= ~HASH_CR_MDMAT;
   \        0x6   0x....             LDR.N    R0,??DataTable16  ;; 0x50060400
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0xF431 0x5100      BICS     R1,R1,#0x2000
   \        0xE   0x6001             STR      R1,[R0, #+0]
   \       0x10   0xE004             B.N      ??HASH_AutoStartDigest_1
    474            }
    475            else
    476            {
    477              /* Disable the auto start of the final message digest at the end of DMA transfer */
    478              HASH->CR |= HASH_CR_MDMAT;
   \                     ??HASH_AutoStartDigest_0: (+1)
   \       0x12   0x....             LDR.N    R0,??DataTable16  ;; 0x50060400
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xF451 0x5100      ORRS     R1,R1,#0x2000
   \       0x1A   0x6001             STR      R1,[R0, #+0]
    479            }
    480          }
   \                     ??HASH_AutoStartDigest_1: (+1)
   \       0x1C   0x4770             BX       LR               ;; return
    481            
    482          /**
    483            * @brief  Enables or disables the HASH DMA interface.
    484            * @note   The DMA is disabled by hardware after the end of transfer.
    485            * @param  NewState: new state of the selected HASH DMA transfer request.
    486            *          This parameter can be: ENABLE or DISABLE.
    487            * @retval None
    488            */

   \                                 In section .text, align 2, keep-with-next
    489          void HASH_DMACmd(FunctionalState NewState)
    490          {
    491            /* Check the parameters */
    492            assert_param(IS_FUNCTIONAL_STATE(NewState));
    493          
    494            if (NewState != DISABLE)
   \                     HASH_DMACmd: (+1)
   \        0x0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD005             BEQ.N    ??HASH_DMACmd_0
    495            {
    496              /* Enable the HASH DMA request */
    497              HASH->CR |= HASH_CR_DMAE;
   \        0x6   0x....             LDR.N    R0,??DataTable16  ;; 0x50060400
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0xF051 0x0108      ORRS     R1,R1,#0x8
   \        0xE   0x6001             STR      R1,[R0, #+0]
   \       0x10   0xE004             B.N      ??HASH_DMACmd_1
    498            }
    499            else
    500            {
    501              /* Disable the HASH DMA request */
    502              HASH->CR &= ~HASH_CR_DMAE;
   \                     ??HASH_DMACmd_0: (+1)
   \       0x12   0x....             LDR.N    R0,??DataTable16  ;; 0x50060400
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xF031 0x0108      BICS     R1,R1,#0x8
   \       0x1A   0x6001             STR      R1,[R0, #+0]
    503            }
    504          }
   \                     ??HASH_DMACmd_1: (+1)
   \       0x1C   0x4770             BX       LR               ;; return
    505          /**
    506            * @}
    507            */
    508          
    509          /** @defgroup HASH_Group5 Interrupts and flags management functions
    510           *  @brief   Interrupts and flags management functions
    511           *
    512          @verbatim   
    513           ===============================================================================
    514                         ##### Interrupts and flags management functions #####
    515           ===============================================================================  
    516          
    517           [..] This section provides functions allowing to configure the HASH Interrupts and 
    518                to get the status and clear flags and Interrupts pending bits.
    519            
    520           [..] The HASH provides 2 Interrupts sources and 5 Flags:
    521            
    522           *** Flags : ***
    523           =============== 
    524           [..]
    525             (#) HASH_FLAG_DINIS : set when 16 locations are free in the Data IN FIFO 
    526                which means that a  new block (512 bit) can be entered into the input buffer.
    527                                    
    528             (#) HASH_FLAG_DCIS :  set when Digest calculation is complete
    529                
    530             (#) HASH_FLAG_DMAS :  set when HASH's DMA interface is enabled (DMAE=1) or 
    531                 a transfer is ongoing. This Flag is cleared only by hardware.
    532                                     
    533             (#) HASH_FLAG_BUSY :  set when The hash core is processing a block of data
    534                 This Flag is cleared only by hardware. 
    535                                     
    536             (#) HASH_FLAG_DINNE : set when Data IN FIFO is not empty which means that 
    537                 the Data IN FIFO contains at least one word of data. This Flag is cleared 
    538                 only by hardware.
    539               
    540           *** Interrupts : ***
    541           ====================
    542           [..]   
    543             (#) HASH_IT_DINI  : if enabled, this interrupt source is pending when 16 
    544                 locations are free in the Data IN FIFO  which means that a new block (512 bit)
    545                 can be entered into the input buffer. This interrupt source is cleared using 
    546                 HASH_ClearITPendingBit(HASH_IT_DINI) function.
    547             
    548             (#) HASH_IT_DCI   : if enabled, this interrupt source is pending when Digest 
    549                 calculation is complete. This interrupt source is cleared using 
    550                 HASH_ClearITPendingBit(HASH_IT_DCI) function.
    551          
    552           *** Managing the HASH controller events : ***
    553           =============================================
    554           [..] The user should identify which mode will be used in his application to manage 
    555                the HASH controller events: Polling mode or Interrupt mode.
    556            
    557             (#) In the Polling Mode it is advised to use the following functions:
    558                 (++) HASH_GetFlagStatus() : to check if flags events occur. 
    559                 (++) HASH_ClearFlag()     : to clear the flags events.
    560              
    561             (#)  In the Interrupt Mode it is advised to use the following functions:
    562                 (++) HASH_ITConfig()       : to enable or disable the interrupt source.
    563                 (++) HASH_GetITStatus()    : to check if Interrupt occurs.
    564                 (++) HASH_ClearITPendingBit() : to clear the Interrupt pending Bit 
    565                      (corresponding Flag). 
    566          
    567          @endverbatim
    568            * @{
    569            */ 
    570            
    571          /**
    572            * @brief  Enables or disables the specified HASH interrupts.
    573            * @param  HASH_IT: specifies the HASH interrupt source to be enabled or disabled.
    574            *          This parameter can be any combination of the following values:
    575            *            @arg HASH_IT_DINI: Data Input interrupt
    576            *            @arg HASH_IT_DCI: Digest Calculation Completion Interrupt
    577            * @param  NewState: new state of the specified HASH interrupt.
    578            *           This parameter can be: ENABLE or DISABLE.
    579            * @retval None
    580            */

   \                                 In section .text, align 2, keep-with-next
    581          void HASH_ITConfig(uint32_t HASH_IT, FunctionalState NewState)
    582          {
    583            /* Check the parameters */
    584            assert_param(IS_HASH_IT(HASH_IT));
    585            assert_param(IS_FUNCTIONAL_STATE(NewState));
    586          
    587            if (NewState != DISABLE)
   \                     HASH_ITConfig: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??HASH_ITConfig_0
    588            {
    589              /* Enable the selected HASH interrupt */
    590              HASH->IMR |= HASH_IT;
   \        0x6   0x....             LDR.N    R1,??DataTable16_12  ;; 0x50060420
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0x4310             ORRS     R0,R0,R2
   \        0xC   0x6008             STR      R0,[R1, #+0]
   \        0xE   0xE004             B.N      ??HASH_ITConfig_1
    591            }
    592            else
    593            {
    594              /* Disable the selected HASH interrupt */
    595              HASH->IMR &= (uint32_t)(~HASH_IT);
   \                     ??HASH_ITConfig_0: (+1)
   \       0x10   0x....             LDR.N    R1,??DataTable16_12  ;; 0x50060420
   \       0x12   0x680A             LDR      R2,[R1, #+0]
   \       0x14   0xEA32 0x0000      BICS     R0,R2,R0
   \       0x18   0x6008             STR      R0,[R1, #+0]
    596            }
    597          }
   \                     ??HASH_ITConfig_1: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
    598          
    599          /**
    600            * @brief  Checks whether the specified HASH flag is set or not.
    601            * @param  HASH_FLAG: specifies the HASH flag to check.
    602            *          This parameter can be one of the following values:
    603            *            @arg HASH_FLAG_DINIS: Data input interrupt status flag
    604            *            @arg HASH_FLAG_DCIS: Digest calculation completion interrupt status flag
    605            *            @arg HASH_FLAG_BUSY: Busy flag
    606            *            @arg HASH_FLAG_DMAS: DMAS Status flag
    607            *            @arg HASH_FLAG_DINNE: Data Input register (DIN) not empty status flag
    608            * @retval The new state of HASH_FLAG (SET or RESET)
    609            */

   \                                 In section .text, align 2, keep-with-next
    610          FlagStatus HASH_GetFlagStatus(uint32_t HASH_FLAG)
    611          {
    612            FlagStatus bitstatus = RESET;
   \                     HASH_GetFlagStatus: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
    613            uint32_t tempreg = 0;
   \        0x2   0x2100             MOVS     R1,#+0
    614          
    615            /* Check the parameters */
    616            assert_param(IS_HASH_GET_FLAG(HASH_FLAG));
    617          
    618            /* check if the FLAG is in CR register */
    619            if ((HASH_FLAG & HASH_FLAG_DINNE) != (uint32_t)RESET ) 
   \        0x4   0x04C1             LSLS     R1,R0,#+19
   \        0x6   0xD502             BPL.N    ??HASH_GetFlagStatus_0
    620            {
    621              tempreg = HASH->CR;
   \        0x8   0x....             LDR.N    R1,??DataTable16  ;; 0x50060400
   \        0xA   0x6809             LDR      R1,[R1, #+0]
   \        0xC   0xE001             B.N      ??HASH_GetFlagStatus_1
    622            }
    623            else /* The FLAG is in SR register */
    624            {
    625              tempreg = HASH->SR;
   \                     ??HASH_GetFlagStatus_0: (+1)
   \        0xE   0x....             LDR.N    R1,??DataTable16_14  ;; 0x50060424
   \       0x10   0x6809             LDR      R1,[R1, #+0]
    626            }
    627          
    628            /* Check the status of the specified HASH flag */
    629            if ((tempreg & HASH_FLAG) != (uint32_t)RESET)
   \                     ??HASH_GetFlagStatus_1: (+1)
   \       0x12   0x4201             TST      R1,R0
   \       0x14   0xD001             BEQ.N    ??HASH_GetFlagStatus_2
    630            {
    631              /* HASH is set */
    632              bitstatus = SET;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xE000             B.N      ??HASH_GetFlagStatus_3
    633            }
    634            else
    635            {
    636              /* HASH_FLAG is reset */
    637              bitstatus = RESET;
   \                     ??HASH_GetFlagStatus_2: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
    638            }
    639          
    640            /* Return the HASH_FLAG status */
    641            return  bitstatus;
   \                     ??HASH_GetFlagStatus_3: (+1)
   \       0x1C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x1E   0x4770             BX       LR               ;; return
    642          }
    643          /**
    644            * @brief  Clears the HASH flags.
    645            * @param  HASH_FLAG: specifies the flag to clear. 
    646            *          This parameter can be any combination of the following values:
    647            *            @arg HASH_FLAG_DINIS: Data Input Flag
    648            *            @arg HASH_FLAG_DCIS: Digest Calculation Completion Flag                       
    649            * @retval None
    650            */

   \                                 In section .text, align 2, keep-with-next
    651          void HASH_ClearFlag(uint32_t HASH_FLAG)
    652          {
    653            /* Check the parameters */
    654            assert_param(IS_HASH_CLEAR_FLAG(HASH_FLAG));
    655            
    656            /* Clear the selected HASH flags */
    657            HASH->SR = ~(uint32_t)HASH_FLAG;
   \                     HASH_ClearFlag: (+1)
   \        0x0   0x43C0             MVNS     R0,R0
   \        0x2   0x....             LDR.N    R1,??DataTable16_14  ;; 0x50060424
   \        0x4   0x6008             STR      R0,[R1, #+0]
    658          }
   \        0x6   0x4770             BX       LR               ;; return
    659          /**
    660            * @brief  Checks whether the specified HASH interrupt has occurred or not.
    661            * @param  HASH_IT: specifies the HASH interrupt source to check.
    662            *          This parameter can be one of the following values:
    663            *            @arg HASH_IT_DINI: Data Input interrupt
    664            *            @arg HASH_IT_DCI: Digest Calculation Completion Interrupt
    665            * @retval The new state of HASH_IT (SET or RESET).
    666            */

   \                                 In section .text, align 2, keep-with-next
    667          ITStatus HASH_GetITStatus(uint32_t HASH_IT)
    668          {
    669            ITStatus bitstatus = RESET;
   \                     HASH_GetITStatus: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
    670            uint32_t tmpreg = 0;
   \        0x2   0x2100             MOVS     R1,#+0
    671          
    672            /* Check the parameters */
    673            assert_param(IS_HASH_GET_IT(HASH_IT));  
    674          
    675          
    676            /* Check the status of the specified HASH interrupt */
    677            tmpreg =  HASH->SR;
   \        0x4   0x....             LDR.N    R1,??DataTable16_14  ;; 0x50060424
   \        0x6   0x6809             LDR      R1,[R1, #+0]
    678          
    679            if (((HASH->IMR & tmpreg) & HASH_IT) != RESET)
   \        0x8   0x....             LDR.N    R2,??DataTable16_12  ;; 0x50060420
   \        0xA   0x6812             LDR      R2,[R2, #+0]
   \        0xC   0x4011             ANDS     R1,R1,R2
   \        0xE   0x4201             TST      R1,R0
   \       0x10   0xD001             BEQ.N    ??HASH_GetITStatus_0
    680            {
    681              /* HASH_IT is set */
    682              bitstatus = SET;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xE000             B.N      ??HASH_GetITStatus_1
    683            }
    684            else
    685            {
    686              /* HASH_IT is reset */
    687              bitstatus = RESET;
   \                     ??HASH_GetITStatus_0: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
    688            }
    689            /* Return the HASH_IT status */
    690            return bitstatus;
   \                     ??HASH_GetITStatus_1: (+1)
   \       0x18   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x1A   0x4770             BX       LR               ;; return
    691          }
    692          
    693          /**
    694            * @brief  Clears the HASH interrupt pending bit(s).
    695            * @param  HASH_IT: specifies the HASH interrupt pending bit(s) to clear.
    696            *          This parameter can be any combination of the following values:
    697            *            @arg HASH_IT_DINI: Data Input interrupt
    698            *            @arg HASH_IT_DCI: Digest Calculation Completion Interrupt
    699            * @retval None
    700            */

   \                                 In section .text, align 2, keep-with-next
    701          void HASH_ClearITPendingBit(uint32_t HASH_IT)
    702          {
    703            /* Check the parameters */
    704            assert_param(IS_HASH_IT(HASH_IT));
    705          
    706            /* Clear the selected HASH interrupt pending bit */
    707            HASH->SR = (uint32_t)(~HASH_IT);
   \                     HASH_ClearITPendingBit: (+1)
   \        0x0   0x43C0             MVNS     R0,R0
   \        0x2   0x....             LDR.N    R1,??DataTable16_14  ;; 0x50060424
   \        0x4   0x6008             STR      R0,[R1, #+0]
    708          }
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x5006'0400        DC32     0x50060400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0xFFFB'FF0F        DC32     0xfffbff0f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0x5006'0408        DC32     0x50060408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \        0x0   0x5006'0404        DC32     0x50060404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \        0x0   0x5006'040C        DC32     0x5006040c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \        0x0   0x5006'0410        DC32     0x50060410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \        0x0   0x5006'0414        DC32     0x50060414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \        0x0   0x5006'0418        DC32     0x50060418

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \        0x0   0x5006'041C        DC32     0x5006041c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \        0x0   0x5006'0724        DC32     0x50060724

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \        0x0   0x5006'0728        DC32     0x50060728

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \        0x0   0x5006'072C        DC32     0x5006072c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \        0x0   0x5006'0420        DC32     0x50060420

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \        0x0   0x5006'04F8        DC32     0x500604f8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \        0x0   0x5006'0424        DC32     0x50060424
    709          
    710          /**
    711            * @}
    712            */ 
    713          
    714          /**
    715            * @}
    716            */ 
    717          
    718          /**
    719            * @}
    720            */ 
    721          
    722          /**
    723            * @}
    724            */ 
    725          
    726          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HASH_AutoStartDigest
       0   HASH_ClearFlag
       0   HASH_ClearITPendingBit
       0   HASH_DMACmd
       0   HASH_DataIn
       8   HASH_DeInit
         8   -> RCC_AHB2PeriphResetCmd
       0   HASH_GetDigest
       0   HASH_GetFlagStatus
       0   HASH_GetITStatus
       0   HASH_GetInFIFOWordsNbr
       0   HASH_ITConfig
       4   HASH_Init
       0   HASH_Reset
       4   HASH_RestoreContext
       0   HASH_SaveContext
       0   HASH_SetLastWordValidBitsNbr
       0   HASH_StartDigest
       0   HASH_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
      30  HASH_AutoStartDigest
       8  HASH_ClearFlag
       8  HASH_ClearITPendingBit
      30  HASH_DMACmd
       6  HASH_DataIn
      20  HASH_DeInit
      50  HASH_GetDigest
      32  HASH_GetFlagStatus
      28  HASH_GetITStatus
      12  HASH_GetInFIFOWordsNbr
      28  HASH_ITConfig
      62  HASH_Init
      12  HASH_Reset
      68  HASH_RestoreContext
      56  HASH_SaveContext
      20  HASH_SetLastWordValidBitsNbr
      12  HASH_StartDigest
      18  HASH_StructInit

 
 560 bytes in section .text
 
 560 bytes of CODE memory

Errors: none
Warnings: none
